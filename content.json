{"meta":{"title":"半漠清风","subtitle":"半漠清风","description":"","author":"Virogu","url":"http://virogu.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-08-31T12:00:20.000Z","updated":"2023-09-01T01:33:06.353Z","comments":false,"path":"about/index.html","permalink":"http://virogu.github.io/about/index.html","excerpt":"","text":""},{"title":"404","date":"2023-08-31T11:59:13.000Z","updated":"2023-09-01T01:33:06.352Z","comments":false,"path":"404.html","permalink":"http://virogu.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-31T12:16:31.000Z","updated":"2023-09-01T01:33:06.355Z","comments":false,"path":"friends/index.html","permalink":"http://virogu.github.io/friends/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-08-31T11:59:13.000Z","updated":"2023-09-01T01:33:06.354Z","comments":false,"path":"categories/index.html","permalink":"http://virogu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-08-31T12:00:07.000Z","updated":"2023-09-01T01:33:06.355Z","comments":false,"path":"tags/index.html","permalink":"http://virogu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ADB 其他命令","slug":"docs/ADB/ADB 其他命令","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-qi-ta-ming-ling/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-qi-ta-ming-ling/","excerpt":"","text":"CPU温度 1adb shell cat /sys/class/thermal/thermal_zone7/temp 强制停止程序 1adb shell am force-stop com.xxxx.android.mirror 启动程序 1adb shell am start com.xxxx.xxxx/com.xxxx.PreviewActivity 卸载程序 1adb uninstall com.xxx.xx 12adb forward tcp:10101 tcp:10101adb reverse tcp:9537 tcp:9537 查看CPU 12adb shell getprop ro.board.platformtop -m 20 -s cpu -d 5 获取处理器信息 1adb shell getprop ro.board.platform 查看相机参数执行这个adb命令会打印所有默认参数和当前使用参数 1adb shell dumpsys media.camera 查看某一项参数,使用过滤命令grep(linux), windows下可使用findstr来过滤 1adb shell dumpsys media.camera |grep picture-size 将结果保存到文件中 1adb shell dumpsys media.camera &gt; F:\\Data\\桌面\\camera.txt","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 执行可执行文件","slug":"docs/ADB/ADB 执行可执行文件","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-zhi-xing-ke-zhi-xing-wen-jian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-zhi-xing-ke-zhi-xing-wen-jian/","excerpt":"","text":"1. 推送文件到 /data/local/tmp 例： adb push E:/Test/libXXX.out.so /data/local/tmp 2. 设置文件权限 例： adb shell cd /data/local/tmp chmod 777 libXXX.out.so 3. 设置工作目录为当前目录： export LD_LIBRARY_PATH=. 4. 执行可执行文件 例：执行 libXXX.out.so ./libXXX.out.so","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 文件操作","slug":"docs/ADB/ADB 文件操作","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-wen-jian-cao-zuo/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-wen-jian-cao-zuo/","excerpt":"","text":"删除文件 adb shell rm -rf /dir1/test1/test 批量删除符合条件的文件 adb shell rm -rf /dir1/test1/test* 批量删除符合条件的文件（不区分大小写） adb shell 'find /dir1/test1 -maxdepth 1 -iname \"TesT*\" -exec rm -rf {} \\;'","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 打开设置界面","slug":"docs/ADB/ADB 打开设置界面","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-da-kai-she-zhi-jie-mian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-da-kai-she-zhi-jie-mian/","excerpt":"","text":"adb命令打开手机设置页面 //关闭设置界面 adb shell am force-stop com.android.settings //打开设置主页面 adb shell am start com.android.settings/com.android.settings.Settings //安全 adb shell am start com.android.settings/com.android.settings.SecuritySettings //手机无线信息 adb shell am start com.android.settings/com.android.settings.RadioInfo // 有些界面需要这样打开 APN界面 adb shell am start -n 'com.android.settings/.Settings\\$ApnSettingsActivity' 更多页面 com.android.settings.AccessibilitySettings 辅助功能设置 com.android.settings.ActivityPicker 选择活动 com.android.settings.ApnSettings APN设置 com.android.settings.ApplicationSettings 应用程序设置 com.android.settings.BandMode 设置GSM/UMTS波段 com.android.settings.BatteryInfo 电池信息 com.android.settings.DateTimeSettings 日期和坝上旅游网时间设置 com.android.settings.DateTimeSettingsSetupWizard 日期和时间设置 com.android.settings.DevelopmentSettings 开发者设置 com.android.settings.DeviceAdminSettings 设备管理器 com.android.settings.DeviceInfoSettings 关于手机 com.android.settings.Display 显示——设置显示字体大小及预览 com.android.settings.DisplaySettings 显示设置 com.android.settings.DockSettings 底座设置 com.android.settings.IccLockSettings SIM卡锁定设置 com.android.settings.InstalledAppDetails 语言和键盘设置 com.android.settings.LanguageSettings 语言和键盘设置 com.android.settings.LocalePicker 选择手机语言 com.android.settings.LocalePickerInSetupWizard 选择手机语言 com.android.settings.ManageApplications 已下载（安装）软件列表 com.android.settings.MasterClear 恢复出厂设置 com.android.settings.MediaFormat 格式化手机闪存 com.android.settings.PhysicalKeyboardSettings 设置键盘 com.android.settings.PrivacySettings 隐私设置 com.android.settings.ProxySelector 代理设置 com.android.settings.RadioInfo 手机信息 com.android.settings.RunningServices 正在运行的程序（服务） com.android.settings.SecuritySettings 位置和安全设置 com.android.settings.Settings 系统设置 com.android.settings.SettingsSafetyLegalActivity 安全信息 com.android.settings.SoundSettings 声音设置 com.android.settings.TestingSettings 测试——显示手机信息、电池信息、使用情况统计、Wifi information、服务信息 com.android.settings.TetherSettings 绑定与便携式热点 com.android.settings.TextToSpeechSettings 文字转语音设置 com.android.settings.UsageStats 使用情况统计 com.android.settings.UserDictionarySettings 用户词典 com.android.settings.VoiceInputOutputSettings 语音输入与输出设置 com.android.settings.WirelessSettings 无线和网络设置","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 查看电池记录","slug":"docs/ADB/ADB 查看电池记录","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-cha-kan-dian-chi-ji-lu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-cha-kan-dian-chi-ji-lu/","excerpt":"","text":"adb shell dumpsys batterystats --reset adb shell dumpsys batterystats &gt; E:\\test\\batterystats.txt adb bugreport &gt; E:\\test\\bugreport.txt","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 查看音量","slug":"docs/ADB/ADB 查看音量","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-cha-kan-yin-liang/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-cha-kan-yin-liang/","excerpt":"","text":"获取设备音频流信息 adb shell dumpsys audio 获取当前设备各类音量大小 获取设备的电话音量 - STREAM_VOICE_CALL adb shell media volume --show --stream 0 --get 获取设备的系统音量 - STREAM_SYSTEM adb shell media volume --show --stream 1 --get 获取设备的铃音音量 - STREAM_RING adb shell media volume --show --stream 2 --get 获取设备的音乐音量（多媒体音量 ）- STREAM_MUSIC adb shell media volume --show --stream 3 --get 获取设备的闹钟音量- STREAM_ALARM adb shell media volume --show --stream 4 --get 设置音量大小 示例：设置多媒体音量大小 adb shell media volume --show --stream 3 --set 10 \"\"\" 输出： [v] will control stream=3 (STREAM_MUSIC) [v] will set volume to index=10 [v] Connecting to AudioService \"\"\" # 注：设置系统音量为0（stream=1）后，设备会进入静音模式，之后再修改其他模式音量会失败","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 模拟命令","slug":"docs/ADB/ADB 模拟命令","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-mo-ni-ming-ling/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-mo-ni-ming-ling/","excerpt":"","text":"模拟开关机广播 adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 设置桌面 adb shell \"cmd package set-home-activity com.xxxx/com.xxx.MainActivity\" 模拟输入文字 adb shell \"input keyboard text 'a text'\" 模拟点击屏幕 adb shell \"input keyevent 3\" 在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒） adb shell input swipe 50 250 250 250 500 在 100 100 位置长按 1000毫秒 adb shell input swipe 100 100 100 100 1000 模拟点击屏幕在屏幕上点击坐标点x=50 y=250的位置。 adb shell input tap 50 250 设置默认输入法 adb shell settings put secure default_input_method com.sohu.inputmethod.sogou/.SougouIME adb shell settings put secure default_input_method com.android.inputmethod.latin/.LatinIME 模拟点击HOME键 adb shell \"input keyevent 3\" 模拟点击按键时每个数字与keycode对应表如下 0 --&gt; \"KEYCODE_UNKNOWN\" 1 --&gt; \"KEYCODE_MENU\" 2 --&gt; \"KEYCODE_SOFT_RIGHT\" 3 --&gt; \"KEYCODE_HOME\" 4 --&gt; \"KEYCODE_BACK\" 5 --&gt; \"KEYCODE_CALL\" 6 --&gt; \"KEYCODE_ENDCALL\" 7 --&gt; \"KEYCODE_0\" 8 --&gt; \"KEYCODE_1\" 9 --&gt; \"KEYCODE_2\" 10 --&gt; \"KEYCODE_3\" 11 --&gt; \"KEYCODE_4\" 12 --&gt; \"KEYCODE_5\" 13 --&gt; \"KEYCODE_6\" 14 --&gt; \"KEYCODE_7\" 15 --&gt; \"KEYCODE_8\" 16 --&gt; \"KEYCODE_9\" 17 --&gt; \"KEYCODE_STAR\" 18 --&gt; \"KEYCODE_POUND\" 19 --&gt; \"KEYCODE_DPAD_UP\" 20 --&gt; \"KEYCODE_DPAD_DOWN\" 21 --&gt; \"KEYCODE_DPAD_LEFT\" 22 --&gt; \"KEYCODE_DPAD_RIGHT\" 23 --&gt; \"KEYCODE_DPAD_CENTER\" 24 --&gt; \"KEYCODE_VOLUME_UP\" 25 --&gt; \"KEYCODE_VOLUME_DOWN\" 26 --&gt; \"KEYCODE_POWER\" 27 --&gt; \"KEYCODE_CAMERA\" 28 --&gt; \"KEYCODE_CLEAR\" 29 --&gt; \"KEYCODE_A\" 30 --&gt; \"KEYCODE_B\" 31 --&gt; \"KEYCODE_C\" 32 --&gt; \"KEYCODE_D\" 33 --&gt; \"KEYCODE_E\" 34 --&gt; \"KEYCODE_F\" 35 --&gt; \"KEYCODE_G\" 36 --&gt; \"KEYCODE_H\" 37 --&gt; \"KEYCODE_I\" 38 --&gt; \"KEYCODE_J\" 39 --&gt; \"KEYCODE_K\" 40 --&gt; \"KEYCODE_L\" 41 --&gt; \"KEYCODE_M\" 42 --&gt; \"KEYCODE_N\" 43 --&gt; \"KEYCODE_O\" 44 --&gt; \"KEYCODE_P\" 45 --&gt; \"KEYCODE_Q\" 46 --&gt; \"KEYCODE_R\" 47 --&gt; \"KEYCODE_S\" 48 --&gt; \"KEYCODE_T\" 49 --&gt; \"KEYCODE_U\" 50 --&gt; \"KEYCODE_V\" 51 --&gt; \"KEYCODE_W\" 52 --&gt; \"KEYCODE_X\" 53 --&gt; \"KEYCODE_Y\" 54 --&gt; \"KEYCODE_Z\" 55 --&gt; \"KEYCODE_COMMA\" 56 --&gt; \"KEYCODE_PERIOD\" 57 --&gt; \"KEYCODE_ALT_LEFT\" 58 --&gt; \"KEYCODE_ALT_RIGHT\" 59 --&gt; \"KEYCODE_SHIFT_LEFT\" 60 --&gt; \"KEYCODE_SHIFT_RIGHT\" 61 --&gt; \"KEYCODE_TAB\" 62 --&gt; \"KEYCODE_SPACE\" 63 --&gt; \"KEYCODE_SYM\" 64 --&gt; \"KEYCODE_EXPLORER\" 65 --&gt; \"KEYCODE_ENVELOPE\" 66 --&gt; \"KEYCODE_ENTER\" 67 --&gt; \"KEYCODE_DEL\" 68 --&gt; \"KEYCODE_GRAVE\" 69 --&gt; \"KEYCODE_MINUS\" 70 --&gt; \"KEYCODE_EQUALS\" 71 --&gt; \"KEYCODE_LEFT_BRACKET\" 72 --&gt; \"KEYCODE_RIGHT_BRACKET\" 73 --&gt; \"KEYCODE_BACKSLASH\" 74 --&gt; \"KEYCODE_SEMICOLON\" 75 --&gt; \"KEYCODE_APOSTROPHE\" 76 --&gt; \"KEYCODE_SLASH\" 77 --&gt; \"KEYCODE_AT\" 78 --&gt; \"KEYCODE_NUM\" 79 --&gt; \"KEYCODE_HEADSETHOOK\" 80 --&gt; \"KEYCODE_FOCUS\" 81 --&gt; \"KEYCODE_PLUS\" 82 --&gt; \"KEYCODE_MENU\" 83 --&gt; \"KEYCODE_NOTIFICATION\" 84 --&gt; \"KEYCODE_SEARCH\" 85 --&gt; \"TAG_LAST_KEYCODE\"","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"打开网络ADB调试","slug":"docs/ADB/打开网络ADB调试","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/da-kai-wang-luo-adb-diao-shi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/da-kai-wang-luo-adb-diao-shi/","excerpt":"","text":"service.adb.tcp.port=5555 adb tcpip 5555 adb shell su -c setprop service.adb.tcp.port 5555 // 方式一 adb root adb remount adb pull /system/build.prop 修改 build.prop 文件，添加 service.adb.tcp.port=5555，保存 adb push build.prop /system/build.prop adb shell chmod 0644 /system/build.prop //方式二 adb shell // su // mount -o remount rw /system echo service.adb.tcp.port=5555 &gt;&gt; /system/build.prop","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"ADB 远程调试","slug":"docs/ADB/ADB 远程调试","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/adb/adb-yuan-cheng-diao-shi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/adb/adb-yuan-cheng-diao-shi/","excerpt":"","text":"service.adb.tcp.port=5555 adb tcpip 5555","categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"}]},{"title":"GIT","slug":"docs/Git/GIT","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git/","excerpt":"","text":"版本控制的作用 备份 避免万一机器挂了,磁盘坏了等原因导致代码丢失. 多人协作 提交 (push/commit),拉取 (pull/update) 分支 (branch) 重置 (revert) 日志 (log) … Git 简史 https://git-scm.com/book/zh/v1/起步-Git-简史 同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统（见第三章），可以应付各种复杂的项目开发需求。 GIT 基本 git 是分布式去中心化的 ,意味着”服务器端”的文档结构,管理方法跟客户端完全一致(其实并没有服务器这一说) git init 初始化一个 git 仓库(创建.git 目录) .gitignore 类似svn ignore.更灵活,不同的工程有不同的配置 # 此为注释 – 将被 Git 忽略 # 忽略所有 .a 结尾的文件 *.a # 但 lib.a 除外 !lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO /TODO # 忽略 build/ 目录下的所有文件 build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录下所有扩展名为 txt 的文件 doc/**/*.txt git add 跟踪文件,并将其放到暂存 git add * 暂存当前目录下所有文件 git add *.c 暂存所有.c 文件 git add README 暂存README 文件 git commit 提交暂存 git commit -a 提交所有,包括未暂存但是已跟踪的. git clone 类似 svn checkout,用来 clone 一个仓库 git status 类似svn status 查看当前工作目录的状态 On branch dev_ftd_ftr Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: app/build.gradle modified: app/src/main/java/com/tsinglink/android/mpu/fragment/VideoSettingFragment.java modified: app/src/main/res/layout/fragment_video_setting.xml modified: app/src/main/res/values-en/strings.xml modified: app/src/main/res/values/strings.xml Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) app/TSP210_D_LA1_1H/ no changes added to commit (use \"git add\" and/or \"git commit -a\") #### git分支 - git 项目结构 如下图所示,当前项目有两个分支:`master`分支和 `v1.0`分支 有个 `HEAD` 指针始终指着当前工作目录所在的分支. Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。 ![image](https://git-scm.com/book/en/v2/images/branch-and-history.png) - git branch `branch_name` `创建一个分支` git branch testing ![image](https://git-scm.com/book/en/v2/images/head-to-master.png) 创建分支后,从当前最新的 HEAD 分支处两条支流,但是 HEAD还是指向 master. - git checkout testing `切换到某个分支` ![image](https://git-scm.com/book/en/v2/images/head-to-testing.png) - 分支前移 再做一次提交后,HEAD 随着 testing 都向前移动了. ![image](https://git-scm.com/book/en/v2/images/advance-testing.png) - 再切到 master `git checkout master` ![image](https://git-scm.com/book/en/v2/images/checkout-master.png) - 再做修改并commit ![image](https://git-scm.com/book/en/v2/images/advance-master.png) - 合并分支 `git merge` - 快进合并(fast-forward) ![image](https://git-scm.com/book/en/v2/images/basic-branching-4.png) ![image](https://git-scm.com/book/en/v2/images/basic-branching-5.png) - git branch -d `branch_name` [删除分支] git branch -d hotfix Deleted branch hotfix (3a0874c). ![image](https://git-scm.com/book/en/v2/images/basic-branching-6.png) - 找到共同祖先再合并 ![image](https://git-scm.com/book/en/v2/images/basic-merging-2.png) - 遇到冲突 git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. - 冲突 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD first file change from master ======= first file change from dev_fix_bug1 &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev_fix_bug1 这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置）在这个区段的上半部分（======= 的上半部分），而 dev_fix_bug1 分支所指示的版本在 ======= 的下半部分。 这里可以选择使用上半部分还是下半部分,或者重新来写这一行,只要 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行被完全删除后,就没有冲突了。 - git branch `查看所有分支` // 查看所有分支的最后一次提交记录 git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes #### 远程分支和本地分支 多个人同时开发时,会产生不同的分支.本地的称为本地分支,其他人提交过的分支,成为远程分支.远程分支以**指针** `origin/[分支名]`来表示. `f4265`是本地从服务器 clone 时的提交点. ![image](https://git-scm.com/book/en/v2/images/remote-branches-1.png) 在此之后,本地和远程各提交了两次,形成如下情况: ![image](https://git-scm.com/book/en/v2/images/remote-branches-3.png) 拉取远程仓库 git fetch 见上图 拉取远程仓库并与本地合并 A---B---C master on origin / D---E---F---G master ^ origin/master in your repository A---B---C origin/master / \\ D---E---F---G---H master 推送本地分支到远程 $ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit [new branch] serverfix -&gt; serverfix删除远程分支 $ git push origin –delete serverfixTo https://github.com/schacon/simplegit [deleted] serverfix #### 标签 Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 1. 列出所有标签 git tag2. 给当前提交打上轻量级标签 git tag v1.03. 附注标签 git tag -a v1.4 -m “提交 v1.4版本.修改记录如下:xxxxx”4. 给历史提交打标签 git tag -a v1.2 9fceb02 #### 分支应用 &gt; 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？ &gt; 这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。 比如我们安卓开发过程中,使用SVN 分支的时候,要拷贝一份工作副本到本地,首先拷贝的过程就很慢,还浪费磁盘空间,拖累电脑速度. Android studio 在打开一个新的工程时,需要建立文件索引,会很慢,还会生成大量临时文件,这些临时文件都上 G的.由于每个分支都是不同的副本,加起来体积就很大了,磁盘很快被塞满.另外很多的分支还会导致工程目录太多,不好管理. 另外svn 的分支合并也不太友好.涉及到多个文件夹之间切来切去的. 第三方工程 GIT 分支参考 - ffmpeg 29 个分支 https://github.com/FFmpeg/FFmpeg - 微软的vscode 366 个分支 https://github.com/microsoft/vscode 分支开发模式 1. 根据开发进度分支 一个模块开发之前,先创建一个分支.开发,测试完成后,合并到主分支. 每一次发布,都打上一个标签, 当线上项目有 bug 需要紧急修复,在标签基础上创建临时分支来修补这个 bug.修补完成再合并到当前分支和主分支.最后若有必要,删除临时分支 2. 根据产品分支 主分支是公共项目,或者第一个产品项目;其他分支是在主分支基础上后来衍生出来的其他产品项目 git branch 210b 210c 210d 210e master 每个产品分支都可以使用第一条开发进度来衍生分支 #### 服务器上的 Git - 协议 远程仓库跟本地仓库没有本质区别.服务器上的 git 结构与本地也没有什么不同. 服务器的架设要考虑的实际上是用何种协议来将 git 仓库 与本地仓库保持同步,以及对应的用户权限. git 支持 4 中种协议来实现同步. - 本地协议 **本地用** // 从一个已有仓库 clonegit clone ../gittestCloning into ‘gittest’…done. // 将本地仓库推送到 git 项目git remote add local_proj /opt/git/project.git - HTTP 协议 **配置 HTTP 服务** $ git clone https://example.com/gitproject.git - SSH 协议 **服务器端最简单了** git clone ssh://user@server/project.git - GIT 协议 一般不用,略… 搭建方式: https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE 建议: 大型项目使用 ssh 协议; 小型项目使用第三方托管. 托管服务: github oschina 国内的 github 阿里云 腾讯云 https://blog.csdn.net/lrcoop/article/details/88599487 #### GIT CUI https://git-scm.com/downloads/guis","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git免密拉取(包括ssh,http方式)","slug":"docs/Git/Git免密拉取(包括ssh,http方式)","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-mian-mi-la-qu-bao-gua-ssh-http-fang-shi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-mian-mi-la-qu-bao-gua-ssh-http-fang-shi/","excerpt":"","text":"配置Git免密拉取 基础安装配置 已安装配置好的可以略过 先配置一下用户名和邮箱git config --global user.name 'username' git config --global user.email 'xxx@xxx.com' 生成ssh公钥：ssh-keygen -t rsa -C \"xxx@xxx.com\" ssh免密拉取配置 将 ~/.ssh/id_rsa.pub 公钥文件内容粘贴到GitLab的ssh公钥管理处 使用 git clone git@xxx:xxx.git 测试一下，一般可以直接拉取成功。 但是有些私有云上部署的GitLab不支持使用ssh方式拉取仓库，所以只能用http方式拉取，类似这样 git clone http://XXX/XXX.git 使用http拉取的话默认又需要每次都输入用户名，密码。 http免密拉取配置 执行 git config --global credential.helper store 执行后再查看一下~/.gitconfig文件，会发现多了这样的内容 [credential] helper = store 也可以不执行命令，手动将上面的内容加到 ~/.gitconfig 文件中 注意：这一步必须要做，下面步骤其实也可以省略。这一步执行完成之后下次首次使用http拉取时会提示输入账号名密码，输入后会自动将相关信息保存到.git-credentials文件中，再次拉取时就不需要账号密码了，也可以手动修改.git-credentials文件中的内容，首次使用http拉取时也可以直接免密拉取 cd到用户根目录 ~/ 下，查看有没有 .git-credentials 文件，没有的话则创建一个 touch .git-credentials 打开.git-credentials文件，在里面根据自己的配置添加以下内容 https://{username}:{password}@{git地址} {username} 指的是git的账号名 {password} 指的是git账号名的密码 {git地址} 指的是git仓库的域名或IP和端口号 类似下面这样 http://name:pw12345@git.gitxx.com http://name:pw12345@123.456.789:1234 这时候再用http的方式拉取仓库就不需要输入用户名和密码了","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git删除某个文件的所有提交记录","slug":"docs/Git/Git删除某个文件的所有提交记录","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-shan-chu-mou-ge-wen-jian-de-suo-you-ti-jiao-ji-lu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-shan-chu-mou-ge-wen-jian-de-suo-you-ti-jiao-ji-lu/","excerpt":"","text":"Git删除某个文件的所有提交记录 git filter-branch --index-filter 'git rm --cached --ignore-unmatch 文件路径' -- --all git filter-branch --index-filter 'git rm --cached --ignore-unmatch 文件路径1 文件路径2 文件路径3' -- --all","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git批量修改提交记录中的作者邮箱","slug":"docs/Git/Git批量修改提交记录中的作者邮箱","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-pi-liang-xiu-gai-ti-jiao-ji-lu-zhong-de-zuo-zhe-you-xiang/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-pi-liang-xiu-gai-ti-jiao-ji-lu-zhong-de-zuo-zhe-you-xiang/","excerpt":"","text":"批量修改Git仓库已提交的记录中的提交作者邮箱信息 执行 git log 命令，查看提交历史记录，并记住需要修改作者邮箱的提交 ID。 执行以下命令，将需要修改的提交 ID 替换为实际的值： git filter-branch --env-filter ' OLD_EMAIL=\"原作者邮箱\" CORRECT_NAME=\"新作者名字\" CORRECT_EMAIL=\"新作者邮箱\" if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\" fi if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\" fi ' --tag-name-filter cat -- --branches --tags 该命令会将 Git 仓库中所有分支和标签下的提交历史记录中的指定作者邮箱信息修改为新的作者名字和邮箱信息。 执行命令，强制推送修改后的提交历史记录到远程仓库上。 git push --force --tags origin 'refs/heads/*'","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git生成多个秘钥","slug":"docs/Git/Git生成多个秘钥","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-sheng-cheng-duo-ge-mi-yao/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-sheng-cheng-duo-ge-mi-yao/","excerpt":"","text":"Git配置多个SSH-Key SSH Key 背景 当有多个git账号时，比如： a. 一个gitee，用于公司内部的工作开发；b. 一个github，用于自己进行一些开发活动； 解决方法 生成一个公司用的SSH-Key $ ssh-keygen -t rsa -C 'xxxxx@company.com' -f ~/.ssh/gitee_id_rsa 生成一个github用的SSH-Key $ ssh-keygen -t rsa -C 'xxxxx@qq.com' -f ~/.ssh/github_id_rsa 在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径） # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 4.用ssh命令分别测试 $ ssh -T git@gitee.com $ ssh -T git@github.com 这里以gitee为例，成功的话会返回下图内容","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git基础","slug":"docs/Git/Git基础","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-ji-chu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-ji-chu/","excerpt":"","text":"Git 基础 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 采用了分布式版本库的方式，不必服务器端软件支持，最终可以使得任何代码的提交者都可以成为“中央代码库”。Git的根本思想和基本工作原理主要是在本地复制一个“代码库”，每次提交的代码均是推送到本地代码库中，节约了由于网络带宽所带来的限制，不至于出现提交一次代码要等待很久的情况。另一方面，一旦中央代码库的服务器出现“崩溃”，那么任何“本地库”均可以还原中央代码库。 Git 安装配置 在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 Git 各平台安装包下载地址为：http://git-scm.com/downloads Windows 平台上安装. 安装包下载地址：http://git-scm.com/download/win 下载完成根据引导安装即可，安装选项根据需求选择，大部分安装选项保持默认的即可 Git 配置 Git 仓库中有个 config 文件，专门用来配置或读取相应的工作环境变量，目录是当前仓库下 .git\\config 文件。 在 Windows 一般都是C:\\Users\\userName\\ .gitconfig 用户信息 配置个人的用户名称和电子邮件地址： $ git config --global user.name \"name\" $ git config --global user.email test@mail.com 如果用了 –global 选项，那么更改的配置文件就是全局文件，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 查看配置信息 要检查已有的配置信息，可以使用 git config –list 命令： $ git config --list Git 工作流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程： Git 创建仓库 git init Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。 使用当前目录作为Git仓库，我们只需使它初始化。 git init 该命令执行完后会在当前目录生成一个 .git 目录。 使用我们指定目录作为Git仓库。 git init newrepo 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： $ git add *.java $ git add README $ git commit -m '初始化项目版本' 以上命令将目录下以 .java结尾及 README 文件提交到仓库中。 git clone 我们使用 git clone 从现有 Git 仓库中拷贝项目。 克隆仓库的命令格式为： git clone &lt;repo&gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式： git clone &lt;repo&gt; &lt;directory&gt; 比如，要克隆 MPU_MVS_25A1 项目： $ git clone git@codeup.aliyun.com:5ee35787f0e06f96cfd22c79/MVS/MPU_MVS_25A1.git 执行该命令后，会在当前目录下创建一个名为 MPU_MVS_25A1 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： $ git clone git@codeup.aliyun.com:5ee35787f0e06f96cfd22c79/MVS/MPU_MVS_25A1.git MPU_MVS_25A1_RENAME Git 基本操作 Git 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull。 说明： workspace：工作区 staging area：暂存区/缓存区 local repository：版本库或本地仓库 remote repository：远程仓库 一个简单的操作步骤： $ git init $ git add . $ git commit git init - 初始化仓库。 git add . - 添加文件到暂存区。 git commit - 将暂存区内容添加到仓库中 提交与修改 Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。 下表列出了有关创建与提交你的项目的快照的命令： 命令 说明 git add 添加文件到仓库 git status 查看仓库当前的状态，显示有变更的文件。 git diff 比较文件的不同，即暂存区和工作区的差异。 git commit 提交暂存区到本地仓库。 git reset 回退版本。 git rm 删除工作区文件。 git mv 移动或重命名工作区文件。 提交日志 命令 说明 git log 查看历史提交记录 git blame &lt;file&gt; 以列表形式查看指定文件的历史修改记录 远程操作 命令 说明 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 Git 分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 开始前我们先创建一个测试目录： $ mkdir gitdemo $ cd gitdemo/ $ git init Initialized empty Git repository... $ touch README $ git add README $ git commit -m '第一次版本提交' [master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README Git 分支管理 列出分支 列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch * master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。 当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 $ git branch testing $ git branch * master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。 接下来演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ ls README $ echo 'runoob.com' &gt; test.txt $ git add . $ git commit -m 'add test.txt' [master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch 'testing' $ ls README 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。 $ git checkout master Switched to branch 'master' $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtest Switched to a new branch 'newtest' $ git rm test.txt rm 'test.txt' $ ls README $ touch newText.txt $ git add . $ git commit -am 'removed test.txt、add newText.txt' [newtest c1501a2] removed test.txt、add newText.txt 2 files changed, 1 deletion(-) create mode 100644 newText.txt delete mode 100644 test.txt $ ls README newText.txt $ git checkout master Switched to branch 'master' $ ls README test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 newText.txt 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 newText.txt不存在主分支中。 使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。 删除分支 删除分支命令： git branch -d (branchname) 例如我们要删除 testing 分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master 分支合并 某分支的独立内容，你希望将它合并回到你的主分支。 你可以使用以 git merge 命令将任何分支合并到当前分支中去： $ git branch * master newtest $ ls README test.txt $ git merge newtest Updating 3e92c19..c1501a2 Fast-forward newText.txt | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 newText.txt delete mode 100644 test.txt $ ls README newText.txt 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。 合并完后就可以删除分支: $ git branch -d newtest Deleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： $ git branch * master 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并文件的修改。 执行合并操作时，两个分支中的文件都有修改时，git合并时也会将文件合并，但是如果两个分支都修改了同一个文件的同一部分，那么合并时就很有可能会发生冲突，因为它无法判断哪一个修改是需要的。 比如master分支中 test.txt 文件第一行文本是“11111”，test分支中test.txt 文件第一行文本是“test”，这时在test分支上将master分支合并过来便会冲突。 $ git merge master CONFLICT (add/add): Merge conflict in test.txt Auto-merging test.txt Automatic merge failed; fix conflicts and then commit the result. 这时候我们就需要自己合并冲突的文件了，打开冲突的文件： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD test ======= 11111 &gt;&gt;&gt;&gt;&gt;&gt;&gt; master &lt;&lt;&lt;&lt;&lt;&lt;&lt; 到 ======= 之间的部分是当前的修改，======= 到 &gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的部分是传入的修改，此时就需要我们自己判断需要哪一个修改，修改完成，删除这三段标记，然后保存文件。 比如我们只保留master分支传进来的修改，则把文件内容改成这样: 11111 保存文件后，可以用 git add 来告诉Git文件冲突已经解决，然后再提交： git add test.text git commit 也可以使用其他工具来处理合并冲突，比如电脑里如果装了VisualStudioCode的话，则可以用该程序打开冲突的文件，冲突的地方会高亮显示，而且可以快速选择合并修改的方式（使用当前修改、使用传入的修改、保留双方修改） Git 查看提交历史 Git 提交历史一般常用两个命令： git log - 查看历史提交记录。 git blame - 以列表形式查看指定文件的历史修改记录。 git log 在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下： $ git log - 我们可以用 --oneline 选项来查看历史记录的简洁的版本。 - ``` $ git log --oneline $ git log --oneline 你也可以用 –reverse 参数来逆向显示所有日志。 $ git log --reverse --oneline - ### git blame - 如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下： - ``` git blame &lt;file&gt; git blame 命令是以列表形式显示修改记录，如下实例： $ git blame README # Git 标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 项目发布一个\"1.0\"版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上 \"v1.0\"的标签。 -a 选项意为\"创建一个带注解的标签\"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 $ git tag -a v1.0 -m '发布1.0版本' 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们之前发布了提交 0456798，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 0456798 -m '发布0.9版本' 如果我们要查看所有标签可以使用以下命令： $ git tag # Git GUI Git安装时会自带一个GUI管理软件，但是使用不是很方便，可以使用其他Git管理软件来代替，能够很大的提升工作效率 SourceTree 是一个免费的Git图形化管理软件，有Windows和Mac OS的版本，下载地址：[sourcetree ](https://www.sourcetreeapp.com/)","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"Git换行符设置","slug":"docs/Git/Git换行符设置","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/git/git-huan-xing-fu-she-zhi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/git/git-huan-xing-fu-she-zhi/","excerpt":"","text":"#在vim下面查看当前文本的模式类型，一般为dos,unix :set ff #提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true #提交时转换为LF，检出时不转换（以上问题使用此命令可解决） git config --global core.autocrlf input #提交检出均不转换 git config --global core.autocrlf false","categories":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"}]},{"title":"C  知识点汇总","slug":"docs/C/C  知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/c/c-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/c/c-zhi-shi-dian-hui-zong/","excerpt":"","text":"头文件 数据类型 typedef 类型限定符 定义常量 存储类 引用 vs 指针 struct vs class 成员函数 析构函数 拷贝构造函数 friend 友元 inline 内联函数 继承类型 运算符重载 动态内存 命名空间 预处理器 #include #define 条件编译 预定义宏 信号 线程 强制类型转换 const_cast static_cast dynamic_cast reinterupt_cast 智能指针 unique_ptr shared_ptr weak_ptr 内存空间 头文件 .h 文件中能包含： 类成员数据的声明，但不能赋值 类静态数据成员的定义和赋值，但不建议 类的成员函数的声明 非类成员函数的声明 常数的定义：如：constint a=5; 静态函数的定义 类的内联函数的定义 不能包含： 所有非静态变量（不是类的数据成员）的声明 默认命名空间声明不要放在头文件，using namespace std; 等应放在 .cpp 中，在 .h 文件中使用 std::string 数据类型 类型 位 char 1 个字节 int 4 个字节 short int 2 个字节 long int 8 个字节 float 4 个字节 double 8 个字节 long double 16 个字节 wchar_t 2 或 4 个字节 typedef 使用 typedef 为一个已有的类型取一个新的名字 typedef type newname; 类型限定符 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 定义常量 // 使用 #define 预处理器 #define LENGTH 10 // const 关键字 const int WIDTH = 5; 存储类 存储类 含义 auto 声明变量时根据初始化表达式自动推断该变量的类型 register 用于定义存储在寄存器中而不是 RAM 中的局部变量，用于需要快速访问的变量，不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置） static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享；修饰全局变量时，会使变量的作用域限制在声明它的文件内 extern 全局变量的引用，全局变量对所有的程序文件都是可见 mutable thread_local 仅可在它在其上创建的线程上访问，变量在创建线程时创建，并在销毁线程时销毁，每个线程都有其自己的变量副本 引用 vs 指针 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 struct vs class class 和 struct 定义类的唯一区别是默认的反问权限，struct 默认是 public，class 默认是 private。 成员函数 成员函数可以在类的外部使用范围解析运算符 :: 定义该函数 double Box::getVolume(void) { return length * breadth * height; } 析构函数 析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行 class Line { public: ~Line(); // 这是析构函数声明 private: double length; }; Line::~Line(void) { cout &lt;&lt; \"Object is being deleted\" &lt;&lt; endl; } 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 class Line { public: Line(int len); // 简单的构造函数 Line(const Line &amp;obj); // 拷贝构造函数 private: int *ptr; }; Line::Line(const Line &amp;obj) { cout &lt;&lt; \"调用拷贝构造函数并为指针 ptr 分配内存\" &lt;&lt; endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } friend 友元 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元也可以是一个类，该类被称为友元类类。 class Box { private: double width; public: friend void printWidth(Box box); void setWidth(double wid); }; // 请注意：printWidth() 不是任何类的成员函数 void printWidth(Box box) { /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; \"Width of box : \" &lt;&lt; box.width &lt;&lt;endl; } inline 内联函数 如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 继承类型 class Rectangle: public Shape { ... } 继承类型 说明 public 基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问 protected 基类的公有和保护成员将成为派生类的保护成员。 private 基类的公有和保护成员将成为派生类的私有成员。 运算符重载 class Box { public: double length; // 长度 double breadth; // 宽度 // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) { Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; return box; } }; 动态内存 new 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。如果不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 double* pvalue = new double ··· delete pvalue; 命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称： namespace namespace_name { // 代码声明 } 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称： name::code; // code 可以是变量或函数 使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称： using namespace std; 预处理器 #include include 是一个来自 C 语言的宏命令，它在编译器进行编译之前，即在预编译的时候就会起作用。#include 的作用是把它后面所写的那个文件的内容一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的内容。 系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。 用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到 C++ 安装目录（比如 VC 中可以指定和修改库文件查找路径，Unix 和 Linux 中可以通过环境变量来设定）中查找，最后在系统文件中查找。 #define #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 示例#define PI 3.14159 #define MIN(a,b) (a&lt;b ? a : b) 条件编译 #define DEBUG #ifdef DEBUG cerr &lt;&lt;\"Trace: Inside main function\" &lt;&lt; endl; #endif 预定义宏 宏 描述 __LINE__ 程序编译时包含当前行号 __FILE__ 程序编译时包含当前文件名 __DATE__ 包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期 __TIME__ 包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时 信号 信号 描述 SIGABRT 程序的异常终止，如调用 abort SIGFPE 错误的算术运算，比如除以零或导致溢出的操作 SIGILL 检测非法指令 SIGINT 程序终止(interrupt)信号 SIGSEGV 非法访问内存 SIGTERM 发送到程序的终止请求 C++ 信号处理库提供了 signal 函数，用来捕获突发事件，raise 函数来生成信号： #include &lt;iostream&gt; #include &lt;csignal&gt; #include &lt;unistd.h&gt; using namespace std; void signalHandler( int signum ) { cout &lt;&lt; \"Interrupt signal (\" &lt;&lt; signum &lt;&lt; \") received.\\n\"; exit(signum); } int main () { int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); raise(SIGINT); return 0; } 线程 c++ 11 之后有了标准的线程库 #include &lt;iostream&gt; #include &lt;thread&gt; std::thread::id main_thread_id = std::this_thread::get_id(); void hello() { std::cout &lt;&lt; \"Hello Concurrent World\\n\"; if (main_thread_id == std::this_thread::get_id()) std::cout &lt;&lt; \"This is the main thread.\\n\"; else std::cout &lt;&lt; \"This is not the main thread.\\n\"; } void pause_thread(int n) { std::this_thread::sleep_for(std::chrono::seconds(n)); std::cout &lt;&lt; \"pause of \" &lt;&lt; n &lt;&lt; \" seconds ended\\n\"; } int main() { std::thread t(hello); std::cout &lt;&lt; t.hardware_concurrency() &lt;&lt; std::endl;//可以并发执行多少个(不准确) std::cout &lt;&lt; \"native_handle \" &lt;&lt; t.native_handle() &lt;&lt; std::endl;//可以并发执行多少个(不准确) t.join(); std::thread a(hello); a.detach(); std::thread threads[5]; // 默认构造线程 std::cout &lt;&lt; \"Spawning 5 threads...\\n\"; for (int i = 0; i &lt; 5; ++i) threads[i] = std::thread(pause_thread, i + 1); // move-assign threads std::cout &lt;&lt; \"Done spawning threads. Now waiting for them to join:\\n\"; for (auto &amp;thread : threads) thread.join(); std::cout &lt;&lt; \"All threads joined!\\n\"; } 强制类型转换 const_cast const_cast 用于去除对象的 const 或 volatile 属性 void Func(double&amp; d) { ... } void ConstCast() { const double pi = 3.14; Func(const_cast&lt;double&amp;&gt;(pi)); // No error. } static_cast static_cast 强制转换只会在编译时检查，但没有运行时类型检查来保证转换的安全性。同时，static_cast 也不能去掉 expression 的 const、volitale、或者 __unaligned 属性。 其主要应用场景有： 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 用于基本数据类型之间的转换，如把 int 转换成char，把 int 转换成enum。这种转换的安全性也要开发人员来保证。 把 void 转换成目标类型的空指针. 把任何类型的表达式转换成 void 类型。Sub sub; Base *base_ptr = static_cast&lt;Base*&gt;(&amp;sub); dynamic_cast dynamic_cast 运算符的主要用途：将基类的指针或引用安全地转换成派生类的指针或引用。并用派生类的指针或引用调用非虚函数。 如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数。 前提条件：当我们将 dynamic_cast 用于某种类型的指针或引用时，只有该类型至少含有虚函数时(最简单是基类析构函数为虚函数)，才能进行这种转换。否则，编译器会报错。 在指针类型中，基类指针所指对象为基类类型，在这种情况下 dynamic_cast 在运行时做检查，转换失败，返回结果为 0； 在引用类型中，并不存在空引用，所以引用的 dynamic_cast 检测失败时会抛出一个 bad_cast 异常。 Base * base = new Base; if (Derived *der = dynamic_cast&lt;Derived*&gt;(base)) { cout &lt;&lt; \"转换成功\" &lt;&lt;endl; der-&gt;Show(); } else { cout &lt;&lt; \"转换失败\" &lt;&lt;endl; } reinterupt_cast reinterpret_cast 用来处理无关类型转换，通常为操作数的位模式提供较低层次的重新解释。 推荐使用在： 从指针类型到一个足够大的整数类型 从整数类型或者枚举类型到指针类型 从一个指向函数的指针到另一个不同类型的指向函数的指针 从一个指向对象的指针到另一个不同类型的指向对象的指针 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针 错误的使用 reinterpret_cast 很容易导致程序的不安全，只有将转换后的类型值转换回到其原始类型，这样才是正确使用 reinterpret_cast 方式。 智能指针 unique_ptr 由 unique_ptr 管理的内存，只能被一个对象持有，所以，unique_ptr不支持复制和赋值。想要把一个 unique_ptr 的内存交给另外一个 unique_ptr 对象管理。只能使用 std::move 转移当前对象的所有权。转移之后，当前对象不再持有此内存，新的对象将获得专属所有权。 auto w = std::make_unique&lt;Widget&gt;(); auto w2 = std::move(w); // w2 获得内存所有权，w 此时等于 nullptr unique_ptr在默认情况下和裸指针的大小是一样的，所以内存上没有任何的额外消耗，性能是最优的。 shared_ptr 多个智能指针可以共享同一个对象。shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr，引用计数会 +1。当一个 shared_ptr 离开作用域时，引用计数会 -1。当引用计数为0的时候，则 delete 内存。 auto w = std::make_shared&lt;Widget&gt;(); shared_ptr的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。 weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空。 内存空间 区 秒速 堆 操作系统维护的一块动态分配内存，malloc 在堆上分配的内存块，使用 free 释放内存 栈 由编译器自动分配释放，存放函数的参数值，局部变量的值等 自由存储区 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念 全局区（静态区） 全局变量和静态变量分配在此一块内存中 常量存储区 存储常量字符串, 程序结束后由系统释放","categories":[{"name":"C","slug":"C","permalink":"http://virogu.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://virogu.github.io/tags/C/"}]},{"title":"Kotlin 标准函数","slug":"docs/Kotlin/Kotlin 标准函数","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/kotlin/kotlin-biao-zhun-han-shu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/kotlin/kotlin-biao-zhun-han-shu/","excerpt":"","text":"[TOC] Kotlin标准函数 let函数 let函数会将调用它的对象作为参数传递到Lambda表达式中。 例如有如下方法 fun doStudy(study: Study){ //Study接口中只有readBooks()和doHomeWork()两个方法 if (study != null){ study.readBooks() } if (study != null){ study.doHomeWork() } } 这个时候结合?.操作符合let函数就可以对代码进行优化了，如下所示 fun doStudy(study: Study){ //?.操作符表示对象不为空时正常调用相应的方法，对象为空时就什么都不做 study?.let {stu -&gt; stu.readBooks() //因为let函数可以正常调用，所以对象一定不为空 stu.doHomeWork() } } 然后利用Lambda语言的特性：当Lambda表达式的参数列表中只有一个参数时，可以不用声明参数名，直接用it关键字代替即可。那么代码就可以进一步简化 fun doStudy(study: Study){ study?.let { it.readBooks() it.doHomeWork() } } 注意： let函数是可以处理全局变量判空的问题的，而if判断语句则无法做到这一点，比如我们将doStudy()函数中的参数变成一个全局变量，使用let函数仍然可以正常工作，但使用if判空语句就会提示错误，代码如下所示： var study: Study? = null fun doStudy() { if (study != null) { study.doHomeWork() //这里会报错，下面一行也是 study.readBooks() // } } 调用study的方法会报错是因为全局变量的值随时都可能被其他线程所修改，即使做了判空处理仍然无法保证if语句中的study对象没有空指针的风险。 with函数 with函数 接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式的最后一行作为返回值返回。它可以在连续调用同一个对象的多个方法时让代码变得更加精简。 举个例子： 比如有一个水果列表，现在我们想吃完所有水果，并将结果答应出来，就可以这样写 val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\") val builder = StringBuilder() builder.append(\"Start eating fruits.\\n\") for (fruit in list){ builder.append(fruit).append(\"\\n\") } builder.append(\"Ate all fruits\") val result = builder.toString() println(result) 上面代码，连续调用了多次builder对象的方法，这时候就可以考虑使用with函数了来让代码变得更加精简了。如下所示 val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\") val builder = StringBuilder() val result = with(StringBuilder()){ append(\"Start eating fruits.\\n\") for (fruit in list){ append(fruit).append(\"\\n\") } append(\"Ate all fruits.\") toString() } println(result) 这段代码其实也不难理解，首先我们给with函数第一个参数传入一个StringBuilder对象，那么接下来第二个参数也就是Lambda表达式的上下文就会是这个StringBuilder对象，于是我们在Lambda表达式中就不用使用builder.append()的方式，而是直接使用append()的方式来调用，Lambda的最后一行会作为with函数的返回值返回，最终将结果打印出来，两段代码运行结果是一样的 run函数 run函数的用法和使用场景其实和with函数斯非常类似的，只是稍微做了些语法改动而已。首先run函数是不能直接调用的，而是一定要调用某个对象的run函数才行；其次run函数只接收一个Lambda参数，并且会在Lambda表达式中提供调用对象的上下文。其他方面和with函数是一样的，也会使用Lambda表达式中的最后一行代码作为返回值返回。 现在可以用run函数来改一下吃水果的这段代码，如下所示： val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\") val builder = StringBuilder() val result = builder.run{ append(\"Start eating fruits.\\n\") for (fruit in list){ append(fruit).append(\"\\n\") } append(\"Ate all fruits.\") toString() } println(result) 总体来说变化非常小，只是将调用with函数并传入StringBuilder对象改成了调用StringBuilder对象的run方法，其他没有任何区别。两段代码运行结果都一样。 apply函数 apply函数和run函数也是极其类似的。都要在某个对象上调用，并且只接收一个Lambda参数，也会在Lambda表达式中提供调用对象的上下文，但是apply函数无法指定返回值，而是会返回调用对象本身。 那么现在用apply函数来改写吃水果这段代码，如下所示： val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\") val builder = StringBuilder() val result = builder.apply{ append(\"Start eating fruits.\\n\") for (fruit in list){ append(fruit).append(\"\\n\") } append(\"Ate all fruits.\") } println(result.toString()) 注意这里的代码变化，因为apply函数无法指定返回值，只能返回调用对象本身，因此这里的result实际上是一个StringBuilder对象。所以我们在最后打印的时候还要调用它的toString()方法才行。这段代码运行结果和前面两段仍然完全相同。 also函数 also函数和apply函数用法基本一致的。要在某个对象上调用，并且返回调用对象本身。只不过also函数在lambda中要用一个名称（默认为 it），在 apply中，不必添加其他前缀来访问其成员，或者使用 this引用 . am.also { //使用 it 来调用对象 it.xxx() } am.apply { //使用 this 来调用对象 或者 直接调用对象 this.xxx() xxx() } 小总结： let、run 返回函数体最后一行 apply、also 返回调用对象本身 let、also 函数体调用时默认用 it run、apply 函数体调用时默认用 this with 调用时需要传一个对象，返回函数体最后一行 use函数 使用use函数的对象要实现Closeable方法，并且无论接下来的操作是否引发异常都会自动正确关闭它，比如InputStream就可以使用use函数 常规写法 var input:InputStream? = null try{ input= FileInputStream(File(\"aaaaa\")) //对 input 进行操作 // ...... }finall{ //最后需要调用close（） input?.close() } 使用use函数写法 val input = FileInputStream(File(\"aaaaa\")) input?.use{ //对 input 进行操作 //不需要手动close } use 函数可以极大地简化文件操作的代码 repeat 重复执行指定次数 repeat(5){ println(\"count:$it\") } 等价于 for (i in 0..4) { println(\"count:$i\") } 或者 for (i in 0 until 5) { println(\"count:$i\") } 或者 (0..4).forEach { println(\"count:$i\") } **takeIf 和 takeUnless ** takeIf 传递一个函数参数，如果函数结果为true，返回T对象，否则返回null例如，判断文件是否存在，不存在则返回 var file = File(\"filePath\") if (file.exists()) { //do something } else { return } 使用takeIf: var file = File(\"filePath\").takeIf { it.exists() }?:return false //do something takeUnless 传递一个函数参数，如果函数结果为false，返回T对象，否则返回null","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/tags/Kotlin/"}]},{"title":"Kotlin 扩展函数","slug":"docs/Kotlin/Kotlin 扩展函数","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/kotlin/kotlin-kuo-zhan-han-shu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/kotlin/kotlin-kuo-zhan-han-shu/","excerpt":"","text":"[TOC] 内置扩展函数 IO操作扩展函数 复制文件 复制文件A到文件B val originFile = File(\"$TEST_PATH\\\\copytest1.txt\") val dstFile = File(\"$TEST_PATH\\\\copytest2.txt\") 常规写法 val inputStream = FileInputStream(originFile) val os = FileOutputStream(dstFile) try { val buffer = ByteArray(1024) var len = inputStream.read(buffer) while (len != -1) { os.write(buffer, 0, len) len = inputStream.read(buffer) } } finally { os.flush() os.close() inputStream.close() } use 结合扩展函数InputStream.copyTo()写法 val inputStream = FileInputStream(originFile) val os = FileOutputStream(dstFile) inputStream.use { os.use { output -&gt; it.copyTo(output) } } 使用 File.copyTo()扩展函数直接复制 try { originFile.copyTo(dstFile) } catch (e: Throwable) { e.printStackTrace() } 遍历文件 遍历文件夹下所有文件包括子目录，子文件等 File.walkBottomUp()获取从下到上的顺序访问此目录及其所有内容的顺序。使用深度优先搜索，并在访问所有文件之前访问目录 File.walkTopDown()获取从上到下的顺序访问此目录及其所有内容的顺序。使用深度优先搜索，并在访问所有文件之前访问目录 val path = File(\"E:\\\\Note\\\\MarkDown\") val files = path.walkBottomUp() println(\"walkBottomUp\") files.forEach { println(it.path) } 删除文件 File.deleteRecursively() 删除文件夹下所有文件，包括子目录、子文件 val path = File(\"$TEST_PATH\\\\testDelete - 副本\\\\\") val result = path.deleteRecursively() 函数返回 true 表示全部删除完成，返回 false 表示至少有一个文件没有删除成功 自定义扩展函数 自定义一个List交换两个元素位置的函数 fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) { if (index1 &gt; this.size - 1 || index2 &gt; this.size - 1) { throw IllegalArgumentException(\"index is more than list's size\") } val temp = this[index1] this[index1] = this[index2] this[index2] = temp } @org.junit.jupiter.api.Test fun listSwap() { val list = mutableListOf(1, 2, 3, 4, 5) println(\"origin: $list\") list.swap(2, 3) println(\"after swap: ${list}\") } 测试执行结果： origin: [1, 2, 3, 4, 5] after swap: [1, 2, 4, 3, 5] 扩展函数在不修改某个类源码的情况下,动态地添加新的函数.className.扩展函数不能访问原有类的私有属性 运算符重载 同一运算符在不同的环境所表现的效果不同，如 ”+“ 在两个 Int 值之间表示两者的数值相加，在两个字符串之间表示，将字符串拼接，同时kotlin允许我们将任意两个类型的对象进行”+“运算，或者其他运算符操作。 语法结构：如下，其中operator 为运算符重载的关键字 operator fun plus(a: A): A { //相关逻辑 } 常见的语法糖表达式和实际调用函数对照表： 表达式 函数名 a * b a.times(b) a / b a.div(b) a % b a.rem(b) a + b a.plus(b) a - b a.minus(b) a++ a.inc() a– a.dec() !a a.not() a == b a.equals(b) ”a &gt; b“、”a &lt; b“、”a &gt;= b“、”a &gt;= b“ a.compareTo(b) a..b a.rangeTo(b) a[b] a.get(b) a[b] = c a.set(b, c) a in b b.contains(a) 扩展函数和运算符重载结合 例：重写 String 的 * （即 times) 操作 operator fun String.times(int: Int): String { return StringBuilder().also { s -&gt; repeat(int) { s.append(this) } }.toString() } 使用 val s = \"hello \" * 5 println(s) 结果 hello hello hello hello hello","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/tags/Kotlin/"}]},{"title":"Kotlin 协程篇","slug":"docs/Kotlin/Kotlin 协程篇","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/kotlin/kotlin-xie-cheng-pian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/kotlin/kotlin-xie-cheng-pian/","excerpt":"","text":"[TOC] CoroutineScope 作用域 指定协程执行的范围 CoroutineScope 应该在生命周期明确的实体上实现（或用作字段），这些实体负责启动子协程。例如在Activity中使用协程： class MyActivity : AppCompatActivity(), CoroutineScope by MainScope() { override fun onDestroy() { cancel() // destroy的时候cancel() } fun showSomeData() = launch { // &lt;- extension on current activity, // 主线程 // 也可以切换到其他线程 draw(data) // draw in the main thread } } Lifecycle的扩展中已经定义了一个协程作用域，这个作用范围是默认在主线程执行的，生命周期结束会执行cancel()，所以我们可以直接使用这个作用域就行了: val LifecycleOwner.lifecycleScope: LifecycleCoroutineScope get() = lifecycle.coroutineScope 在Activity中使用协程时就可以用 lifecycleScope 了 lifecycleScope.launch { // do something in main thread launch(Dispatchers.IO) { // do something in io thread } } 在 Fragment 中也是使用 lifecycleScope 作用域，在 ViewModel 中用 viewModelScope GlobalScope 全局的 CoroutineScope，没有绑定到任何Job。GlobalScope 用于启动在整个应用程序生命周期内运行且不会过早取消的顶级协程.应用程序代码通常应使用应用程序定义的[CoroutineScope]。不建议在[GlobalScope]实例上使用[async][CoroutineScope.async]或[launch] [CoroutineScope.launch]。 suspendCoroutine 挂起函数 suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T 获取暂停函数中的当前继续实例，并暂停当前正在运行的协程。也就是阻塞的等待函数返回结果，这个函数类似RxJava 中 Single&lt;T&gt; 的blockGet()操作。 例： lifecycleScope.launch(Dispatchers.IO) { Timber.i(\"start\") val result = suspendCoroutineGetTest() Timber.i(\"result: $result\") Timber.i(\"end:\") } private suspend fun suspendCoroutineGetTest(): String? = suspendCoroutine { runBlocking(Dispatchers.IO) { delay(3000L) } it.resume(\"hhhhh\") } 运行结果： 15:53:43.858 I/MainActivity$onCreate: start 15:53:46.865 I/MainActivity$onCreate: result: hhhhh 15:53:46.865 I/MainActivity$onCreate: end: 使用resumeWithException可以让它抛出异常，调用该方法的地方就可以捕获到该异常，例： lifecycleScope.launch(Dispatchers.IO) { Timber.i(\"start\") try { val result = suspendCoroutineGetTest() Timber.i(\"result: $result\") } catch (e: Throwable) { Timber.e(e) } Timber.i(\"end:\") } private suspend fun suspendCoroutineGetTest(): String? = suspendCoroutine { runBlocking(Dispatchers.IO) { delay(3000L) } it.resumeWithException(IllegalStateException(\"test\")) } 运行结果 2021-02-03 16:01:50.964 I/MainActivity$onCreate: start 2021-02-03 16:01:53.971 E/MainActivity$onCreate: java.lang.IllegalStateException: test ...... 2021-02-03 16:01:53.971 I/MainActivity$onCreate: end: 使用这个函数我们就可以将异步的一些操作改能同步的，或者将一些回调特别多的操作改成同步的。比如进行相机拍照操作就可以这样处理： // 点击拍照按钮 bt_snap.setOnClickListener { bt_snap.isEnabled = false lifecycleScope.launch(Dispatchers.IO) { val byteArray = doTakePicture(mCamera) // .... launch(Dispatchers.Main) { bt_snap.isEnabled = true } } } private suspend fun doTakePicture(camera: Camera?): ByteArray? = suspendCoroutine { if (camera == null) { it.resume(null) return@suspendCoroutine } camera.autoFocus { _, c -&gt; if (c == null) { it.resume(null) return@autoFocus } c.takePicture (null, null, { data, c1 -&gt; if (c1 == null) { it.resume(null) return@takePicture } try { c1.startPreview() } finally { it.resume(data) return@takePicture } }) } } 在此函数中，resume和resumeWithException可以在运行暂停功能的同一堆栈中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。随后调用任何恢复函数将产生一个java.lang.IllegalStateException: Already resumed的异常。另外，如果此函数中使用了resumeWithException，在调用它的地方也要进行异常捕获处理。 suspendCancellableCoroutine 可取消的挂起函数 上面讲的suspendCoroutine 挂起函数执行开始之后是不可取消的，比如： lifecycleScope.launch(Dispatchers.Main) { val job = launch(Dispatchers.IO) { Timber.i(\"start\") //这里三秒后才会返回结果 val result = suspendCoroutineGetTest() Timber.i(\"result: $result\") Timber.i(\"end:\") } // 1秒后取消 launch(Dispatchers.IO) { delay(1000L) Timber.i(\"cancel job\") job.cancel() } } private suspend fun suspendCoroutineGetTest(): String? = suspendCoroutine { runBlocking(Dispatchers.IO) { delay(3000L) } Timber.i(\"suspendCoroutine return \") it.resume(\"hhhhh\") } 预期结果是1秒后 job 被取消，suspendCoroutineGetTest 将不再返回结果，而实际结果是： 00.789 I/MainActivity$onCreate$1$job: start 01.796 I/MainActivity$onCreate: cancel job 03.804 I/MainActivity: suspendCoroutine return 03.804 I/MainActivity$onCreate$1$job: result: hhhhh 03.804 I/MainActivity$onCreate$1$job: end: job 调用了cancel方法之后，挂起函数还在执行，并且整个job还在正常运行，这显然不符合我们预期要求。如果要让job能够取消就需要使用suspendCancellableCoroutine private suspend fun suspendCoroutineGetTest(): String? = suspendCancellableCoroutine { runBlocking(Dispatchers.IO) { delay(3000L) } Timber.i(\"suspendCoroutine return \") it.resume(\"hhhhh\") } 这时候再运行： 52.797 I/MainActivity$onCreate$1$job: start 53.806 I/MainActivity$onCreate: cancel job 55.806 I/MainActivity: suspendCoroutine return 55.810 E/MainActivity$onCreate$1$job: kotlinx.coroutines.JobCancellationException: Job was cancelled; 三秒后挂起函数返回结果时便抛出了异常，job也不会继续执行。 上面讲到挂起函数调用resume之后再次resume就会抛出异常，但是如果是使用 suspendCancellableCoroutine 就可以通过 isActive 来判断是否需要再 resume 了: Timber.i(\"suspendCoroutine return \") it.resume(\"hhhhh\") if(it.isActive) { it.resume(\"hhhhh\") } if(it.isActive) { //这里再次调用resume也不会再执行了，因为上面已经resume了，isActive也已经变成了false it.resume(\"hhhhh\") } 所以我们在使用挂起函数时最好使用 suspendCancellableCoroutine 而不是 suspendCoroutine 。另外，这个挂起函数中有三个标志：isActive 函数如果没有完成或取消则返回 trueisCompleted 由于任何原因完成此继续操作时，都返回 true 。被取消的继续也被视为完成。isCancelled 如果调用了job的cancel()方法，之后则返回 true 一般情况下使用isActive就可以满足需求了。 Flow 什么是Flow Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流 类似 RxJava 的 Observable 、 Flowable 等。用生产者和消费者来做对比，简单来讲就可以一边生产一边消费的作用。 使用Flow 先看一个简单的使用例子 lifecycleScope.launch { launch { //验证Flow没有阻塞线程 repeat(3){ delay(1000) Timber.i(\"I'm not blocked: $it\") } } flow{ repeat(3){ delay(1000) emit(it) } }.collect { Timber.i(\"collect: $it\") } } 运行结果 00.480 I: collect : 0 00.481 I: I'm not blocked : 0 01.484 I: collect : 1 01.484 I: I'm not blocked : 1 02.486 I: collect : 2 02.487 I: I'm not blocked : 2 其中Flow的接口，只有一个collect函数。和RXjava相比的话，可以理解为 collect() 对应subscribe()，而 emit() 对应onNext()。 切换线程 默认情况没有切换线程的话flow的生产者和消费者是同步非阻塞的： lifecycleScope.launch { flow{ repeat(3){ delay(1000) Timber.i(\"emit on: ${Thread.currentThread().name}\") emit(it) } }.collect { Timber.i(\"collect on ${Thread.currentThread().name} : $it\") } } 输出结果： I: emit on: main I: collect on main : 0 I: emit on: main I: collect on main : 1 I: emit on: main I: collect on main : 2 切换线程，相比Rxjava中使用 observeOn、subscribeOn 来切换线程，flow 会更加简单。只需使用 flowOn，如下： lifecycleScope.launch { flow{ repeat(3){ delay(1000) Timber.i(\"emit on: ${Thread.currentThread().name}\") emit(it) } }.flowOn(Dispatchers.IO).collect { Timber.i(\"collect on ${Thread.currentThread().name} : $it\") } } 输出结果： I: emit on: DefaultDispatcher-worker-1 I: collect on main : 0 I: emit on: DefaultDispatcher-worker-2 I: collect on main : 1 I: emit on: DefaultDispatcher-worker-1 I: collect on main : 2 flow builder是运行在 flowOn() 指定的线程中， clollect() 所在线程则取决于整个 flow 处于哪个 CoroutineScope 下。 Flow 什么时候开始执行 Flow 是一种类似于序列的冷流 ， flow 构建器中的代码直到流被收集的时候才运行。 例：先初始化一个flow，三秒后再collect Timber.i(\"start\") val f = flow{ repeat(3){ delay(1000) Timber.i(\"emit on: ${Thread.currentThread().name}\") emit(it) } }.flowOn(Dispatchers.IO) delay(3000) f.collect { Timber.i(\"collect on ${Thread.currentThread().name} : $it\") } 运行结果 46.180 I: start 50.211 I: emit on: DefaultDispatcher-worker-1 50.212 I: collect on main : 0 ...... Flow 怎么取消 Flow是需要写在 lanuch 中的，所以取消的话只需要调用launch的cancel()把launch取消就行了 val d = launch { flow{ repeat(3){ delay(1000) Timber.i(\"emit on: ${Thread.currentThread().name}\") emit(it) } }.flowOn(Dispatchers.IO).collect { Timber.i(\"collect on ${Thread.currentThread().name} : $it\") } } delay(1000) d.cancel() 这样一秒后这个flow操作就会被取消 Flow 可以用在哪里 用处一：后台进行下载操作，主线程更新下载进度： doDownload().flowOn(Dispatchers.IO).collect { Timber.i(\"下载进度：$it\") } private fun doDownload() = flow { repeat(100){ delay(10) emit(it) } } 运行结果： I: 下载进度：0 I: 下载进度：1 I: 下载进度：2 I: 下载进度：3 ...... I: 下载进度：98 I: 下载进度：99 用法二：后台耗时获取数据，后台一边获取，主线程一边处理。比如获取大量设备列表，后台可以分批进行获取，获取一批便emit一批。 lifecycleScope.launch { Timber.i(\"start\") var count = 0 getDevices().flowOn(Dispatchers.IO).buffer().collect { count++ Timber.i(\"获取到 ${it.size} 个设备，开始更新列表\") } Timber.i(\"end, count: $count\") } private fun getDevices() = flow { val list: MutableList&lt;Int&gt; = ArrayList() repeat(1000) { i -&gt; list.add(i) } repeat(100) { delay(100) //Timber.i(\"emit: $it\") emit(list) } } 上面是模拟一次获取1000个设备，获取100次 I: start I: 获取到 1000 个设备，开始更新列表 I: 获取到 1000 个设备，开始更新列表 ...... I: end, count: 100 Flow 其他操作符 例子： foo().collect { println(it) } repeat(10) { delay(100) emit(it) } 结果： 0 1 ... 9 map 使用map我们可以将最终结果映射为其他类型，融合了Rxjava的map与flatMap的功能代码如下所示： foo().map { \"转换成了String : $it\" }.collect { println(it) } 结果： 转换成了String : 0 转换成了String : 1 ... 转换成了String : 9 filter 通过 filter 可以对结果添加过滤条件，如下所示，仅打印出大于7的值 foo().filter { it &gt; 7 }.collect { println(it) } 结果： 8 9 transform transform可以自定义转换逻辑，除了可以实现filter和map的功能，还可以实现其他功能 foo().transform { if(it &gt; 7){ emit(\"transform to string :$it\") emit(\"emit second :$it\") } }.collect { println(it) } 运行结果： transform to string :8 emit second :8 transform to string :9 emit second :9 末端操作符 上面常用的collect就是一个末端操作符，除此之外还有toList、reduce、fold、asLiveData等操作符toList 就如字面意思，把所有结果转成List数组reduce 可以把所有结果累加起来： val d = foo().reduce { accumulator, value -&gt; accumulator + value } println(d) 结果: 45 asLiveData 将Flow转成LiveData，通过LiveData来监听 emit 的数据： val liveData = getDevices().flowOn(Dispatchers.IO).buffer().asLiveData() liveData.observe(this@MainActivity, { count++ Timber.i(\"count: $count\") }) 运行结果： I: start I: count: 1 I: count: 2 I: count: 3 ... ... I: count: 100 协程背压 Kotlin流程设计中的所有函数都标有suspend修饰符，具有在不阻塞线程的情况下挂起调用程序执行的强大功能。因此，当流的收集器不堪重负时，它可以简单地挂起发射器，并在准备好接受更多元素时稍后将其恢复。 buffer 操作符 例如，发射者需要100毫秒处理并产生一个数据，而收集者需要200毫秒来处理这个数据，这时候发射者发就需要等收集者处理完上个数据再去花费100毫秒处理产生一个新数据，这样一个周期就是300毫秒，而使用 buffer操作符就可以并发运行流中发射元素的代码以及收集的代码， 当发射者发射数据时，收集者还没处理完，会将这个数据先缓存下来，收集者处理完上一个数据之后立马就可以处理下一个数据。这样除了第一个周期是300毫秒，接下来的每个周期都是200毫秒，会节省很多时间。默认可以无限制添加数据，但是超出默认缓存区域大小时，会 suspend 暂停。buffer() 函数体可以传两个参数来自行定义缓存机制 buffer(capacity: Int = BUFFERED, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND) 前面的获取设备列表的演示就加上了buffer。 println(\"start\") var count = 0 getDevices().flowOn(Dispatchers.IO).conflate().collect { count++ delay(200) println(\"获取到 ${it.size} 个设备，开始更新列表\") } println(\"end, count: $count\") conflate 操作符 用了 conflate 操作符，当发射者发射数据时，收集者还在处理上一个数据时则会跳过这个值，上面例子中buffer() 改成 conflate() 接口如下： println(\"start\") var count = 0 getDevices().flowOn(Dispatchers.IO).conflate().collect { count++ delay(200) println(\"获取到 ${it.size} 个设备，开始更新列表\") } println(\"end, count: $count\") 输出结果： ... ... 获取到 1000 个设备，开始更新列表 end, count: 11 只处理了11个 collectLatest()操作符 只处理最新的数据，这看上去似乎与 conflate 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。 var count = 0 getDevices().flowOn(Dispatchers.IO).collectLatest { delay(500) count++ println(\"获取到 ${it.size} 个设备，开始更新列表\") } println(\"end, count: $count\") 处理的时候延时500毫秒，而发送间隔只有100毫秒，所以每次发送时都会把前面的处理取消掉，因此只有最后一个结果能被处理 start 获取到 1000 个设备，开始更新列表 end, count: 1 组合多个流 Zip zip 操作符可以组合两个流中的相关值： val nums = (1..6).onEach { delay(10) }.asFlow() // 数字 1..3 val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(50) } // 字符串 nums.zip(strs) { a, b -&gt; \"$a -&gt; $b\" }.collect { println(it) } 输出结果 1 -&gt; one 2 -&gt; two 3 -&gt; three Combine 当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。也就是说当两个流中任何一个流产生了新的流的时候，并且这两个流都已经有值发射了，就将这两个流当前最新的值组合在一起。 val nums = (1..6).asFlow().onEach { delay(10) } val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(50) } nums.combine(strs) { a, b -&gt; \"$a -&gt; $b\" }.collect { println(it) } 输出结果 4 -&gt; one 5 -&gt; one 6 -&gt; one 6 -&gt; two 6 -&gt; three","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/tags/Kotlin/"}]},{"title":"Emoji表情","slug":"docs/MarkDown/Emoji表情","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/markdown/emoji-biao-qing/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/markdown/emoji-biao-qing/","excerpt":"","text":"Emoji表情 将对应emoji表情的符号码复制后输入你的markdown文本即可显示emoji表情。如:blush:，显示为😊 注：有些编辑器可能不支持显示表情 人物 syntax preview syntax preview syntax preview :bowtie: :smile: 😄 :laughing: 😆 :blush: 😊 :smiley: 😃 :relaxed: ☺ :smirk: 😏 :heart_eyes: 😍 :kissing_heart: 😘 :kissing_closed_eyes: 😚 :flushed: 😳 :relieved: 😌 :satisfied: 😆 :grin: 😁 :wink: 😉 :stuck_out_tongue_winking_eye: 😜 :stuck_out_tongue_closed_eyes: 😝 :grinning: 😀 :kissing: 😗 :kissing_smiling_eyes: 😙 :stuck_out_tongue: 😛 :sleeping: 😴 :worried: 😟 :frowning: 😦 :anguished: 😧 :open_mouth: 😮 :grimacing: 😬 :confused: 😕 :hushed: 😯 :expressionless: 😑 :unamused: 😒 :sweat_smile: 😅 :sweat: 😓 :disappointed_relieved: 😥 :weary: 😩 :pensive: 😔 :disappointed: 😞 :confounded: 😖 :fearful: 😨 :cold_sweat: 😰 :persevere: 😣 :cry: 😢 :sob: 😭 :joy: 😂 :astonished: 😲 :scream: 😱 :neckbeard: :tired_face: 😫 :angry: 😠 :rage: 😡 :triumph: 😤 :sleepy: 😪 :yum: 😋 :mask: 😷 :sunglasses: 😎 :dizzy_face: 😵 :imp: 👿 :smiling_imp: 😈 :neutral_face: 😐 :no_mouth: 😶 :innocent: 😇 :alien: 👽 :yellow_heart: 💛 :blue_heart: 💙 :purple_heart: 💜 :heart: ❤ :green_heart: 💚 :broken_heart: 💔 :heartbeat: 💓 :heartpulse: 💗 :two_hearts: 💕 :revolving_hearts: 💞 :cupid: 💘 :sparkling_heart: 💖 :sparkles: ✨ :star: ⭐ :star2: 🌟 :dizzy: 💫 :boom: 💥 :collision: 💥 :anger: 💢 :exclamation: ❗ :question: ❓ :grey_exclamation: ❕ :grey_question: ❔ :zzz: 💤 :dash: 💨 :sweat_drops: 💦 :notes: 🎶 :musical_note: 🎵 :fire: 🔥 :hankey: 💩 :poop: 💩 :: 💩 :+1: :+1: :thumbsup: 👍 :-1: :-1: :thumbsdown: 👎 :ok_hand: 👌 :punch: 👊 :facepunch: 👊 :fist: ✊ :v: ✌ :wave: 👋 :hand: ✋ :raised_hand: ✋ :open_hands: 👐 :point_up: ☝ :point_down: 👇 :point_left: 👈 :point_right: 👉 :raised_hands: 🙌 :pray: 🙏 :point_up_2: 👆 :clap: 👏 :muscle: 💪 :metal: 🤘 :fu: 🖕 :walking: 🚶 :runner: 🏃 :running: 🏃 :couple: 👫 :family: 👪 :two_men_holding_hands: 👬 :two_women_holding_hands: 👭 :dancer: 💃 :dancers: 👯 :ok_woman: 🙆♀ :no_good: 🙅 :information_desk_person: 💁 :raising_hand: 🙋 :bride_with_veil: 👰 :person_with_pouting_face: :person_with_pouting_face: :person_frowning: :person_frowning: :bow: 🙇 :couplekiss: 💏 :couple_with_heart: 💑 :massage: 💆 :haircut: 💇 :nail_care: 💅 :boy: 👦 :girl: 👧 :woman: 👩 :man: 👨 :baby: 👶 :older_woman: 👵 :older_man: 👴 :person_with_blond_hair: :person_with_blond_hair: :man_with_gua_pi_mao: 👲 :man_with_turban: 👳♂ :construction_worker: 👷 :cop: 👮 :angel: 👼 :princess: 👸 :smiley_cat: 😺 :smile_cat: 😸 :heart_eyes_cat: 😻 :kissing_cat: 😽 :smirk_cat: 😼 :scream_cat: 🙀 :crying_cat_face: 😿 :joy_cat: 😹 :pouting_cat: 😾 :japanese_ogre: 👹 :japanese_goblin: 👺 :see_no_evil: 🙈 :hear_no_evil: 🙉 :speak_no_evil: 🙊 :guardsman: 💂♂ :skull: 💀 :feet: 🐾 :lips: 👄 :kiss: 💋 :droplet: 💧 :ear: 👂 :eyes: 👀 :nose: 👃 :tongue: 👅 :love_letter: 💌 :bust_in_silhouette: 👤 :busts_in_silhouette: 👥 :speech_balloon: 💬 :thought_balloon: 💭 :feelsgood: :finnadie: :goberserk: :godmode: :hurtrealbad: :rage1: :rage2: :rage3: :rage4: :suspect: :trollface: 自然 syntax preview syntax preview syntax preview :sunny: ☀ :umbrella: ☔ :cloud: ☁ :snowflake: ❄ :snowman: ⛄ :zap: ⚡ :cyclone: 🌀 :foggy: 🌁 :ocean: 🌊 :cat: 🐱 :dog: 🐶 :mouse: 🐭 :hamster: 🐹 :rabbit: 🐰 :wolf: 🐺 :frog: 🐸 :tiger: 🐯 :koala: 🐨 :bear: 🐻 :pig: 🐷 :pig_nose: 🐽 :cow: 🐮 :boar: 🐗 :monkey_face: 🐵 :monkey: 🐒 :horse: 🐴 :racehorse: 🐎 :camel: 🐫 :sheep: 🐑 :elephant: 🐘 :panda_face: 🐼 :snake: 🐍 :bird: 🐦 :baby_chick: 🐤 :hatched_chick: 🐥 :hatching_chick: 🐣 :chicken: 🐔 :penguin: 🐧 :turtle: 🐢 :bug: 🐛 :honeybee: 🐝 :ant: 🐜 :beetle: 🐞 :snail: 🐌 :octopus: 🐙 :tropical_fish: 🐠 :fish: 🐟 :whale: 🐳 :whale2: 🐋 :dolphin: 🐬 :cow2: 🐄 :ram: 🐏 :rat: 🐀 :water_buffalo: 🐃 :tiger2: 🐅 :rabbit2: 🐇 :dragon: 🐉 :goat: 🐐 :rooster: 🐓 :dog2: 🐕 :pig2: 🐖 :mouse2: 🐁 :ox: 🐂 :dragon_face: 🐲 :blowfish: 🐡 :crocodile: 🐊 :dromedary_camel: 🐪 :leopard: 🐆 :cat2: 🐈 :poodle: 🐩 :paw_prints: 🐾 :bouquet: 💐 :cherry_blossom: 🌸 :tulip: 🌷 :four_leaf_clover: 🍀 :rose: 🌹 :sunflower: 🌻 :hibiscus: 🌺 :maple_leaf: 🍁 :leaves: 🍃 :fallen_leaf: 🍂 :herb: 🌿 :mushroom: 🍄 :cactus: 🌵 :palm_tree: 🌴 :evergreen_tree: 🌲 :deciduous_tree: 🌳 :chestnut: 🌰 :seedling: 🌱 :blossom: 🌼 :ear_of_rice: 🌾 :shell: 🐚 :globe_with_meridians: 🌐 :sun_with_face: 🌞 :full_moon_with_face: 🌝 :new_moon_with_face: 🌚 :new_moon: 🌑 :waxing_crescent_moon: 🌒 :first_quarter_moon: 🌓 :full_moon: 🌕 :waning_gibbous_moon: 🌖 :last_quarter_moon: 🌗 :waning_crescent_moon: 🌘 :last_quarter_moon_with_face: 🌜 :first_quarter_moon_with_face: 🌛 :moon: 🌔 :earth_africa: 🌍 :earth_americas: 🌎 :earth_asia: 🌏 :volcano: 🌋 :milky_way: 🌌 :partly_sunny: ⛅ :octocat: :squirrel: :squirrel: :waxing_gibbous_moon: 🌔 物体 syntax preview syntax preview syntax preview :bamboo: 🎍 :gift_heart: 💝 :dolls: 🎎 :school_satchel: 🎒 :mortar_board: 🎓 :flags: 🎏 :fireworks: 🎆 :sparkler: 🎇 :wind_chime: 🎐 :rice_scene: 🎑 :jack_o_lantern: 🎃 :ghost: 👻 :santa: 🎅 :christmas_tree: 🎄 :gift: 🎁 :bell: 🔔 :no_bell: 🔕 :tanabata_tree: 🎋 :tada: 🎉 :confetti_ball: 🎊 :balloon: 🎈 :crystal_ball: 🔮 :cd: 💿 :dvd: 📀 :floppy_disk: 💾 :camera: 📷 :video_camera: 📹 :movie_camera: 🎥 :computer: 💻 :tv: 📺 :iphone: 📱 :phone: ☎ :telephone: ☎ :telephone_receiver: 📞 :pager: 📟 :fax: 📠 :minidisc: 💽 :vhs: 📼 :sound: 🔉 :speaker: 🔈 :mute: 🔇 :loudspeaker: 📢 :mega: 📣 :hourglass: ⌛ :hourglass_flowing_sand: ⏳ :alarm_clock: ⏰ :watch: ⌚ :radio: 📻 :satellite: 📡 :loop: ➿ :mag: 🔍 :mag_right: 🔎 :unlock: 🔓 :lock: 🔒 :lock_with_ink_pen: 🔏 :closed_lock_with_key: 🔐 :key: 🔑 :bulb: 💡 :flashlight: 🔦 :high_brightness: 🔆 :low_brightness: 🔅 :electric_plug: 🔌 :battery: 🔋 :calling: 📲 :email: ✉ :mailbox: 📫 :postbox: 📮 :bath: 🛀 :bathtub: 🛁 :shower: 🚿 :toilet: 🚽 :wrench: 🔧 :nut_and_bolt: 🔩 :hammer: 🔨 :seat: 💺 :moneybag: 💰 :yen: 💴 :dollar: 💵 :pound: 💷 :euro: 💶 :credit_card: 💳 :money_with_wings: 💸 :e-mail: :e-mail: :inbox_tray: 📥 :outbox_tray: 📤 :envelope: ✉ :incoming_envelope: 📨 :postal_horn: 📯 :mailbox_closed: 📪 :mailbox_with_mail: 📬 :mailbox_with_no_mail: 📭 :door: 🚪 :smoking: 🚬 :bomb: 💣 :gun: 🔫 :hocho: 🔪 :pill: 💊 :syringe: 💉 :page_facing_up: 📄 :page_with_curl: 📃 :bookmark_tabs: 📑 :bar_chart: 📊 :chart_with_upwards_trend: 📈 :chart_with_downwards_trend: 📉 :scroll: 📜 :clipboard: 📋 :calendar: 📆 :date: 📅 :card_index: 📇 :file_folder: 📁 :open_file_folder: 📂 :scissors: ✂ :pushpin: 📌 :paperclip: 📎 :black_nib: ✒ :pencil2: ✏ :straight_ruler: 📏 :triangular_ruler: 📐 :closed_book: 📕 :green_book: 📗 :blue_book: 📘 :orange_book: 📙 :notebook: 📓 :notebook_with_decorative_cover: 📔 :ledger: 📒 :books: 📚 :bookmark: 🔖 :microscope: 🔬 :telescope: 🔭 :name_badge: 📛 :newspaper: 📰 :football: 🏈 :basketball: 🏀 :soccer: ⚽ :baseball: ⚾ :tennis: 🎾 :8ball: 🎱 :rugby_football: 🏉 :bowling: 🎳 :golf: ⛳ :mountain_bicyclist: 🚵 :bicyclist: 🚴 :horse_racing: 🏇 :snowboarder: 🏂 :swimmer: 🏊 :surfer: 🏄 :ski: 🎿 :spades: ♠ :hearts: ♥ :clubs: ♣ :diamonds: ♦ :gem: 💎 :ring: 💍 :trophy: 🏆 :musical_score: 🎼 :musical_keyboard: 🎹 :violin: 🎻 :space_invader: 👾 :video_game: 🎮 :black_joker: 🃏 :flower_playing_cards: 🎴 :game_die: 🎲 :dart: 🎯 :mahjong: 🀄 :clapper: 🎬 :memo: 📝 :pencil: 📝 :book: 📖 :art: 🎨 :microphone: 🎤 :headphones: 🎧 :trumpet: 🎺 :saxophone: 🎷 :guitar: 🎸 :shoe: 👞 :sandal: 👡 :high_heel: 👠 :lipstick: 💄 :boot: 👢 :shirt: 👕 :tshirt: 👕 :necktie: 👔 :womans_clothes: 👚 :dress: 👗 :running_shirt_with_sash: 🎽 :jeans: 👖 :kimono: 👘 :bikini: 👙 :ribbon: 🎀 :tophat: 🎩 :crown: 👑 :womans_hat: 👒 :mans_shoe: 👞 :closed_umbrella: 🌂 :briefcase: 💼 :handbag: 👜 :pouch: 👝 :purse: 👛 :eyeglasses: 👓 :fishing_pole_and_fish: 🎣 :coffee: ☕ :tea: 🍵 :sake: 🍶 :baby_bottle: 🍼 :beer: 🍺 :beers: 🍻 :cocktail: 🍸 :tropical_drink: 🍹 :wine_glass: 🍷 :fork_and_knife: 🍴 :pizza: 🍕 :hamburger: 🍔 :fries: 🍟 :poultry_leg: 🍗 :meat_on_bone: 🍖 :spaghetti: 🍝 :curry: 🍛 :fried_shrimp: 🍤 :bento: 🍱 :sushi: 🍣 :fish_cake: 🍥 :rice_ball: 🍙 :rice_cracker: 🍘 :rice: 🍚 :ramen: 🍜 :stew: 🍲 :oden: 🍢 :dango: 🍡 :egg: 🥚 :bread: 🍞 :doughnut: 🍩 :custard: 🍮 :icecream: 🍦 :ice_cream: 🍨 :shaved_ice: 🍧 :birthday: 🎂 :cake: 🍰 :cookie: 🍪 :chocolate_bar: 🍫 :candy: 🍬 :lollipop: 🍭 :honey_pot: 🍯 :apple: 🍎 :green_apple: 🍏 :tangerine: 🍊 :lemon: 🍋 :cherries: 🍒 :grapes: 🍇 :watermelon: 🍉 :strawberry: 🍓 :peach: 🍑 :melon: 🍈 :banana: 🍌 :pear: 🍐 :pineapple: 🍍 :sweet_potato: 🍠 :eggplant: 🍆 :tomato: 🍅 :corn: 🌽 地点 syntax preview syntax preview syntax preview :house: 🏠 :house_with_garden: 🏡 :school: 🏫 :office: 🏢 :post_office: 🏣 :hospital: 🏥 :bank: 🏦 :convenience_store: 🏪 :love_hotel: 🏩 :hotel: 🏨 :wedding: 💒 :church: ⛪ :department_store: 🏬 :european_post_office: 🏤 :city_sunrise: 🌇 :city_sunset: 🌆 :japanese_castle: 🏯 :european_castle: 🏰 :tent: ⛺ :factory: 🏭 :tokyo_tower: 🗼 :japan: 🗾 :mount_fuji: 🗻 :sunrise_over_mountains: 🌄 :sunrise: 🌅 :stars: 🌠 :statue_of_liberty: 🗽 :bridge_at_night: 🌉 :carousel_horse: 🎠 :rainbow: 🌈 :ferris_wheel: 🎡 :fountain: ⛲ :roller_coaster: 🎢 :ship: 🚢 :speedboat: 🚤 :boat: ⛵ :sailboat: ⛵ :rowboat: 🚣 :anchor: ⚓ :rocket: 🚀 :airplane: ✈ :helicopter: 🚁 :steam_locomotive: 🚂 :tram: 🚊 :mountain_railway: 🚞 :bike: 🚲 :aerial_tramway: 🚡 :suspension_railway: 🚟 :mountain_cableway: 🚠 :tractor: 🚜 :blue_car: 🚙 :oncoming_automobile: 🚘 :car: 🚗 :red_car: 🚗 :taxi: 🚕 :oncoming_taxi: 🚖 :articulated_lorry: 🚛 :bus: 🚌 :oncoming_bus: 🚍 :rotating_light: 🚨 :police_car: 🚓 :oncoming_police_car: 🚔 :fire_engine: 🚒 :ambulance: 🚑 :minibus: 🚐 :truck: 🚚 :train: 🚋 :station: 🚉 :train2: 🚆 :bullettrain_front: 🚅 :bullettrain_side: 🚄 :light_rail: 🚈 :monorail: 🚝 :railway_car: 🚃 :trolleybus: 🚎 :ticket: 🎫 :fuelpump: ⛽ :vertical_traffic_light: 🚦 :traffic_light: 🚥 :warning: ⚠ :construction: 🚧 :beginner: 🔰 :atm: 🏧 :slot_machine: 🎰 :busstop: 🚏 :barber: 💈 :hotsprings: ♨ :checkered_flag: 🏁 :crossed_flags: 🎌 :izakaya_lantern: 🏮 :moyai: 🗿 :circus_tent: 🎪 :performing_arts: 🎭 :round_pushpin: 📍 :triangular_flag_on_post: 🚩 :jp: 🇯🇵 :kr: 🇰🇷 :cn: 🇨🇳 :us: 🇺🇸 :fr: 🇫🇷 :es: 🇪🇸 :it: 🇮🇹 :ru: 🇷🇺 :gb: 🇬🇧 :uk: 🇬🇧 :de: 🇩🇪 符号 syntax preview syntax preview syntax preview :one: 1⃣ :two: 2⃣ :three: 3⃣ :four: 4⃣ :five: 5⃣ :six: 6⃣ :seven: 7⃣ :eight: 8⃣ :nine: 9⃣ :keycap_ten: 🔟 :1234: 🔢 :zero: 0⃣ :hash: #⃣ :symbols: 🔣 :arrow_backward: ◀ :arrow_down: ⬇ :arrow_forward: ▶ :arrow_left: ⬅ :capital_abcd: 🔠 :abcd: 🔡 :abc: 🔤 :arrow_lower_left: ↙ :arrow_lower_right: ↘ :arrow_right: ➡ :arrow_up: ⬆ :arrow_upper_left: ↖ :arrow_upper_right: ↗ :arrow_double_down: ⏬ :arrow_double_up: ⏫ :arrow_down_small: 🔽 :arrow_heading_down: ⤵ :arrow_heading_up: ⤴ :leftwards_arrow_with_hook: ↩ :arrow_right_hook: ↪ :left_right_arrow: ↔ :arrow_up_down: ↕ :arrow_up_small: 🔼 :arrows_clockwise: 🔃 :arrows_counterclockwise: 🔄 :rewind: ⏪ :fast_forward: ⏩ :information_source: ℹ :ok: 🆗 :twisted_rightwards_arrows: 🔀 :repeat: 🔁 :repeat_one: 🔂 :new: 🆕 :top: 🔝 :up: 🆙 :cool: 🆒 :free: 🆓 :ng: 🆖 :cinema: 🎦 :koko: 🈁 :signal_strength: 📶 :u5272: 🈹 :u5408: 🈴 :u55b6: 🈺 :u6307: 🈯 :u6708: 🈷 :u6709: 🈶 :u6e80: 🈵 :u7121: 🈚 :u7533: 🈸 :u7a7a: 🈳 :u7981: 🈲 :sa: 🈂 :restroom: 🚻 :mens: 🚹 :womens: 🚺 :baby_symbol: 🚼 :no_smoking: 🚭 :parking: 🅿 :wheelchair: ♿ :metro: 🚇 :baggage_claim: 🛄 :accept: 🉑 :wc: 🚾 :potable_water: 🚰 :put_litter_in_its_place: 🚮 :secret: ㊙ :congratulations: ㊗ :m: Ⓜ :passport_control: 🛂 :left_luggage: 🛅 :customs: 🛃 :ideograph_advantage: 🉐 :cl: 🆑 :sos: 🆘 :id: 🆔 :no_entry_sign: 🚫 :underage: 🔞 :no_mobile_phones: 📵 :do_not_litter: 🚯 :non-potable_water: :non-potable_water: :no_bicycles: 🚳 :no_pedestrians: 🚷 :children_crossing: 🚸 :no_entry: ⛔ :eight_spoked_asterisk: ✳ :eight_pointed_black_star: ✴ :heart_decoration: 💟 :vs: 🆚 :vibration_mode: 📳 :mobile_phone_off: 📴 :chart: 💹 :currency_exchange: 💱 :aries: ♈ :taurus: ♉ :gemini: ♊ :cancer: ♋ :leo: ♌ :virgo: ♍ :libra: ♎ :scorpius: ♏ :sagittarius: ♐ :capricorn: ♑ :aquarius: ♒ :pisces: ♓ :ophiuchus: ⛎ :six_pointed_star: 🔯 :negative_squared_cross_mark: ❎ :a: 🅰 :b: 🅱 :ab: 🆎 :o2: 🅾 :diamond_shape_with_a_dot_inside: 💠 :recycle: ♻ :end: 🔚 :on: 🔛 :soon: 🔜 :clock1: 🕐 :clock130: 🕜 :clock10: 🕙 :clock1030: 🕥 :clock11: 🕚 :clock1130: 🕦 :clock12: 🕛 :clock1230: 🕧 :clock2: 🕑 :clock230: 🕝 :clock3: 🕒 :clock330: 🕞 :clock4: 🕓 :clock430: 🕟 :clock5: 🕔 :clock530: 🕠 :clock6: 🕕 :clock630: 🕡 :clock7: 🕖 :clock730: 🕢 :clock8: 🕗 :clock830: 🕣 :clock9: 🕘 :clock930: 🕤 :heavy_dollar_sign: 💲 :copyright: © :registered: ® :tm: ™ :x: ❌ :heavy_exclamation_mark: ❗ :bangbang: ‼ :interrobang: ⁉ :o: ⭕ :heavy_multiplication_x: ✖ :heavy_plus_sign: ➕ :heavy_minus_sign: ➖ :heavy_division_sign: ➗ :white_flower: 💮 :100: 💯 :heavy_check_mark: ✔ :ballot_box_with_check: ☑ :radio_button: 🔘 :link: 🔗 :curly_loop: ➰ :wavy_dash: 〰 :part_alternation_mark: 〽 :trident: 🔱 :black_large_square: ⬛ :white_large_square: ⬜ :white_check_mark: ✅ :white_square_button: 🔳 :black_square_button: 🔲 :black_circle: ⚫ :white_circle: ⚪ :red_circle: 🔴 :large_blue_circle: 🔵 :large_blue_diamond: 🔷 :large_orange_diamond: 🔶 :small_blue_diamond: 🔹 :small_orange_diamond: 🔸 :small_red_triangle: 🔺 :small_red_triangle_down: 🔻 :shipit:","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/categories/MarkDown/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/tags/MarkDown/"}]},{"title":"Kotlin知识点汇总","slug":"docs/Kotlin/Kotlin知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/kotlin/kotlin-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/kotlin/kotlin-zhi-shi-dian-hui-zong/","excerpt":"","text":"对象 类 继承 变量 常量 静态常量 定义方法 重载方法 基本数据类型 比较类型 转换符 字符串比较 数组 循环 角标循环 高级循环 判断器 构造函数 类创建 私有化 set 方法 私有化 get 方法 枚举 接口 匿名内部类 内部类 内部类访问外部类同名变量 抽象类 静态变量和方法 可变参数 泛型 构造代码块 静态代码块 方法代码块 可见修饰符 无需 findViewById Lambda 函数变量 空安全 方法支持添加默认参数 类方法扩展 运算符重载 扩展函数 let 函数 with 函数 run 函数 apply 函数 also 函数 总结 协程 对象 Java 的写法 MainActivity.this Kotlin 的写法 this@MainActivity 类 Java 的写法 MainActivity.class Kotlin 的写法 MainActivity::class.java 继承 Java 的写法 public class MainActivity extends AppCompatActivity { } Kotlin 的写法（在 Kotlin 中被继承类必须被 open 关键字修饰） class MainActivity : AppCompatActivity() { } 变量 Java 的写法 Intent intent = new Intent(); Kotlin 的写法 var intent = Intent() 常量 Java 的写法 final String text = \"\"; Kotlin 的写法 val text = \"\" 静态常量 Java 的写法 public class MainActivity extends AppCompatActivity { static final String text = \"\"; } Kotlin 的写法（需要注意的是要把静态变量定义在类上方） const val text = \"\" class MainActivity : AppCompatActivity() { } 定义方法 Java 的写法 public void test(String message) { } Kotlin 的写法（Unit 跟 void 一样效果） fun test(message : String) : Unit { } // 在 Kotlin 可以省略 Unit 这种返回值 fun test(message : String) { } 重载方法 Java 的写法 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); } } Kotlin 的写法 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) } } 基本数据类型 Java 的写法 int i = 1; long l = 2; boolean b = true; float f = 0; double d = 0; char c = 'A'; String s = \"text\"; Kotlin 的写法 var i : Int = 1 var l : Long = 2 var b : Boolean = true var f : Float = 0F var d : Double = 0.0 var c : Char = 'A' var s : String = \"text\" // 更简洁点可以这样，自动推倒类型 var i = 1 var l = 2 var b = true var f = 0F var d = 0.0 var c = 'A' var s = \"text\" 比较类型 Java 的写法 if (\"\" instanceof String) { } Kotlin 的写法 if (\"\" is String) { } 转换符 Java 的写法 int number = 100; System.out.println(String.format(\"商品数量有%d\", number)); Kotlin 的写法 var number = 100 println(\"商品数量有${number}\") // 换种简洁的写法 var number = 100 println(\"商品数量有$number\") // 如果不想字符串被转义可以使用\\$ var number = 100 println(\"商品数量有\\$number\") 字符串比较 Java 的写法 String s1 = \"text\"; String s2 = \"text\"; if (s1.equals(s2)) { } Kotlin 的写法（Kotlin 对字符串比较的写法进行优化了，其他类型对象对比还是要用 equals 方法） var s1 = \"text\" var s2 = \"text\" if (s1 == s2) { } 数组 Java 的写法 int[] array1 = {1, 2, 3}; float[] array2 = {1f, 2f, 3f}; String[] array3 = {\"1\", \"2\", \"3\"}; Kotlin 的写法 val array1 = intArrayOf(1, 2, 3) val array2 = floatArrayOf(1f, 2f, 3f) val array3 = arrayListOf(\"1\", \"2\", \"3\") 循环 Java 的写法 String[] array = {\"1\", \"2\", \"3\"}; for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } Kotlin 的写法 val array = arrayListOf(\"1\", \"2\", \"3\") for (i in array.indices) { println(array[i]) } 角标循环 Java 的写法 String[] array = {\"1\", \"2\", \"3\"}; for (int i = 1; i &lt; array.length; i++) { System.out.println(array[i]); } Kotlin 的写法（这种写法在 Kotlin 中称之为区间） val array = arrayListOf(\"1\", \"2\", \"3\") for (i in IntRange(1, array.size - 1)) { println(array[i]) } // 换种更简洁的写法 val array = arrayListOf(\"1\", \"2\", \"3\") for (i in 1..array.size - 1) { println(array[i]) } // 编译器提示要我们换种写法 val array = arrayListOf(\"1\", \"2\", \"3\") for (i in 1 until array.size) { println(array[i]) } 高级循环 Java 的写法 String[] array = {\"1\", \"2\", \"3\"}; for (String text : array) { System.out.println(text); } Kotlin 的写法 val array = arrayListOf(\"1\", \"2\", \"3\") for (text in array) { println(text) } 判断器 Java 的写法 int count = 1; switch (count) { case 0: System.out.println(count); break; case 1: case 2: System.out.println(count); break; default: System.out.println(count); break; } Kotlin 的写法 var count = 1 when (count) { 0 -&gt; { println(count) } in 1..2 -&gt; { println(count) } else -&gt; { println(count) } } var count = 1 // 换种更简洁的写法 when (count) { 0 -&gt; println(count) in 1..2 -&gt; println(count) else -&gt; println(count) } 构造函数 Java 的写法 public class MyView extends View { public MyView(Context context) { this(context, null); } public MyView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } } Kotlin 的写法 class MyView : View { constructor(context : Context) : this(context, null) { } constructor(context : Context, attrs : AttributeSet?) : this(context, attrs, 0) { } constructor(context : Context, attrs : AttributeSet?, defStyleAttr : Int) : super(context, attrs, defStyleAttr) { } } // 换种更简洁的写法 class MyView : View { constructor(context : Context) : this(context, null) constructor(context : Context, attrs : AttributeSet?) : this(context, attrs, 0) constructor(context : Context, attrs : AttributeSet?, defStyleAttr : Int) : super(context, attrs, defStyleAttr) } // 只有一种构造函数的还可以这样写 class MyView(context: Context?) : View(context) { } 类创建 Java 的写法 public class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Person person = new Person(\"CurvedBowZhang\", 100); person.setName(\"ZJX\"); person.setAge(50); System.out.println(\"name: \" + person.getName() + \", age: \" + person.getAge()); Kotlin 的写法（如果不想暴露成员变量的set方法，可以将 var 改成 val ) class Person { var name : String? = null get() = field set(value) {field = value} var age : Int = 0 get() = field set(value) {field = value} } // 换种更简洁的写法 class Person(var name : String, var age : Int) var person = Person(\"CurvedBowZhang\", 100) person.name = \"ZJX\" person.age = 50 println(\"name: {$person.name}, age: {$person.age}\") 私有化 set 方法 Java 的写法 public class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } private void setName(String name) { this.name = name; } public int getAge() { return age; } private void setAge(int age) { this.age = age; } } Kotlin 的写法 class Person { var name : String? = null private set var age : Int = 0 private set } 私有化 get 方法 Java 的写法 public class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } private String getName() { return name; } private void setName(String name) { this.name = name; } private int getAge() { return age; } private void setAge(int age) { this.age = age; } } Kotlin 的写法 class Person { private var name : String? = null private var age : Int = 0 } 枚举 Java 的写法 enum Sex { MAN(true), WOMAN(false); Sex(boolean isMan) {} } Kotlin 的写法 enum class Sex (var isMan: Boolean) { MAN(true), WOMAN(false) } 接口 Java 的写法 public interface Callback { void onSuccess(); void onFail(); } Kotlin 的写法（Kotlin接口方法里面是可以自己实现，这里就不再演示了） interface Callback { fun onSuccess() fun onFail() } 匿名内部类 Java 的写法 new Callback() { @Override public void onSuccess() { } @Override public void onFail() { } }; Kotlin 的写法 object:Callback { override fun onSuccess() { } override fun onFail() { } } 内部类 Java 的写法 public class MainActivity extends AppCompatActivity { public class MyTask { } } Kotlin 的写法 class MainActivity : AppCompatActivity() { inner class MyTask { } } 内部类访问外部类同名变量 Java 的写法 String name = \"CurvedBowZhang\"; public class MyTask { String name = \"ZJX\"; public void show() { System.out.println(name + \"---\" + MainActivity.this.name); } } Kotlin 的写法 var name = \"CurvedBowZhang\" inner class MyTask { var name = \"ZJX\" fun show() { println(name + \"---\" + this@MainActivity.name) } } 抽象类 Java 的写法 public abstract class BaseActivity extends AppCompatActivity implements Runnable { abstract void init(); } Kotlin 的写法 abstract class BaseActivity : AppCompatActivity(), Runnable { abstract fun init() } 静态变量和方法 Java 的写法 public class ToastUtils { public static Toast sToast; public static void show() { sToast.show(); } } Kotlin 的写法（在 Kotlin 将这种方式称之为伴生对象） companion object ToastUtils { var sToast : Toast? = null fun show() { sToast!!.show() } } 可变参数 Java 的写法 public int add(int... array) { int count = 0; for (int i : array) { count += i; } return count; } Kotlin 的写法 fun add(vararg array: Int) : Int { var count = 0 //for (i in array) { // count += i //} array.forEach { count += it } return count } 泛型 Java 的写法 public class Bean&lt;T extends String&gt; { T data; public Bean(T t) { this.data = t; } } Bean&lt;String&gt; bean = new Bean&lt;&gt;(\"666666\"); Kotlin 的写法 class Bean&lt;T : Comparable&lt;String&gt;&gt;(t: T) { var data = t } var bean = Bean&lt;String&gt;(\"666666\") // 换种更简洁的写法 var bean = Bean(\"666666\") 构造代码块 Java 的写法 public class MainActivity extends AppCompatActivity { int number; { number = 1; } } Kotlin 的写法 class MainActivity : AppCompatActivity() { var number = 0 init { number = 1 } } 静态代码块 Java 的写法 public class MainActivity extends AppCompatActivity { static int number; static { number = 1; } } Kotlin 的写法 class MainActivity : AppCompatActivity() { companion object { var number = 0 init { number = 1 } } } 方法代码块 Java 的写法 void test(){ { int a = 1; } } Kotlin 的写法 fun test() { run { var a =1 } } 可见修饰符 Java 的写法（默认为 default） 修饰符 作用 public 所有类可见 protected 子类可见 default 同一包下的类可见 private 仅对自己类可见 Kotlin 的写法（默认为 public） 修饰符 作用 public 所有类可见 internal 同 Module 下的类可见 protected 子类可见 private 仅对自己类可见 无需 findViewById 在布局中定义 &lt;TextView android:id=\"@+id/tv_content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; 直接设置 TextView 的文本 tv_content.text = \"改变文本\" Lambda Lambda 表达式虽然在 Java JDK 已经加上了，但是没有普及开来，现在搭配 Kotlin 是一个不错的选择 tv_content.setOnClickListener(View.OnClickListener( fun(v : View) { v.visibility = View.GONE } )) 现在可以用 Lambda 表达式进行简化 tv_content.setOnClickListener { v -&gt; v.visibility = View.GONE } 函数变量 在 Kotlin 语法中函数是可以作为变量进行传递的 var result = fun(number1 : Int, number2 : Int) : Int { return number1 + number2 } 使用这个函数变量 println(result(1, 2)) 空安全 在 Java 不用强制我们处理空对象，所以常常会导致 NullPointerException 空指针出现，现在 Kotlin 对空对象进行了限定，必须在编译时处理对象是否为空的情况，不然会编译不通过 在对象不可空的情况下，可以直接使用这个对象 fun getText() : String { return \"text\" } val text = getText() print(text.length) 在对象可空的情况下，必须要判断对象是否为空 fun getText() : String? { return null } val text = getText() if (text != null) { print(text.length) } // 如果不想判断是否为空，可以直接这样，如果 text 对象为空，则会报空指针异常，一般情况下不推荐这样使用 val text = getText() print(text!!.length) // 还有一种更好的处理方式，如果 text 对象为空则不会报错，但是 text.length 的结果会等于 null val text = getText() print(text?.length) 方法支持添加默认参数 在 Java 上，我们可能会为了扩展某个方法而进行多次重载 public void toast(String text) { toast(this, text, Toast.LENGTH_SHORT); } public void toast(Context context, String text) { toast(context, text, Toast.LENGTH_SHORT); } public void toast(Context context, String text, int time) { Toast.makeText(context, text, time).show(); } toast(\"弹个吐司\"); toast(this, \"弹个吐司\"); toast(this, \"弹个吐司\", Toast.LENGTH_LONG); 但是在 Kotlin 上面，我们无需进行重载，可以直接在方法上面直接定义参数的默认值 fun toast(context : Context = this, text : String, time : Int = Toast.LENGTH_SHORT) { Toast.makeText(context, text, time).show() } toast(text = \"弹个吐司\") toast(this, \"弹个吐司\") toast(this, \"弹个吐司\", Toast.LENGTH_LONG) 类方法扩展 可以在不用继承的情况下对扩展原有类的方法，例如对 String 类进行扩展方法 fun String.handle() : String { return this + \"CurvedBowZhang\" } // 需要注意，handle 方法在哪个类中被定义，这种扩展只能在那个类里面才能使用 print(\"ZJX = \".handle()) ZJX = CurvedBowZhang 运算符重载 在 Kotlin 中使用运算符最终也会调用对象对应的方法，我们可以通过重写这些方法使得这个对象支持运算符，这里不再演示代码 运算符 调用方法 +a a.unaryPlus() -a a.unaryMinus() !a a.not() 运算符 调用方法 a++ a.inc() a– a.dec() 运算符 调用方法 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b), a.mod(b) (deprecated) a..b a.rangeTo(b) 运算符 调用方法 a in b b.contains(a) a !in b !b.contains(a) 运算符 调用方法 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 运算符 调用方法 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, …, i_n) a.invoke(i_1, …, i_n) 运算符 调用方法 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b), a.modAssign(b) (deprecated) 运算符 调用方法 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) 运算符 调用方法 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 扩展函数 扩展函数是 Kotlin 用于简化一些代码的书写产生的，其中有 let、with、run、apply、also 五个函数 let 函数 在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式 一般写法 fun main() { val text = \"CurvedBowZhang\" println(text.length) val result = 1000 println(result) } let 写法 fun main() { val result = \"CurvedBowZhang\".let { println(it.length) 1000 } println(result) } 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理 mVideoPlayer?.setVideoView(activity.course_video_view) mVideoPlayer?.setControllerView(activity.course_video_controller_view) mVideoPlayer?.setCurtainView(activity.course_video_curtain_view) mVideoPlayer?.let { it.setVideoView(activity.course_video_view) it.setControllerView(activity.course_video_controller_view) it.setCurtainView(activity.course_video_curtain_view) } 又或者是需要去明确一个变量所处特定的作用域范围内可以使用 with 函数 前面的几个函数使用方式略有不同，因为它不是以扩展的形式存在的。它是将某对象作为函数的参数，在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式 定义 Person 类 class Person(var name : String, var age : Int) 一般写法 fun main() { var person = Person(\"CurvedBowZhang\", 100) println(person.name + person.age) var result = 1000 println(result) } with 写法 fun main() { var result = with(Person(\"CurvedBowZhang\", 100)) { println(name + age) 1000 } println(result) } 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上 override fun onBindViewHolder(holder: ViewHolder, position: Int){ val item = getItem(position)?: return holder.nameView.text = \"姓名：${item.name}\" holder.ageView.text = \"年龄：${item.age}\" } override fun onBindViewHolder(holder: ViewHolder, position: Int){ val item = getItem(position)?: return with(item){ holder.nameView.text = \"姓名：$name\" holder.ageView.text = \"年龄：$age\" } } run 函数 实际上可以说是let和with两个函数的结合体，run函数只接收一个lambda函数为参数，以闭包形式返回，返回值为最后一行的值或者指定的return的表达式 一般写法 var person = Person(\"CurvedBowZhang\", 100) println(person.name + \"+\" + person.age) var result = 1000 println(result) run 写法 var person = Person(\"CurvedBowZhang\", 100) var result = person.run { println(\"$name + $age\") 1000 } println(result) 适用于let,with函数任何场景。因为run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理，这里还是借助 onBindViewHolder 案例进行简化 override fun onBindViewHolder(holder: ViewHolder, position: Int){ val item = getItem(position)?: return holder.nameView.text = \"姓名：${item.name}\" holder.ageView.text = \"年龄：${item.age}\" } override fun onBindViewHolder(holder: ViewHolder, position: Int){ val item = getItem(position)?: return item?.run { holder.nameView.text = \"姓名：$name\" holder.ageView.text = \"年龄：$age\" } } apply 函数 从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身 一般写法 val person = Person(\"CurvedBowZhang\", 100) person.name = \"ZJX\" person.age = 50 apply 写法 val person = Person(\"CurvedBowZhang\", 100).apply { name = \"ZJX\" age = 50 } 整体作用功能和run函数很像，唯一不同点就是它返回的值是对象本身，而run函数是一个闭包形式返回，返回的是最后一行的值。正是基于这一点差异它的适用场景稍微与run函数有点不一样。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到 mRootView = View.inflate(activity, R.layout.example_view, null) mRootView.tv_cancel.paint.isFakeBoldText = true mRootView.tv_confirm.paint.isFakeBoldText = true mRootView.seek_bar.max = 10 mRootView.seek_bar.progress = 0 使用 apply 函数后的代码是这样的 mRootView = View.inflate(activity, R.layout.example_view, null).apply { tv_cancel.paint.isFakeBoldText = true tv_confirm.paint.isFakeBoldText = true seek_bar.max = 10 seek_bar.progress = 0 } 多层级判空问题 if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) { return; } if (mSectionMetaData.questionnaire.userProject != null) { renderAnalysis(); return; } if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) { fetchQuestionData(); return; } kotlin的apply函数优化 mSectionMetaData?.apply { //mSectionMetaData不为空的时候操作mSectionMetaData }?.questionnaire?.apply { //questionnaire不为空的时候操作questionnaire }?.section?.apply { //section不为空的时候操作section }?.sectionArticle?.apply { //sectionArticle不为空的时候操作sectionArticle } also 函数 also函数的结构实际上和let很像唯一的区别就是返回值的不一样，let是以闭包的形式返回，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值。而also函数返回的则是传入对象的本身 fun main() { val result = \"CurvedBowZhang\".let { println(it.length) 1000 } println(result) // 打印：1000 } fun main() { val result = \"CurvedBowZhang\".also { println(it.length) } println(result) // 打印：CurvedBowZhang } 适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是let函数最后的返回值是最后一行的返回值而also函数的返回值是返回当前的这个对象。一般可用于多个扩展函数链式调用 总结 通过以上几种函数的介绍，可以很方便优化kotlin中代码编写，整体看起来几个函数的作用很相似，但是各自又存在着不同。使用的场景有相同的地方比如run函数就是let和with的结合体 协程 子任务协作运行，优雅的处理异步问题解决方案 协程实际上就是极大程度的复用线程，通过让线程满载运行，达到最大程度的利用CPU，进而提升应用性能 在当前 app module 中配置环境和依赖（因为现在协程在 Kotlin 中是实验性的） kotlin { experimental { coroutines 'enable' } } dependencies { implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.20' implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:0.20' } 协程的三种启动方式 runBlocking:T launch:Job async/await:Deferred runBlocking runBlocking 的中文翻译：运行阻塞。说太多没用，直接用代码测试一下 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") runBlocking { println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) // 因为 Activity 最长响应时间为 15 秒 println(\"测试延迟结束\") } println(\"测试结束\") 17:02:08.686 System.out: 测试是否为主线程 true 17:02:08.686 System.out: 测试开始 17:02:08.688 System.out: 测试是否为主线程 true 17:02:08.688 System.out: 测试延迟开始 17:02:28.692 System.out: 测试延迟结束 17:02:28.693 System.out: 测试结束 runBlocking 运行在主线程，过程中 App 出现过无响应提示，由此可见 runBlocking 和它的名称一样，真的会阻塞当前的线程，只有等 runBlocking 里面的代码执行完了才会执行 runBlocking 外面的代码 launch launch 的中文翻译：启动。甭管这是啥，直接用代码测试 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") launch { println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) println(\"测试延迟结束\") } println(\"测试结束\") 17:19:17.190 System.out: 测试是否为主线程 true 17:19:17.190 System.out: 测试开始 17:19:17.202 System.out: 测试结束 17:19:17.203 System.out: 测试是否为主线程 false 17:19:17.203 System.out: 测试延迟开始 17:19:37.223 System.out: 测试延迟结束 async async 的中文翻译：异步。还是老套路，直接上代码 测试的时候是主线程，但是到了 launch 中就会变成子线程，这种效果类似 new Thread()，有木有？和 runBlocking 最不同的是 launch 没有执行顺序这个概念 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") async { println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) println(\"测试延迟结束\") } println(\"测试结束\") 17:29:00.694 System.out: 测试是否为主线程 true 17:29:00.694 System.out: 测试开始 17:29:00.697 System.out: 测试结束 17:29:00.697 System.out: 测试是否为主线程 false 17:29:00.697 System.out: 测试延迟开始 17:29:20.707 System.out: 测试延迟结束 这结果不是跟 launch 一样么？那么这两个到底有什么区别呢？，让我们先看一段测试代码 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") val async = async { println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) println(\"测试延迟结束\") return@async \"666666\" } println(\"测试结束\") runBlocking { println(\"测试返回值：\" + async.await()) } 17:50:57.117 System.out: 测试是否为主线程 true 17:50:57.117 System.out: 测试开始 17:50:57.120 System.out: 测试结束 17:50:57.120 System.out: 测试是否为主线程 false 17:50:57.120 System.out: 测试延迟开始 17:51:17.131 System.out: 测试延迟结束 17:51:17.133 System.out: 测试返回值：666666 看到这里你是否懂了，async 和 launch 还是有区别的，async 可以有返回值，通过它的 await 方法进行获取，需要注意的是这个方法只能在协程的操作符中才能调用 线程调度 啥？协程有类似 RxJava 线程调度？先用 launch 试验一下 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") launch(CommonPool) { // 同学们，敲重点 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) println(\"测试延迟结束\") } println(\"测试结束\") 18:00:23.243 System.out: 测试是否为主线程 true 18:00:23.244 System.out: 测试开始 18:00:23.246 System.out: 测试结束 18:00:23.246 System.out: 测试是否为主线程 false 18:00:23.247 System.out: 测试延迟开始 18:00:43.256 System.out: 测试延迟结束 Q：这个跟刚刚的代码有什么不一样吗？ A：当然不一样，假如一个网络请求框架维护了一个线程池，一个图片加载框架也维护了一个线程池…….，你会发现其实这样不好的地方在于，这些线程池里面的线程没有被重复利用，于是乎协程主动维护了一个公共的线程池 CommonPool，很好的解决了这个问题 Q：还有刚刚不是说能线程调度吗？为什么还是在子线程运行？ A：因为我刚刚只用了 CommonPool 这个关键字，我再介绍另一个关键字 UI，光听名字就知道是啥了 println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试开始\") launch(UI) { println(\"测试是否为主线程\" + (Thread.currentThread() == Looper.getMainLooper().thread)) println(\"测试延迟开始\") delay(20000) println(\"测试延迟结束\") } println(\"测试结束\") 18:07:20.181 System.out: 测试是否为主线程 true 18:07:20.181 System.out: 测试开始 18:07:20.186 System.out: 测试结束 18:07:20.192 System.out: 测试是否为主线程 true 18:07:20.192 System.out: 测试延迟开始 18:07:40.214 System.out: 测试延迟结束","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/tags/Kotlin/"}]},{"title":"Java知识点汇总","slug":"docs/Java/Java知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/java/java-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/java/java-zhi-shi-dian-hui-zong/","excerpt":"","text":"JVM JVM 工作流程 运行时数据区（Runtime Data Area） 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 方法指令 类加载器 垃圾回收 gc 对象存活判断 垃圾收集算法 垃圾收集器 内存模型与回收策略 Object equals 方法 hashCode 方法 static final String、StringBuffer、StringBuilder 异常处理 内部类 匿名内部类 多态 抽象和接口 集合框架 HashMap 结构图 HashMap 的工作原理 HashMap 与 HashTable 对比 ConcurrentHashMap Base 1.7 Base 1.8 ArrayList LinkedList CopyOnWriteArrayList 反射 单例 饿汉式 双重检查模式 静态内部类模式 线程 属性 状态 状态控制 volatile synchronized 根据获取的锁分类 原理 Lock 锁的分类 悲观锁、乐观锁 自旋锁、适应性自旋锁 死锁 引用类型 动态代理 元注解 JVM JVM 工作流程 运行时数据区（Runtime Data Area） 程序计数器 程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。 因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。 如果线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java 虚拟机栈 Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等消息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。 其中 64 位长度的 long 和 double 类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在 Java 虚拟机规范中，对这个区域规定了两种异常状态： 如果线程请求的栈深度大于虚拟机所允许的的深度，将抛出 StackOverflowError 异常。 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。 本地方法栈 本地方法栈（Native Method Stack） 与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（例如：Sun HotSpot虚拟机）直接就把虚拟机栈和本地方法栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java 堆 对于大多数应用来说，Java 堆（Java Heap） 是 Java 虚拟机所管理的的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器基本采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。 从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 方法区 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池（Runtime Constant Pool） 是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时就会抛出 OutOfMemoryError 异常。 方法指令 指令 说明 invokeinterface 用以调用接口方法 invokevirtual 指令用于调用对象的实例方法 invokestatic 用以调用类/静态方法 invokespecial 用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法 类加载器 类加载器 说明 BootstrapClassLoader Bootstrap 类加载器负责加载 rt.jar 中的 JDK 类文件，它是所有类加载器的父加载器。Bootstrap 类加载器没有任何父类加载器，如果你调用 String.class.getClassLoader()，会返回 null，任何基于此的代码会抛出 NUllPointerException 异常。Bootstrap 加载器被称为初始类加载器 ExtClassLoader 而 Extension 将加载类的请求先委托给它的父加载器，也就是Bootstrap，如果没有成功加载的话，再从 jre/lib/ext 目录下或者 java.ext.dirs 系统属性定义的目录下加载类。Extension 加载器由 sun.misc.Launcher$ExtClassLoader 实现 AppClassLoader 第三种默认的加载器就是 System 类加载器（又叫作 Application 类加载器）了。它负责从 classpath 环境变量中加载某些应用相关的类，classpath 环境变量通常由 -classpath 或 -cp 命令行选项来定义，或者是 JAR 中的 Manifest 的 classpath 属性。Application 类加载器是 Extension 类加载器的子加载器 工作原理 说明 委托机制 加载任务委托交给父类加载器，如果不行就向下传递委托任务，由其子类加载器加载，保证 java 核心库的安全性 可见性机制 子类加载器可以看到父类加载器加载的类，而反之则不行 单一性机制 父加载器加载过的类不能被子加载器加载第二次 垃圾回收 gc 对象存活判断 引用计数 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析 从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。 在Java语言中，GC Roots包括： 虚拟机栈中引用的对象。 方法区中类静态属性实体引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI 引用的对象。 垃圾收集算法 标记 -清除算法 “标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 “复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。 标记-整理算法 复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法 GC 分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 垃圾收集器 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） G1收集器 与CMS收集器相比G1收集器有以下特点： 1、空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 2、可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。 使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region 的集合。 G1的新生代收集跟 ParNew 类似，当新生代占用达到一定比例的时候，开始出发收集。和 CMS 类似，G1 收集器收集老年代对象会有短暂停顿。 内存模型与回收策略 Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。 Eden 区 大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。 Survivor 区 Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。 Old 区 老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记——整理算法。 Object equals 方法 对两个对象的地址值进行的比较（即比较引用是否相同） public boolean equals(Object obj) { return (this == obj); } hashCode 方法 hashCode() 方法给对象返回一个 hash code 值。这个方法被用于 hash tables，例如 HashMap。 它的性质是： 在一个Java应用的执行期间，如果一个对象提供给 equals 做比较的信息没有被修改的话，该对象多次调用 hashCode() 方法，该方法必须始终如一返回同一个 integer。 如果两个对象根据 equals(Object) 方法是相等的，那么调用二者各自的 hashCode() 方法必须产生同一个 integer 结果。 并不要求根据 equals(Object) 方法不相等的两个对象，调用二者各自的 hashCode() 方法必须产生不同的 integer 结果。然而，程序员应该意识到对于不同的对象产生不同的 integer 结果，有可能会提高 hash table 的性能。 在 JDK 中，Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。在 String 类，重写了 hashCode 方法 public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } static static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。 能通过 this 访问静态成员变量吗?所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 static是不允许用来修饰局部变量 final 可以声明成员变量、方法、类以及本地变量 final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误 final 变量是只读的 final 申明的方法不可以被子类的方法重写 final 类通常功能是完整的，不能被继承 final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销 final 关键字提高了性能，JVM 和 Java 应用都会缓存 final 变量，会对方法、变量及类进行优化 方法的内部类访问方法中的局部变量，但必须用 final 修饰才能访问 String、StringBuffer、StringBuilder String 是 final 类，不能被继承。对于已经存在的 Stirng 对象，修改它的值，就是重新创建一个对象 StringBuffer 是一个类似于 String 的字符串缓冲区，使用 append() 方法修改 Stringbuffer 的值，使用 toString() 方法转换为字符串，是线程安全的 StringBuilder 用来替代于 StringBuffer，StringBuilder 是非线程安全的，速度更快 异常处理 Exception、Error 是 Throwable 类的子类 Error 类对象由 Java 虚拟机生成并抛出，不可捕捉 不管有没有异常，finally 中的代码都会执行 当 try、catch 中有 return 时，finally 中的代码依然会继续执行 常见的Error OutOfMemoryError StackOverflowError NoClassDeffoundError 常见的Exception 常见的非检查性异常 ArithmeticException ArrayIndexOutOfBoundsException ClassCastException IllegalArgumentException IndexOutOfBoundsException NullPointerException NumberFormatException SecurityException UnsupportedOperationException 常见的检查性异常 IOException CloneNotSupportedException IllegalAccessException NoSuchFieldException NoSuchMethodException FileNotFoundException 内部类 非静态内部类没法在外部类的静态方法中实例化。 非静态内部类的方法可以直接访问外部类的所有数据，包括私有的数据。 在静态内部类中调用外部类成员，成员也要求用 static 修饰。 创建静态内部类的对象可以直接通过外部类调用静态内部类的构造器；创建非静态的内部类的对象必须先创建外部类的对象，通过外部类的对象调用内部类的构造器。 匿名内部类 匿名内部类不能定义任何静态成员、方法 匿名内部类中的方法不能是抽象的 匿名内部类必须实现接口或抽象父类的所有抽象方法 匿名内部类不能定义构造器 匿名内部类访问的外部类成员变量或成员方法必须用 final 修饰 多态 父类的引用可以指向子类的对象 创建子类对象时，调用的方法为子类重写的方法或者继承的方法 如果我们在子类中编写一个独有的方法，此时就不能通过父类的引用创建的子类对象来调用该方法 抽象和接口 抽象类不能有对象（不能用 new 关键字来创建抽象类的对象） 抽象类中的抽象方法必须在子类中被重写 接口中的所有属性默认为：public static final ****； 接口中的所有方法默认为：public abstract ****； 集合框架 List接口存储一组不唯一，有序（插入顺序）的对象, Set接口存储一组唯一，无序的对象。 HashMap 结构图 JDK 1.7 HashMap 结构图 JDK 1.8 HashMap 结构图 HashMap 的工作原理 HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存 Entry 对象。当两个对象的 hashcode 相同时，它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用链表存储对象，这个 Entry 会存储在链表中，当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。 如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为 0.75，也就是说，当一个 map 填满了 75% 的 bucket 时候，和其它集合类(如 ArrayList 等)一样，将会创建原来 HashMap 大小的两倍的 bucket 数组，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。这个过程叫作 rehashing，因为它调用 hash 方法找到新的 bucket 位置。 为什么 String, Interger 这样的 wrapper 类适合作为键?因为 String 是不可变的，也是 final 的，而且已经重写了 equals() 和 hashCode() 方法了。其他的 wrapper 类也有这个特点。不可变性是必要的，因为为了要计算 hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个 field 声明成 final 就能保证 hashCode 是不变的，那么请这么做吧。因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会小些，这样就能提高 HashMap 的性能。 HashMap 与 HashTable 对比 HashMap 是非 synchronized 的，性能更好，HashMap 可以接受为 null 的 key-value，而 Hashtable 是线程安全的，比 HashMap 要慢，不接受 null 的 key-value。 HashMap.java public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { ··· public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } ··· public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } ··· } HashTable.java public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { ··· public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } ··· addEntry(hash, key, value, index); return null; } ··· public synchronized V get(Object key) { HashtableEntry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (HashtableEntry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return (V)e.value; } } return null; } ··· } ConcurrentHashMap Base 1.7 ConcurrentHashMap 最外层不是一个大的数组，而是一个 Segment 的数组。每个 Segment 包含一个与 HashMap 数据结构差不多的链表数组。 在读写某个 Key 时，先取该 Key 的哈希值。并将哈希值的高 N 位对 Segment 个数取模从而得到该 Key 应该属于哪个Segment，接着如同操作 HashMap 一样操作这个 Segment。 Segment 继承自 ReentrantLock，可以很方便的对每一个 Segmen 上锁。 对于读操作，获取 Key 所在的 Segment 时，需要保证可见性。具体实现上可以使用volatile关键字，也可使用锁。但使用锁开销太大，而使用volatile时每次写操作都会让所有CPU内缓存无效，也有一定开销。ConcurrentHashMap 使用如下方法保证可见性，取得最新的Segment： Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u) 获取 Segment 中的 HashEntry 时也使用了类似方法： HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE) 对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个Map。它会先获取该 Key-Value 对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该 Segment 的安全性。同时由于其它 Segment 的锁并未被获取，因此理论上可支持 concurrencyLevel（等于Segment的个数）个线程安全的并发读写。 获取锁时，并不直接使用 lock 来获取，因为该方法获取锁失败时会挂起。事实上，它使用了自旋锁，如果 tryLock 获取锁失败，说明锁被其它线程占用，此时通过循环再次以 tryLock 的方式申请锁。如果在循环过程中该 Key 所对应的链表头被修改，则重置 retry 次数。如果 retry 次数超过一定值，则使用 lock 方法申请锁。 这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗 CPU 资源比较多，因此在自旋次数超过阈值时切换为互斥锁。 Base 1.8 1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题：查询遍历链表效率太低。因此 1.8 做了一些数据结构上的调整。 其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 ConcurrentHashMap.java final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh &gt;= 0) { binCount = 1; ··· } else if (f instanceof TreeBin) { ··· } else if (f instanceof ReservationNode) throw new IllegalStateException(\"Recursive update\"); } } ··· } addCount(1L, binCount); return null; } ArrayList ArrayList 本质上是一个动态数组，第一次添加元素时，数组大小将变化为 DEFAULT_CAPACITY 10，不断添加元素后，会进行扩容。删除元素时，会按照位置关系把数组元素整体（复制）移动一遍。 ArrayList.java public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ··· // 增加元素 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } ··· // 删除元素 public E remove(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } ··· // 查找元素 public E get(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); return (E) elementData[index]; } ··· } LinkedList LinkedList 本质上是一个双向链表的存储结构。 LinkedList.java public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable { ···· private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } ··· // 增加元素 void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } ··· // 删除元素 E unlink(Node&lt;E&gt; x) { final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } ··· // 查找元素 Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } ··· } 对于元素查询来说，ArrayList 优于 LinkedList，因为 LinkedList 要移动指针。对于新增和删除操作，LinedList 比较占优势，因为 ArrayList 要移动数据。 CopyOnWriteArrayList CopyOnWriteArrayList 是线程安全容器(相对于 ArrayList)，增加删除等写操作通过加锁的形式保证数据一致性，通过复制新集合的方式解决遍历迭代的问题。 CopyOnWriteArrayList.java public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { final transient Object lock = new Object(); ··· // 增加元素 public boolean add(E e) { synchronized (lock) { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } } ··· // 删除元素 public E remove(int index) { synchronized (lock) { Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } } ··· // 查找元素 private E get(Object[] a, int index) { return (E) a[index]; } } 反射 try { Class cls = Class.forName(\"com.jasonwu.Test\"); //获取构造方法 Constructor[] publicConstructors = cls.getConstructors(); //获取全部构造方法 Constructor[] declaredConstructors = cls.getDeclaredConstructors(); //获取公开方法 Method[] methods = cls.getMethods(); //获取全部方法 Method[] declaredMethods = cls.getDeclaredMethods(); //获取公开属性 Field[] publicFields = cls.getFields(); //获取全部属性 Field[] declaredFields = cls.getDeclaredFields(); Object clsObject = cls.newInstance(); Method method = cls.getDeclaredMethod(\"getModule1Functionality\"); Object object = method.invoke(null); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } 单例 饿汉式 public class CustomManager { private Context mContext; private static final Object mLock = new Object(); private static CustomManager mInstance; public static CustomManager getInstance(Context context) { synchronized (mLock) { if (mInstance == null) { mInstance = new CustomManager(context); } return mInstance; } } private CustomManager(Context context) { this.mContext = context.getApplicationContext(); } } 双重检查模式 public class CustomManager { private Context mContext; private volatile static CustomManager mInstance; public static CustomManager getInstance(Context context) { // 避免非必要加锁 if (mInstance == null) { synchronized (CustomManger.class) { if (mInstance == null) { mInstacne = new CustomManager(context); } } } return mInstacne; } private CustomManager(Context context) { this.mContext = context.getApplicationContext(); } } 静态内部类模式 public class CustomManager{ private CustomManager(){} private static class CustomManagerHolder { private static final CustomManager INSTANCE = new CustomManager(); } public static CustomManager getInstance() { return CustomManagerHolder.INSTANCE; } } 静态内部类的原理是： 当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance() 方法第一次被调用时，才会去初始化 INSTANCE，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。getInstance 方法并没有多次去 new 对象，取的都是同一个 INSTANCE 对象。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕 缺点在于无法传递参数，如Context等 线程 线程是进程中可独立执行的最小单位，也是 CPU 资源（时间片）分配的基本单位。同一个进程中的线程可以共享进程中的资源，如内存空间和文件句柄。 属性 属性 说明 id 线程 id 用于标识不同的线程。编号可能被后续创建的线程使用。编号是只读属性，不能修改 name 名字的默认值是 Thread-(id) daemon 分为守护线程和用户线程，我们可以通过 setDaemon(true) 把线程设置为守护线程。守护线程通常用于执行不重要的任务，比如监控其他线程的运行情况，GC 线程就是一个守护线程。setDaemon() 要在线程启动前设置，否则 JVM 会抛出非法线程状态异常，可被继承。 priority 线程调度器会根据这个值来决定优先运行哪个线程（不保证），优先级的取值范围为 1~10，默认值是 5，可被继承。Thread 中定义了下面三个优先级常量：- 最低优先级：MIN_PRIORITY = 1- 默认优先级：NORM_PRIORITY = 5- 最高优先级：MAX_PRIORITY = 10 状态 状态 说明 New 新创建了一个线程对象，但还没有调用start()方法。 Runnable Ready 状态 线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中 获取 cpu 的使用权。Running 绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。 Blocked 线程因为某种原因放弃了cpu 使用权（等待锁），暂时停止运行 Waiting 线程进入等待状态因为以下几个方法：- Object#wait()- Thread#join()- LockSupport#park() Timed Waiting 有等待时间的等待状态。 Terminated 表示该线程已经执行完毕。 状态控制 wait() / notify() / notifyAll() wait()，notify()，notifyAll() 是定义在Object类的实例方法，用于控制线程状态，三个方法都必须在synchronized 同步关键字所限定的作用域中调用，否则会报错 java.lang.IllegalMonitorStateException。 方法 说明 wait() 线程状态由 的使用权。Running 变为 Waiting, 并将当前线程放入等待队列中 notify() notify() 方法是将等待队列中一个等待线程从等待队列移动到同步队列中 notifyAll() 则是将所有等待队列中的线程移动到同步队列中 被移动的线程状态由 Running 变为 Blocked，notifyAll 方法调用后，等待线程依旧不会从 wait() 返回,需要调用 notify() 或者 notifyAll() 的线程释放掉锁后，等待线程才有机会从 wait() 返回。 join() / sleep() / yield() 在很多情况，主线程创建并启动子线程，如果子线程中需要进行大量的耗时计算，主线程往往早于子线程结束。这时，如果主线程想等待子线程执行结束之后再结束，比如子线程处理一个数据，主线程要取得这个数据，就要用 join() 方法。 sleep(long) 方法在睡眠时不释放对象锁，而 join() 方法在等待的过程中释放对象锁。 yield() 方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。执行了yield方法的线程什么时候会继续运行由线程调度器来决定。 volatile 当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步，因此在读取 volatile 类型的变量时总会返回最新写入的值。 当一个变量定义为 volatile 之后，将具备以下特性： 保证此变量对所有的线程的可见性，不能保证它具有原子性（可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的） 禁止指令重排序优化 volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行 AtomicInteger 中主要实现了整型的原子操作，防止并发情况下出现异常结果，其内部主要依靠 JDK 中的 unsafe 类操作内存中的数据来实现的。volatile 修饰符保证了 value 在内存中其他线程可以看到其值得改变。CAS（Compare and Swap）操作保证了 AtomicInteger 可以安全的修改value 的值。 synchronized 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。 Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。Monitor 是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。 根据获取的锁分类 获取对象锁 synchronized(this|object) {} 修饰非静态方法 获取类锁 synchronized(类.class) {} 修饰静态方法 原理 同步代码块： monitorenter 和 monitorexit 指令实现的 同步方法 方法修饰符上的 ACC_SYNCHRONIZED 实现 Lock public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition(); } 方法 说明 lock() 用来获取锁，如果锁被其他线程获取，处于等待状态。如果采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在 try{}catch{} 块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。 lockInterruptibly() 通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。 tryLock() tryLock 方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回 true，如果获取失败（即锁已被其他线程获取），则返回 false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 tryLock(long，TimeUnit) 与 tryLock 类似，只不过是有等待时间，在等待时间内获取到锁返回 true，超时返回 false。 锁的分类 悲观锁、乐观锁 悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，synchronized 关键字和 Lock 的实现类都是悲观锁。悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在 Java 中是通过使用无锁编程来实现，最常采用的是 CAS 算法，Java 原子类中的递增操作就通过 CAS 自旋实现。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 自旋锁、适应性自旋锁 阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次，可以使用 -XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。 自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 死锁 当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源。 引用类型 强引用 &gt; 软引用 &gt; 弱引用 引用类型 说明 StrongReferenc（强引用） 当一个对象具有强引用，那么垃圾回收器是绝对不会的回收和销毁它的，非静态内部类会在其整个生命周期中持有对它外部类的强引用 WeakReference （弱引用） 在垃圾回收器运行的时候，如果对一个对象的所有引用都是弱引用的话，该对象会被回收 SoftReference（软引用） 如果一个对象只具有软引用，若内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，才会回收这些对象的内存 PhantomReference（虚引用） 一个只被虚引用持有的对象可能会在任何时候被 GC 回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到 ReferenceQueue 来判断是否被GC，这也是唯一判断对象是否被 GC 的途径）。 动态代理 示例： // 定义相关接口 public interface BaseInterface { void doSomething(); } // 接口的相关实现类 public class BaseImpl implements BaseInterface { @Override public void doSomething() { System.out.println(\"doSomething\"); } } public static void main(String args[]) { BaseImpl base = new BaseImpl(); // Proxy 动态代理实现 BaseInterface proxyInstance = (BaseInterface) Proxy.newProxyInstance(base.getClass().getClassLoader(), base.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().equals(\"doSomething\")) { method.invoke(base, args); System.out.println(\"do more\"); } return null; } }); proxyInstance.doSomething(); } Proxy.java public class Proxy implements java.io.Serializable { // 代理类的缓存 private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); ··· // 生成代理对象方法入口 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException { Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); // 找到并生成相关的代理类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); // 调用代理类的构造方法生成代理类实例 try { final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) { cons.setAccessible(true); } return cons.newInstance(new Object[]{h}); } ··· } ··· // 定义和返回代理类的工厂类 private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; { // 所有代理类的前缀 private static final String proxyClassNamePrefix = \"$Proxy\"; // 用于生成唯一代理类名称的下一个数字 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) { Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); ··· String proxyPkg = null; // 用于定义代理类的包名 int accessFlags = Modifier.PUBLIC | Modifier.FINAL; // 确保所有 non-public 的代理接口在相同的包里 for (Class&lt;?&gt; intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( \"non-public interfaces from different packages\"); } } } if (proxyPkg == null) { // 如果没有 non-public 的代理接口，使用默认的包名 proxyPkg = \"\"; } { List&lt;Method&gt; methods = getMethods(interfaces); Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE); validateReturnTypes(methods); List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods); Method[] methodsArray = methods.toArray(new Method[methods.size()]); Class&lt;?&gt;[][] exceptionsArray = exceptions.toArray(new Class&lt;?&gt;[exceptions.size()][]); // 生成代理类的名称 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; // Android 特定修改：直接调用 native 方法生成代理类 return generateProxy(proxyName, interfaces, loader, methodsArray, exceptionsArray); // JDK 使用的 ProxyGenerator.generateProxyClas 方法创建代理类 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try { return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } ··· } } ··· // 最终调用 native 方法生成代理类 @FastNative private static native Class&lt;?&gt; generateProxy(String name, Class&lt;?&gt;[] interfaces, ClassLoader loader, Method[] methods, Class&lt;?&gt;[][] exceptions); } ProxyGenerator.java public static byte[] generateProxyClass(final String name, Class[] interfaces) { ProxyGenerator gen = new ProxyGenerator(name, interfaces); final byte[] classFile = gen.generateClassFile(); if (saveGeneratedFiles) { java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&lt;Void&gt;() { public Void run() { try { FileOutputStream file = new FileOutputStream(dotToSlash(name) + \".class\"); file.write(classFile); file.close(); return null; } catch (IOException e) { throw new InternalError( \"I/O exception saving generated file: \" + e); } } }); } return classFile; } 元注解 @Retention：保留的范围，可选值有三种。 RetentionPolicy 说明 SOURCE 注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里），如 @Override CLASS 注解在class文件中可用，但会被 VM 丢弃（该类型的注解信息会保留在源码里和 class 文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义 Retention 值时，默认值是 CLASS。 RUNTIME 注解信息将在运行期 (JVM) 也保留，因此可以通过反射机制读取注解的信息（源码、class 文件和执行的时候都有注解的信息），如 @Deprecated @Target：可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER等，未标注则表示可修饰所有 @Inherited：是否可以被继承，默认为false @Documented：是否会保存到 Javadoc 文档中","categories":[{"name":"Java","slug":"Java","permalink":"http://virogu.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://virogu.github.io/tags/Java/"}]},{"title":"MarkDown简明语法手册","slug":"docs/MarkDown/MarkDown简明语法手册","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/markdown/markdown-jian-ming-yu-fa-shou-ce/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/markdown/markdown-jian-ming-yu-fa-shou-ce/","excerpt":"","text":"markdown-handbook Markdown 简明语法手册GitHub地址 目录 标题 文本 普通文本 单行文本 多行文本 文字高亮 横线 链接 文字超链接 锚点 图片超链接 图片 列表 圆点列表 数字列表 复选框列表 块引用 代码 表格 表情 1.标题 行首加井号表示不同级别的标题 (H1-H6),例如：# H1, ## H2, ### H3，#### H4. 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 也可以使用在文字下放加 === 表示一级标题,使用 — 表示二级标题. 一级标题 二级标题 2. 文本 普通文本 直接输入的文字就是普通文本。需要注意的是要换行的时候不能直接通过回车来换行，需要使用&lt;br&gt;.也就是html里面的标签. 注意第三行的&lt;br&gt;前加了反斜杠 \\ .目的就是像其他语言那样实现转义，也就是 &lt; 的转义. 单行文本 使用两个Tab符实现单行文本. 多行文本 多行文本和 单行文本异曲同工，只要在 每行行首加两个Tab. 文字高亮 如果你想使一段话中部分文字高亮显示，来起到突出强调的作用，那么可以把它用 ` ` 包围起来.注意这不是单引号，而是Tab上方，数字1左边的按键（注意使用英文输入法). 3. 斜体和粗体 使用 * 和 ** 表示斜体和粗体. 这是 斜体,这是 粗体. 4. 删除线 使用~~表示删除线. 5. 外链接 使用 [描述](链接地址) 为文字增加外链接。 这是去往 有趣的HTML5和CSS3特效在线演示地址 的链接。 6.锚点 我们可以使用HTML的锚点标签（#）来设置锚点：回到目录但其实呢，每一个标题都是一个锚点，不需要用标签来指定，比如我们 回到顶部不过不幸的是，由于对中文支持的不好，所以中文标题貌似是不能视作标签的。 6. 列表 使用 *，+，- 表示无序列表。 无序列表项 一 无序列表项 二 无序列表项 三 二级三级原点 编程语言 脚本语言 Python 使用数字和点表示有序列表。 有序列表项 一 有序列表项 二 有序列表项 三 7. 数字列表自动排序 也可以在第一行指定1. ，而接下来的几行用星号*（或者继续用数字1. ）就可以了，它会自动显示成2、3、4……面向对象的七大原则： 开闭原则 里氏转换原则 依赖倒转原则 接口隔离原则 组合聚合复用原则 迪米特法则 单一直则原则 8. 多级数字列表 和圆点的列表一样，数字列表也有多级结构： 这是一级的数字列表，数字1还是1 这是二级的数字列表，阿拉伯数字在显示的时候变成了罗马数字 这是三级的数字列表，数字在显示的时候变成了英文字母 四级的数字列表显示效果，就不再变化了，依旧是英文字母 9. 复选框列表 C C++ Java Qt Android C# .NET 10. 文字引用 使用 &gt; 表示文字引用。 单个引用： 野火烧不尽，春风吹又生。 字符包围： 数据结构 树 二叉树 平衡二叉树 满二叉树 11. 代码块 使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 12. 加强的代码块 支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： $ sudo npm install Python 示例： @requires_authorization def somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or None class SomeClass: pass &gt;&gt;&gt; message = '''interpreter ... prompt''' JavaScript 示例： /** * nth element in the fibonacci series. * @param n &gt;= 0 * @return the nth element, &gt;= 0. */ function fib(n) { var a = 1, b = 1; var tmp; while (--n &gt;= 0) { tmp = a; a += b; b = tmp; } return a; } document.write(fib(10)); 13.插入图像 使用 ![描述](图片链接地址) 插入图像。 插入图片示例： 给图片添加链接: ![V][V]:https://github.com/gnipbao/gnipbao.github.io/blob/master/images/markdown.jpg 14.显示表格 表头1 | 表头2 ------------- | ------------- Content Cell | Content Cell Content Cell | Content Cell 表头1 表头2 Content Cell Content Cell Content Cell Content Cell 名字 描述 Help Display the help window. Close Closes a window 表格中也可以使用普通文本的删除线，斜体等效果 名字 描述 Help Display the help window. Close Closes a window 表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 表格中嵌入图片 图片 描述 图片 15. Html 标签 本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 16. 待办事宜 Todo 列表 使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 17.添加表情 Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情. 比如:blush:，可以显示😊. 详细查看emoji.","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/categories/MarkDown/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/tags/MarkDown/"}]},{"title":"一些常用的Gradle依赖","slug":"docs/Gradle/一些常用的Gradle依赖","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/gradle/yi-xie-chang-yong-de-gradle-yi-lai/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/gradle/yi-xie-chang-yong-de-gradle-yi-lai/","excerpt":"","text":"//kotlin安卓扩展 apply plugin: 'kotlin-android-extensions' //Retrifot(网络请求) implementation 'com.squareup.retrofit2:retrofit:2.0.2' implementation 'com.squareup.retrofit2:converter-gson:2.0.2' implementation 'com.squareup.okhttp3:okhttp:3.12.1' // CameraX def camerax_version = \"1.0.0-alpha05\" // CameraX view def camerax_view_version = \"1.0.0-alpha02\" // CameraX 扩展 library def camerax_ext_version = \"1.0.0-alpha02\" implementation \"androidx.camera:camera-core:$camerax_version\" //如果你要使用Camera2的扩展功能 implementation \"androidx.camera:camera-camera2:$camerax_version\" // 如果你要使用 CameraX View implementation \"androidx.camera:camera-view:$camerax_view_version\" // 如果你要使用 CameraX 的 扩展功能 implementation \"androidx.camera:camera-extensions:$camerax_ext_version\" //申请权限 implementation 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.5' //add at the end of android{} block compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } //Collection KTX implementation \"androidx.collection:collection-ktx:1.1.0\" //Permissionx implementation 'com.permissionx.guolindev:permissionx:1.3.0' implementation 'com.permissionx.guolindev:permission-support:1.3.0' //协程 implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\"","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"}]},{"title":"Gradle知识点汇总","slug":"docs/Gradle/Gradle知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/gradle/gradle-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/gradle/gradle-zhi-shi-dian-hui-zong/","excerpt":"","text":"依赖项配置 配置 说明 implementation Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当模块配置 implementation 依赖项时，其他模块只有在运行时才能使用该依赖项。 api Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。 compileOnly Gradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到编译输出）。 runtimeOnly Gradle 只会将依赖项添加到编译输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。 annotationProcessor 要添加对作为注解处理器的库的依赖关系，必须使用 annotationProcessor 配置将其添加到注解处理器类路径。","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"}]},{"title":"根据flavor设置不同启动页面","slug":"docs/Gradle/根据flavor设置不同启动页面","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/gradle/gen-ju-flavor-she-zhi-bu-tong-qi-dong-ye-mian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/gradle/gen-ju-flavor-she-zhi-bu-tong-qi-dong-ye-mian/","excerpt":"","text":"defaultConfig { &nbsp; &nbsp;...... &nbsp; &nbsp;// 先在默认配置中定义两个变量main_activity_key和oem_main_activity_key，并赋初始值 &nbsp; &nbsp;manifestPlaceholders += [main_activity_key: \"android.intent.action.MAIN\", &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oem_main_activity_key: \"android.intent.action.NO_MAIN\"] &nbsp; //不能单独写两个manifestPlaceholders，必须是一个数组，不然编译通不过 &nbsp; &nbsp;...... } productFlavors { OemA { buildConfigField \"int\", \"oem_type\", \"0\" } OemB { buildConfigField \"int\", \"oem_type\", \"0\" } } // 遍历OEM版本，在目标客户中根据需要替换main_activity_key和oem_main_activity_key的值 productFlavors.all {flavor -&gt; if (flavor.name.contains(\"OemA\")) { flavor.manifestPlaceholders = [main_activity_key: \"androidintent.action.NO_MAIN\", oem_main_activity_key: \"android.intent.action.MAIN\"] } else if (flavor.name.contains(\"OemB\")) { flavor.manifestPlaceholders = [main_activity_key: \"android.intent.action.MAIN\", &nbsp; &nbsp;oem_main_activity_key: \"android.intent.action.NO_MAIN\"] } } 然后在Manifest中修改两个Activity的action属性 &lt;activity android:name=\".ui.activity.OemAActivity\" android:excludeFromRecents=\"true\" android:launchMode=\"singleInstance\" android:screenOrientation=\"landscape\" android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"${oem_main_activity_key}\"/&gt; // 修改属性 &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".ui.activity.OemBActivity\" android:excludeFromRecents=\"true\" android:launchMode=\"singleInstance\" android:screenOrientation=\"landscape\" android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"${main_activity_key}\"/&gt; // 修改属性 &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"}]},{"title":"仓库中有某个库依然报错找不到某个依赖库","slug":"docs/Gradle/仓库中有某个库依然报错找不到某个依赖库","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/gradle/cang-ku-zhong-you-mou-ge-ku-yi-ran-bao-cuo-zhao-bu-dao-mou-ge-yi-lai-ku/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/gradle/cang-ku-zhong-you-mou-ge-ku-yi-ran-bao-cuo-zhao-bu-dao-mou-ge-yi-lai-ku/","excerpt":"","text":"gradle同步时提示找不到某个依赖库 先排除是不是网络有问题，或者这个库是不是真的不存在 但是大部分情况下上面这两个都是没问题的，还是会提示找不到某个依赖库，类似这样 Where: Build file xxx build.gradle.kts' line: 4 * What went wrong: Plugin [id:\"xxx:\" x.x.x ，apply: false] was not found in any of the following sources: -Gradle Core Plugins (plugin is not in 'org.gradle' namespace) -plugin Repositories (could not resolve plugin artifact xxx:x.x.x) Searched in the following repositories: maven(http://xxx1/repository/maven-releases/) maven2(http://xxx2/repository/maven-releases/) Gradle Central Plugin Repository Google MavenRepo Try: &gt; Run with --stacktrace option to get the stack trace . &gt; Run with --debug option to get more log output. &gt; Run with --scan to get full insights. 这种情况可以加上--info之后再执行一下，看看控制台输出的具体日志，有可能会出现类似下面的内容: ... Failed to get resource: HEAD.[HTTP HTTP/1.1 502 Bad Gateway: http://xxx2/repository/maven-releases/xxx.pom)] FAILURE: Build failed with an exception. ... 明明配置了多个仓库，但是gradle只在其中一个仓库中找不到这个依赖就直接报错停止了，没有继续从其他仓库中找。 这种情况是因为gradle下载依赖会判断 http status code，正常情况下如果仓库中没有某个依赖，返回的code应该是404，这时gradle才会继续从下一个仓库中寻找，但如果仓库服务器返回了不明的code，gralde就会视为程序异常直接抛出异常提示build失败。上面这个例子就是因为这个maven2仓库返回了502的状态导致构建直接异常。 解决办法，调整gradle脚本中仓库地址的顺序，尽量将官方的仓库放到前面，将第三方仓库或者自建的maven仓库放到后面。类似这样： pluginManagement { repositories { gradlePluginPortal() google() mavenCentral() maven { setUrl(\"http://xxx1\") } maven { setUrl(\"http://xxx2\") } } } 如果报错不是这个原因的话，再根据实际日志信息进行排查","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"}]},{"title":"使用fat-aar 打包依赖库到aar","slug":"docs/Gradle/使用fat-aar 打包依赖库到aar","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/gradle/shi-yong-fat-aar-da-bao-yi-lai-ku-dao-aar/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/gradle/shi-yong-fat-aar-da-bao-yi-lai-ku-dao-aar/","excerpt":"","text":"https://github.com/kezong/fat-aar-android 项目根目录 build.gradle 添加 buildscript { repositories { maven { url \"https://plugins.gradle.org/m2/\" } } dependencies { classpath 'com.kezong:fat-aar:1.3.1' } } module 的 build.gradle 添加： apply plugin: 'com.kezong.fat-aar' 使用：需要打包进aar的库使用 embed ，而不是 implementation embed(name: 'abcdef', ext: 'aar') embed('com.abc.abc:abc:1.2.3')","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"}]},{"title":"ssh-agent","slug":"docs/ssh/ssh-agent","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/ssh/ssh-agent/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/ssh/ssh-agent/","excerpt":"","text":"ssh-add命令是把专用密钥添加到ssh-agent的高速缓存中,从而提高ssh的认证速度。 命令语法 ssh-add [-cDdLlXx] [-t life] [file ...] ssh-add -s pkcs11 ssh-add -e pkcs11 命令选项 -D：删除ssh-agent中的所有密钥. -d：从ssh-agent中的删除密钥 -e pkcs11：删除PKCS#11共享库pkcs1提供的钥匙。 -s pkcs11：添加PKCS#11共享库pkcs1提供的钥匙。 -L：显示ssh-agent中的公钥 -l：显示ssh-agent中的密钥 -t life：对加载的密钥设置超时时间，超时ssh-agent将自动卸载密钥 -X：对ssh-agent进行解锁 -x：对ssh-agent进行加锁 开启ssh-agent 默认操作系统是不开启ssh-agent的，需要手动打开 Linux: ssh-agent bash Windows: 使用管理员打开Power Shell后执行： Start-Service ssh-agent 也可以设置自启动： Set-Service ssh-agent -StartupType Auto 把专用密钥添加到ssh-agent的高速缓存中 ssh-add ~/.ssh/id_dsa 从ssh-agent中删除密钥 ssh-add -d ~/.ssh/id_dsa.pub","categories":[{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/categories/ssh/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/tags/ssh/"}]},{"title":"ssh-config","slug":"docs/ssh/ssh-config","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/ssh/ssh-config/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/ssh/ssh-config/","excerpt":"","text":"ssh配置文件详解 1、/etc/ssh/ssh_config配置文件 选项参数 说明 Host * 选项“Host”只对能够匹配后面字串的计算机有效。“*”表示所有的计算机。 ForwardAgent no 设置连接是否经过验证代理（如果存在）转发给远程计算机。 ForwardX11 no 设置X11连接是否被自动重定向到安全的通道和显示集（DISPLAY set） RhostsAuthentication no 设置是否使用基于rhosts的安全验证 RhostsRSAAuthentication no 设置是否使用用RSA算法的基于rhosts的安全验证 RSAAuthentication yes 设置是否使用RSA算法进行安全验证 PasswordAuthentication yes 设置是否使用口令验证 FallBackToRsh no 设置如果用ssh连接出现错误是否自动使用rsh UseRsh no 设置是否在这台计算机上使用“rlogin/rsh” BatchMode no 如果设为“yes”，passphrase/password（交互式输入口令）的提示将被禁止。当不能交互式输入口令的时候，这个选项对脚本文件和批处理任务十分有用 CheckHostIP yes 设置ssh是否查看连接到服务器的主机的IP地址以防止DNS欺骗。建议设置为“yes” StrictHostKeyChecking no 如果设置成“yes”，ssh就不会自动把计算机的密匙加入“$HOME/.ssh/known_hosts”文件，并且一旦计算机的密匙发生了变化，就拒绝连接 IdentityFile ~/.ssh/identity 设置从哪个文件读取用户的RSA安全验证标识 Port 22 设置连接到远程主机的端口 Cipher blowfish 设置加密用的密码 EscapeChar ~ 设置escape字符 2、/etc/ssh/sshd_config配置文件 参数选项 说明 Port 22 SH 预设使用 22 这个 port，您也可以使用多的 port ！ Protocol 2,1 选择的 SSH 协议版本，可以是 1 也可以是 2 ，如果要同时支持两者，就必须要使用 2,1 这个分隔了！ ListenAddress 0.0.0.0 监听的主机适配卡！举个例子来说，如果您有两个 IP，分别是 192.168.0.100 及 192.168.2.20 ，那么只想要开放 192.168.0.100 时，就可以写如同下面的样式： ListenAddress 192.168.0.100 只监听来自 192.168.0.100 这个 IP 的SSH联机。如果不使用设定的话，则预设所有接口均接受 SSH PidFile /var/run/sshd.pid 可以放置 SSHD 这个 PID 的档案！左列为默认值 LoginGraceTime 600 当使用者连上 SSH server 之后，会出现输入密码的画面，在该画面中，在多久时间内没有成功连上 SSH server ，就断线！时间为秒！ Compression yes 是否可以使用压缩指令？ HostKey /etc/ssh/ssh_host_key SH version 1 使用的私钥 HostKey /etc/ssh/ssh_host_rsa_key SH version 2 使用的 RSA 私钥 HostKey /etc/ssh/ssh_host_dsa_key SH version 2 使用的 DSA 私钥 KeyRegenerationInterval 3600 由前面联机的说明可以知道， version 1 会使用 server 的 Public Key ，每隔一段时间来重新建立一次！时间为秒！ ServerKeyBits 768 erver key 的长度！ SyslogFacility AUTH 当有人使用 SSH 登入系统的时候，SSH会记录信息 LogLevel INFO 登录记录的等级—》全部 PermitRootLogin no 是否允许 root 登入！预设是允许的，但是建议设定成 no！ UserLogin no 在 SSH 底下本来就不接受 login 这个程序的登入！ StrictModes yes 当使用者的 host key 改变之后，Server 就不接受联机 RSAAuthentication yes 是否使用纯的 RSA 认证！？仅针对 version 1 ！ PubkeyAuthentication yes 是否允许 Public Key ？只有 version 2 AuthorizedKeysFile .ssh/authorized_keys 设定若要使用不需要密码登入的账号时，那么那个账号的存放档案所在档名！ RhostsAuthentication no 本机系统不使用 .rhosts ， .rhosts 不安全！ IgnoreRhosts yes 是否取消使用 ~/.ssh/.rhosts 来做为认证！ RhostsRSAAuthentication no 针对 version 1 ，使用 rhosts 档案在/etc/hosts.equiv配合 RSA 演算方式来进行认证！ HostbasedAuthentication no 这个项目与上面的项目类似，不过是给 version 2 使用的！ IgnoreUserKnownHosts no 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容 PasswordAuthentication yes 密码验证当然是需要的！ PermitEmptyPasswords no 上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，这个项目在是否允许以空的密码登入！ ChallengeResponseAuthentication yes 挑战任何的密码认证！所以，任何 login.conf 规定的认证方式，均可适用！ PAMAuthenticationViaKbdInt yes 是否启用其它的 PAM 模块！启用这个模块将会导致 PasswordAuthentication 设定失效！ 与Kerberos 有关的参数设定！底下不用设定 KerberosAuthentication no KerberosOrLocalPasswd yes KerberosTicketCleanup yes KerberosTgtPassing no 有关在 X-Window 底下使用的相关设定 X11Forwarding yes X11DisplayOffset 10 X11UseLocalhost yes PrintMotd no 登入后是否显示出一些信息呢？例如上次登入的时间、地点等，预设是 yes ，但是，如果为了安全，可以考虑改为 no ！ PrintLastLog yes 显示上次登入的信息！预设也是 yes KeepAlive yes 一般而言，如果设定这项目的话，那么 SSH Server 会传送KeepAlive 的讯息给 Client 端，以确保两者的联机正常！在这个情况下，任何一端死掉后， SSH 可以立刻知道！而不会有僵尸程序的发生！ UsePrivilegeSeparation yes 使用者的权限设定项目！ MaxStartups 10 同时允许几个尚未登入的联机画面 DenyUsers * 设定受抵挡的使用者名称 AllowUsers * 设定允许的使用者名称","categories":[{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/categories/ssh/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/tags/ssh/"}]},{"title":"抓包","slug":"docs/Others/抓包","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/others/zhua-bao/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/others/zhua-bao/","excerpt":"","text":"adb push tcpdump /data/local/tmp adb shell chmod 777 /data/local/tmp/tcpdump /data/local/tmp/tcpdump -i any -p -X -s 0 -w /sdcard/test.pcap adb pull /sdcard/test.pcap E:\\Files\\pcaps 监视指定主机的数据包 打印所有进入或离开sundown的数据包. tcpdump host sundown 也可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包 tcpdump host 210.27.48.1 打印helios 与 hot 或者与 ace 之间通信的数据包 tcpdump host helios and \\( hot or ace \\) 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信 tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) 打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包. tcpdump ip host ace and not helios 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： tcpdump ip host 210.27.48.1 and ! 210.27.48.2 截获主机hostname发送的所有数据 tcpdump -i eth0 src host hostname 监视所有送到主机hostname的数据包 tcpdump -i eth0 dst host hostname 监视指定主机和端口的数据包如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令 tcpdump tcp port 23 and host 210.27.48.1 对本机的udp 123 端口进行监视 123 为ntp的服务端口 tcpdump udp port 123 监视指定网络的数据包打印本地主机与Berkeley网络上的主机之间的所有通信数据包(nt: ucb-ether, 此处可理解为’Berkeley网络’的网络地址,此表达式最原始的含义可表达为: 打印网络地址为ucb-ether的所有数据包) tcpdump net ucb-ether 打印所有通过网关snup的ftp数据包(注意, 表达式被单引号括起来了, 这可以防止shell对其中的括号进行错误解析) tcpdump 'gateway snup and (port ftp or ftp-data)' 打印所有源地址或目标地址是本地主机的IP数据包(如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折,需补充).localnet 实际使用时要真正替换成本地网络的名字) tcpdump ip and not net localnet","categories":[{"name":"Others","slug":"Others","permalink":"http://virogu.github.io/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://virogu.github.io/tags/Others/"}]},{"title":"学习正则表达式的简单方法","slug":"docs/正则表达式/学习正则表达式的简单方法","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/zheng-ze-biao-da-shi/xue-xi-zheng-ze-biao-da-shi-de-jian-dan-fang-fa/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/zheng-ze-biao-da-shi/xue-xi-zheng-ze-biao-da-shi-de-jian-dan-fang-fa/","excerpt":"","text":"源文件地址 什么是正则表达式 ？ 正则表达式是一种被用于从文本中检索符合某些特定模式的文本。 正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。 想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名： 上面这个正则表达式可以匹配 john_doe，jo-hn_doe 和 john12_as。但是它不能匹配 Jo，因为该字符串里面包含大写字符，并且它太短了。 目录 基本匹配 元字符 英文句号 字符集 否定字符集 重复 星号 加号 问号 花括号 字符组 分支结构 转义特殊字符 定位符 插入符号 美元符号 简写字符集 断言 正向先行断言 负向先行断言 正向后行断言 负向后行断言 标记 不区分大小写 全局搜索 多行匹配 常用正则表达式 1. 基本匹配 正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 cat，表示：字母 c 后面跟着一个字母 a，再后面跟着一个字母 t。 \"cat\" =&gt; The cat sat on the mat 正则表达式 123 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。正则表达式通常区分大小写，因此正则表达式 Cat 与字符串“cat”不匹配。 \"Cat\" =&gt; The cat sat on the Cat 2. 元字符 元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。元字符如下： 元字符 描述 . 匹配除换行符以外的任意字符。 [ ] 字符类，匹配方括号中包含的任意字符。 [^ ] 否定字符类。匹配方括号中不包含的任意字符 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 {n,m} 花括号，匹配前面字符至少 n 次，但是不超过 m 次。 (xyz) 字符组，按照确切的顺序匹配字符 xyz。 | 分支结构，匹配符号之前的字符或后面的字符。 \\ 转义符，它可以还原元字符原来的含义，允许你匹配保留字符 [ ] ( ) { } . * + ? ^ $ \\ | ^ 匹配行的开始 $ 匹配行的结束 2.1 英文句号 英文句号 . 是元字符的最简单的例子。元字符 . 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 .ar，表示：任意字符后面跟着一个字母 a，再后面跟着一个字母 r。 \".ar\" =&gt; The car parked in the garage. 2.2 字符集 字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。例如正则表达式 [Tt]he，表示：大写 T 或小写 t ，后跟字母 h，再后跟字母 e。 \"[Tt]he\" =&gt; The car parked in the garage. 然而，字符集中的英文句号表示它字面的含义。正则表达式 ar[.]，表示小写字母 a，后面跟着一个字母 r，再后面跟着一个英文句号 . 字符。 \"ar[.]\" =&gt; A garage is a good place to park a car. 2.2.1 否定字符集 一般来说插入字符 ^ 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 [^c]ar，表示：除了字母 c 以外的任意字符，后面跟着字符 a，再后面跟着一个字母 r。 \"[^c]ar\" =&gt; The car parked in the garage. 2.3 重复 以下元字符 +，* 或 ? 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。 2.3.1 星号 星号 * 表示匹配上一个匹配规则零次或多次。正则表达式 a* 表示小写字母 a 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。例如正则表达式 [a-z]*，表示：一行中可以包含任意数量的小写字母。 \"[a-z]*\" =&gt; The car parked in the garage #21. 星号 * 可以与元符号 . 用在一起，用来匹配任意字符串 .*。星号 * 可以与空格符 \\s 一起使用，用来匹配一串空格字符。例如正则表达式 \\s*cat\\s*，表示：零个或多个空格，后面跟小写字母 c，再后面跟小写字母 a，再在后面跟小写字母 t，后面再跟零个或多个空格。 \"\\s*cat\\s*\" =&gt; The fat cat sat on the cat. 2.3.2 加号 加号 + 表示匹配上一个字符一次或多次。例如正则表达式 c.+t，表示：一个小写字母 c，后跟任意数量的字符，后跟小写字母 t。 \"c.+t\" =&gt; The fat cat sat on the mat. 2.3.3 问号 在正则表达式中，元字符 ? 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。例如正则表达式 [T]?he，表示：可选的大写字母 T，后面跟小写字母 h，后跟小写字母 e。 \"[T]he\" =&gt; The car is parked in the garage. \"[T]?he\" =&gt; The car is parked in the garage. 2.4 花括号 在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 [0-9]{2,3}，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。 \"[0-9]{2,3}\" =&gt; The number was 9.9997 but we rounded it off to 10.0. 我们可以省略第二个数字。例如正则表达式 [0-9]{2,}，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 [0-9]{2}，表示：匹配正好为 2 位数的数字。 \"[0-9]{2,}\" =&gt; The number was 9.9997 but we rounded it off to 10.0. \"[0-9]{2}\" =&gt; The number was 9.9997 but we rounded it off to 10.0. 2.5 字符组 字符组是一组写在圆括号内的子模式 (...)。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。例如正则表达式 (ab)* 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 |。例如正则表达式 (c|g|p)ar，表示：小写字母 c、g 或 p 后面跟字母 a，后跟字母 r。 \"(c|g|p)ar\" =&gt; The car is parked in the garage. 2.6 分支结构 在正则表达式中垂直条 | 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。例如正则表达式 (T|t)he|car，表示：匹配大写字母 T 或小写字母 t，后面跟小写字母 h，后跟小写字母 e，或匹配小写字母 c，后跟小写字母 a，后跟小写字母 r。 \"(T|t)he|car\" =&gt; The car is parked in the garage. 2.7 转义特殊字符 正则表达式中使用反斜杠 \\ 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 { } [ ] / \\ + * . $ ^ | ?。在特殊字符前面加 \\，就可以使用它来做匹配字符。例如正则表达式 . 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 . 字符，正则表达式 (f|c|m)at\\.?，表示：小写字母 f、c 或者 m 后跟小写字母 a，后跟小写字母 t，后跟可选的 . 字符。 \"(f|c|m)at\\.?\" =&gt; The fat cat sat on the mat. 2.8 定位符 在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。定位符有两种类型：第一种类型是 ^ 检查匹配字符是否是起始字符，第二种类型是 $，它检查匹配字符是否是输入字符串的最后一个字符。 2.8.1 插入符号 插入符号 ^ 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 ^a（如果 a 是起始符号）匹配字符串 abc，它会匹配到 a。但是如果我们使用正则表达式 ^b，它是匹配不到任何东西的，因为在字符串 abc 中“b”不是起始字符。让我们来看看另一个正则表达式 ^(T|t)he，这表示：大写字母 T 或小写字母 t 是输入字符串的起始符号，后面跟着小写字母 h，后跟小写字母 e。 \"(T|t)he\" =&gt; The car is parked in the garage. \"^(T|t)he\" =&gt; The car is parked in the garage. 2.8.2 美元符号 美元 $ 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 (at\\.)$，表示：小写字母 a，后跟小写字母 t，后跟一个 . 字符，且这个匹配器必须是字符串的结尾。 \"(at\\.)\" =&gt; The fat cat. sat. on the mat. \"(at\\.)$\" =&gt; The fat cat sat on the mat. 3. 简写字符集 正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下： 简写 描述 . 匹配除换行符以外的任意字符 \\w 匹配所有字母和数字的字符：[a-zA-Z0-9_] \\W 匹配非字母和数字的字符：[^\\w] \\d 匹配数字：[0-9] \\D 匹配非数字：[^\\d] \\s 匹配空格符：[\\t\\n\\f\\r\\p{Z}] \\S 匹配非空格符：[^\\s] 4. 断言 后行断言和先行断言有时候被称为断言，它们是特殊类型的 非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。例如我们想获取输入字符串 $4.44 and $10.88 中带有前缀 $ 的所有数字。我们可以使用这个正则表达式 (?&lt;=\\$)[0-9\\.]*，表示：获取包含 . 字符且前缀为 $ 的所有数字。以下是正则表达式中使用的断言： 符号 描述 ?= 正向先行断言 ?! 负向先行断言 ?&lt;= 正向后行断言 ?&lt;! 负向后行断言 4.1 正向先行断言 正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 (?=...)。先行断言表达式写在括号中的等号后面。例如正则表达式 (T|t)he(?=\\sfat)，表示：匹配大写字母 T 或小写字母 t，后面跟字母 h，后跟字母 e。在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 fat 的 The 或 the。 \"(T|t)he(?=\\sfat)\" =&gt; The fat cat sat on the mat. 4.2 负向先行断言 当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，唯一的区别在于我们使用否定符号 ! 而不是等号 =，例如 (?!...)。我们来看看下面的正则表达式 (T|t)he(?!\\sfat)，表示：从输入字符串中获取全部 The 或者 the 且不匹配 fat 前面加上一个空格字符。 \"(T|t)he(?!\\sfat)\" =&gt; The fat cat sat on the mat. 4.3 正向后行断言 正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 (?&lt;=...)。例如正则表达式 (?&lt;=(T|t)he\\s)(fat|mat)，表示：从输入字符串中获取在单词 The 或 the 之后的所有 fat 和 mat 单词。 \"(?&lt;=(T|t)he\\s)(fat|mat)\" =&gt; The fat cat sat on the mat. 4.4 负向后行断言 负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 (?&lt;!...)。例如正则表达式 (?&lt;!(T|t)he\\s)(cat)，表示：在输入字符中获取所有不在 The 或 the 之后的所有单词 cat。 \"(?&lt;!(T|t)he\\s)(cat)\" =&gt; The cat sat on cat. 5. 标记 标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。 标记 描述 i 不区分大小写：将匹配设置为不区分大小写。 g 全局搜索：搜索整个输入字符串中的所有匹配。 m 多行匹配：会匹配输入字符串每一行。 5.1 不区分大小写 i 修饰符用于执行不区分大小写匹配。例如正则表达式 /The/gi，表示：大写字母 T，后跟小写字母 h，后跟字母 e。但是在正则匹配结束时 i 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 g 标记，因为我们要在整个输入字符串中搜索匹配。 \"The\" =&gt; The fat cat sat on the mat. \"/The/gi\" =&gt; The fat cat sat on the mat. 5.2 全局搜索 g 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。例如正则表达式 /.(at)/g，表示：除换行符之外的任意字符，后跟小写字母 a，后跟小写字母 t。因为我们在正则表达式的末尾使用了 g 标记，它会从整个输入字符串中找到每个匹配项。 \".(at)\" =&gt; The fat cat sat on the mat. \"/.(at)/g\" =&gt; The fat cat sat on the mat. 5.3 多行匹配 m 修饰符被用来执行多行的匹配。正如我们前面讨论过的 (^, $)，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 m 修饰符。例如正则表达式 /at(.)?$/gm，表示：小写字母 a，后跟小写字母 t，匹配除了换行符以外任意字符零次或一次。而且因为 m 标记，现在正则表达式引擎匹配字符串中每一行的末尾。 \"/.at(.)?$/\" =&gt; The fat cat sat on the mat. \"/.at(.)?$/gm\" =&gt; The fat cat sat on the mat. 常用正则表达式 正整数：^\\d+$ 负整数：^-\\d+$ 电话号码：^+?[\\d\\s]{3,}$ 电话代码：^+?[\\d\\s]+(?[\\d\\s]{10,}$ 整数：^-?\\d+$ 用户名：^[\\w\\d_.]{4,16}$ 字母数字字符：^[a-zA-Z0-9]*$ 带空格的字母数字字符：^[a-zA-Z0-9 ]*$ 密码：^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$ 电子邮件：^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4})*$ IPv4 地址：^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$ 小写字母：^([a-z])*$ 大写字母：^([A-Z])*$ 网址：^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%&amp;_\\.~?\\-]*))*$ VISA 信用卡号码：^(4[0-9]{12}(?:[0-9]{3})?)*$ 日期（MM/DD/YYYY）：^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$ 日期（YYYY/MM/DD）：^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$ 万事达信用卡号码：^(5[1-5][0-9]{14})*$ Contribution Report issues Open pull request with improvements Spread the word License MIT © Zeeshan Ahmed ⬆ top","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"常用到正则表达式","slug":"docs/正则表达式/常用到正则表达式","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/zheng-ze-biao-da-shi/chang-yong-dao-zheng-ze-biao-da-shi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/zheng-ze-biao-da-shi/chang-yong-dao-zheng-ze-biao-da-shi/","excerpt":"","text":"源文件地址 目录 邮箱 电话 域名 IP 帐号校验 字符校验 汉字 英文和数字 长度为3-20的所有字符 英文字符 由26个英文字母组成的字符串 由26个大写英文字母组成的字符串 由26个小写英文字母组成的字符串 由数字和26个英文字母组成的字符串 由数字、26个英文字母或者下划线组成的字符串 中文、英文、数字包括下划线 中文、英文、数字但不包括下划线等符号 禁止输入含有^%&amp;’,;=?$\"等字符 禁止输入含有~的字符 数字正则 整数 正整数 负整数 非负整数 非正整数 浮点数 正浮点数 负浮点数 非负浮点数 非正浮点数 邮箱 gaozihang-001@gmail.com 只允许英文字母、数字、下划线、英文句号、以及中划线组成 ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ 高子航001Abc@bowbee.com.cn 名称允许汉字、字母、数字，域名只允许英文域名 ^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ 电话 13012345678 手机号 ^1(3|4|5|6|7|8|9)\\d{9}$ XXX-XXXXXXX XXXX-XXXXXXXX 固定电话 (\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{8} 域名 https://google.com/ ^((http:\\/\\/)|(https:\\/\\/))?([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}(\\/) IP 127.0.0.1 ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 帐号校验 gaozihang_001 字母开头，允许5-16字节，允许字母数字下划线 ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 字符校验 汉字 高子航 ^[\\u4e00-\\u9fa5]{0,}$ 英文和数字 ^[A-Za-z0-9]+$ 长度为3-20的所有字符 ^.{3,20}$ 英文字符 由26个英文字母组成的字符串 ^[A-Za-z]+$ 由26个大写英文字母组成的字符串 ^[A-Z]+$ 由26个小写英文字母组成的字符串 ^[a-z]+$ 由数字和26个英文字母组成的字符串 ^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串 ^\\w+$ 中文、英文、数字包括下划线 ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号 ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 禁止输入含有%&amp;’,;=?$\"等字符 [^%&amp;',;=?$\\x22]+ 禁止输入含有~的字符 [^~\\x22]+ 数字正则 整数 ^-?[1-9]\\d*$ 正整数 ^[1-9]\\d*$ 负整数 ^-[1-9]\\d*$ 非负整数 ^[1-9]\\d*|0$ 非正整数 ^-[1-9]\\d*|0$ 浮点数 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 正浮点数 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 负浮点数 ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 非负浮点数 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ License MIT License. See the LICENSE file. ⬆ top","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"正则表达式","slug":"docs/正则表达式/正则表达式","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/zheng-ze-biao-da-shi/zheng-ze-biao-da-shi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/zheng-ze-biao-da-shi/zheng-ze-biao-da-shi/","excerpt":"","text":"正则表达式 基本表达式 表达式 匹配 示例 \\u#### 中文字符 \\u548c -&gt; 和 . 任意一个字符 \\d 一个数字 \\D 一个非数字 \\w 一个字母、数字或下划线 \\s 一个空格字符(空格，tab 等) \\S 非\\s * 修饰符，匹配任意个字符 + 修饰符，至少一个数字 ？ 修饰符，匹配 0 个或 1 个字符 {n} 修饰符，匹配 n 个字符 \\d{3} - &gt; 匹配 3 个数字 {m,n} 修饰符，匹配 m 到 n 个字符 \\d{3,5} -&gt; 匹配 3 到 5 个数字 {n,} 修饰符，匹配至少 n 个字符 \\d{3,} -&gt; 匹配至少 3 个数字 […] 修饰符，匹配[ ]里面的字符 [123456789]\\d{6,7} -&gt; 匹配不以 0 开头的 7-8 位数字 [1-9]\\d{6,7} -&gt; 同上 [^…] 修饰符，匹配不包含 … 的字符 | 或 ^ 开头 ^\\d -&gt; 数字开头 $ 结尾 \\d$ -&gt; 数字结尾 其他表达式示例 表达式 匹配 (($\\n\\r*$)|(^\\n\\r*^)) 匹配空行 (^(\\s|&amp;nbsp;)*$) 匹配空行,包含空格 [一-龥] 匹配汉字","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"JNI中打印AndroidLog","slug":"docs/Android/JNI/JNI中打印AndroidLog","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/jni/jni-zhong-da-yin-androidlog/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/jni/jni-zhong-da-yin-androidlog/","excerpt":"","text":"#include &lt;android/log.h&gt; #define TAG \"LogTag\" #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__) #define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__) #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"JNI","slug":"Android/JNI","permalink":"http://virogu.github.io/categories/Android/JNI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"图片操作（byte[],Bitmap,YuvImage,Drawable）旋转、缩放、相互转化","slug":"docs/Android/工具类/图片操作（byte[],Bitmap,YuvImage,Drawable）旋转、缩放、相互转化","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/gong-ju-lei/tu-pian-cao-zuo-byte-bitmap-yuvimage-drawable-xuan-zhuan-suo-fang-xiang-hu-zhuan-hua/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/gong-ju-lei/tu-pian-cao-zuo-byte-bitmap-yuvimage-drawable-xuan-zhuan-suo-fang-xiang-hu-zhuan-hua/","excerpt":"","text":"byte[],Bitmap,YuvImage,Drawable 旋转、缩放、相互转化 1、byte-&gt;Bitmap 在相机开发中，Camera获取到摄像头每一帧的图像数据byte[]，有时候需要把它转为Bitmap @Override public void onPreviewFrame(final byte[] data, Camera camera) { camera.setPreviewCallback(null); if (mCamera == null) return; Camera.Parameters parameters = camera.getParameters(); int width = parameters.getPreviewSize().width; int height = parameters.getPreviewSize().height; YuvImage yuv = new YuvImage(data, parameters.getPreviewFormat(), width, height, null); ByteArrayOutputStream out = new ByteArrayOutputStream(); yuv.compressToJpeg(new Rect(0, 0, width, height), 50, out); byte[] bytes = out.toByteArray(); final Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length); this.mCamera.setPreviewCallback(this); } 2、byte顺时针旋转90度 Camera获取到摄像头图像帧数据，直接把byte[]数据进行图像旋转。 private byte[] rotateYUV420Degree90(byte[] data, int imageWidth, int imageHeight) { byte [] yuv = new byte[imageWidth*imageHeight*3/2]; // Rotate the Y luma int i = 0; for(int x = 0;x &lt; imageWidth;x++) { for(int y = imageHeight-1;y &gt;= 0;y--) { yuv[i] = data[y*imageWidth+x]; i++; } } // Rotate the U and V color components i = imageWidth*imageHeight*3/2-1; for(int x = imageWidth-1;x &gt; 0;x=x-2) { for(int y = 0;y &lt; imageHeight/2;y++) { yuv[i] = data[(imageWidth*imageHeight)+(y*imageWidth)+x]; i--; yuv[i] = data[(imageWidth*imageHeight)+(y*imageWidth)+(x-1)]; i--; } } return yuv; } Android很多使用zxing扫码工具，关于获取预览帧进行旋转的代码，大多数都是错误的，包括徐医生的在内的。我从Zxing官方项目，下载源码进行了优化和精简，使用了很多不错的特性。源码地址 3 、从resources中获取Bitmap Resources res = getResources(); Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.icon); 4、Bitmap → byte[] public byte[] Bitmap2Bytes(Bitmap bm) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); bm.compress(Bitmap.CompressFormat.PNG, 100, baos); return baos.toByteArray(); } 5、byte[] → Bitmap public Bitmap Bytes2Bimap(byte[] b) { if (b.length != 0) { return BitmapFactory.decodeByteArray(b, 0, b.length); } else { return null; } } 6、将Drawable转化为Bitmap public static Bitmap drawableToBitmap(Drawable drawable) { // 取 drawable 的长宽 int w = drawable.getIntrinsicWidth(); int h = drawable.getIntrinsicHeight(); // 取 drawable 的颜色格式 Bitmap.Config config = drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565; // 建立对应 bitmap Bitmap bitmap = Bitmap.createBitmap(w, h, config); // 建立对应 bitmap 的画布 Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, w, h); // 把 drawable 内容画到画布中 drawable.draw(canvas); return bitmap; } 7、Bitmap转换成Drawable Bitmap bm=xxx; //xxx根据你的情况获取 BitmapDrawable bd= new BitmapDrawable(getResource(), bm); //因为BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。 8、Bitmap缩放 public static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) { int w = bitmap.getWidth(); int h = bitmap.getHeight(); Matrix matrix = new Matrix(); float scaleWidth = ((float) width / w); float scaleHeight = ((float) height / h); matrix.postScale(scaleWidth, scaleHeight); Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true); return newbmp; } 9、Drawable缩放 public static Drawable zoomDrawable(Drawable drawable, int w, int h) { int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); // drawable转换成bitmap Bitmap oldbmp = drawableToBitmap(drawable); // 创建操作图片用的Matrix对象 Matrix matrix = new Matrix(); // 计算缩放比例 float sx = ((float) w / width); float sy = ((float) h / height); // 设置缩放比例 matrix.postScale(sx, sy); // 建立新的bitmap，其内容是对原bitmap的缩放后的图 Bitmap newbmp = Bitmap.createBitmap(oldbmp, 0, 0, width, height,matrix, true); return new BitmapDrawable(newbmp); }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"工具类","slug":"Android/工具类","permalink":"http://virogu.github.io/categories/Android/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"EditText","slug":"docs/Android/View/EditText","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/edittext/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/edittext/","excerpt":"","text":"一些 inputType 属性值 android:inputType=\"none\"--输入普通字符 android:inputType=\"text\"--输入普通字符 android:inputType=\"textCapWords\"--单词首字母大小 android:inputType=\"textCapSentences\"--仅第一个字母大小 android:inputType=\"textAutoCorrect\"--前两个自动完成 android:inputType=\"textAutoComplete\"--前两个自动完成 android:inputType=\"textMultiLine\"--多行输入 android:inputType=\"textImeMultiLine\"--输入法多行（不一定支持） android:inputType=\"textNoSuggestions\"--不提示 android:inputType=\"textUri\"--URI格式 android:inputType=\"textEmailAddress\"--电子邮件地址格式 android:inputType=\"textEmailSubject\"--邮件主题格式 android:inputType=\"textShortMessage\"--短消息格式 android:inputType=\"textLongMessage\"--长消息格式 android:inputType=\"textPersonName\"--人名格式 android:inputType=\"textPostalAddress\"--邮政格式 android:inputType=\"textPassword\"--密码格式 android:inputType=\"textVisiblePassword\"--密码可见格式 android:inputType=\"textWebEditText\"--作为网页表单的文本格式 android:inputType=\"textFilter\"--文本筛选格式 android:inputType=\"textPhonetic\"--拼音输入格式 android:inputType=\"number\"--数字格式 android:inputType=\"numberSigned\"--有符号数字格式 android:inputType=\"numberDecimal\"--可以带小数点的浮点格式 android:inputType=\"phone\"--拨号键盘 android:inputType=\"datetime\" android:inputType=\"date\"--日期键盘 android:inputType=\"time\"--时间键盘 清单文件里面键盘的属性 android:windowSoftInputMode \"stateUnspecified\" 软键盘的状态&nbsp;(是否它是隐藏或可见&nbsp;)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。 这个是软键盘行为默认的设置。 ​\"stateUnchanged\"​ 软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。 ​\"stateHidden\"​ 当用户选择该&nbsp;Activity时，软键盘被隐藏——也就是，当用户确定导航到该&nbsp;Activity时，而不是返回到它由于离开另一个&nbsp;Activity。 ​\"stateAlwaysHidden\"​ 软键盘总是被隐藏的，当该&nbsp;Activity主窗口获取焦点时。 ​\"stateVisible\"​ 软键盘是可见的，当那个是正常合适的时&nbsp;(当用户导航到&nbsp;Activity主窗口时&nbsp;)。 ​\"stateAlwaysVisible\"​ 当用户选择这个&nbsp;Activity时，软键盘是可见的——也就是，也就是，当用户确定导航到该&nbsp;Activity时，而不是返回到它由于离开另一个Activity。 ​\"adjustUnspecified\"​ 它不被指定是否该&nbsp;Activity主 窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。 系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局 视图能够滚动他们的内容。如果有这样的一个视图， 这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为 设置。 ​\"adjustResize\"​ 该&nbsp;Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间 ​\"adjustPan\"​ 该&nbsp;Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。 这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。 禁止EditText横屏键盘全屏 android:imeOptions=\"flagNoExtractUi\" 注意 若在切换横竖屏后页面显示不全需要追加属性 ​flagNoFullscreen​ android:imeOptions=\"flagNoExtractUi|flagNoFullscreen\"","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"RadioButton","slug":"docs/Android/View/RadioButton","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/radiobutton/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/radiobutton/","excerpt":"","text":"RadioButton 切换文字和按钮布局 RadioButton默认选择框是在左边显示的，文字显示在右边。 在某些场景下，我们想在右边显示选择框，左边显示文字，给RadioButton 添加一下两个属性就可实现这种效果 android:layoutDirection=\"rtl\" android:textDirection=\"ltr\" 两个属性的值分别设置成 ltr 和 rtl 可以实现4种布局效果","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"TextView","slug":"docs/Android/View/TextView","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/textview/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/textview/","excerpt":"","text":"TextView 跑马灯 &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"40sp\" android:singleLine=\"true\" android:ellipsize=\"marquee\" android:focusableInTouchMode=\"true\" android:focusable=\"true\" android:clickable=\"true\" android:marqueeRepeatLimit=\"marquee_forever\" android:text=\"人民日报生活漫步：莫让千元打车费毁了专车\" /&gt; focusableInTouchMode=\"true\" focusable=\"true\" clickable=\"true\" singleLine=\"true\" android:ellipsize=\"marquee\" 以上五个属性必须设置 marqueeReatLimit属性是滚动重复次数，设置为marquee_forever 意思为一直都是滚动模式。","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"TextView相关","slug":"docs/Android/View/TextView相关","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/textview-xiang-guan/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/textview-xiang-guan/","excerpt":"","text":"/** * EditText限制只能输入汉字 */ public InputFilter getInputFilter() { InputFilter filter = new InputFilter() { public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { if (TextUtils.isEmpty(source)){ return \"\"; } for (int i = start; i &lt; end; i++) { if (stringFilterChinese(source) &amp;&amp; !source.toString().contains(\"。\") &amp;&amp; !source.toString ().contains(\"，\")) { return \"\"; } else if (CHINESE_RADICAL_DIGISTS.contains(source)) { return \"\"; } } return null; } }; return filter; } /** * 限制只能输入汉字，过滤非汉字 * * @param str 输入值 * @return true 非汉字；false 汉字 */ public boolean stringFilterChinese(CharSequence str) { //只允许汉字，正则表达式匹配出所有非汉字 String regEx = \"[^\\u4E00-\\u9FA5]\"; Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(str); if (m.find()) { return true; } else { return false; } } mEdtAddDictation.setFilters(new InputFilter[]{getInputFilter()});","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"AndroidSamples","slug":"docs/Android/其他/AndroidSamples","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/androidsamples/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/androidsamples/","excerpt":"","text":"AndroidSamples Android Camera1 DataStoreDemo mediasoup-demo-android MLKit UVCCamera android-test android-compose-codelabs animation-samples background-tasks-samples camera-samples compose-samples graphics-samples material-components-android permissions-samples testing-samples user-interface-samples views-widgets-samples splashscreen-sample","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Android目录文件简析","slug":"docs/Android/其他/Android目录文件简析","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/android-mu-lu-wen-jian-jian-xi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/android-mu-lu-wen-jian-jian-xi/","excerpt":"","text":"Android目录文件简析 [TOC] 根目录 data data分区 app 用户安装的软件都在这里面,一个包名一个文件夹 oat/arm/base.art,base.odex,base.vdex 用户运行应用，而这随后就会触发 ART 加载 .dex 文件。如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件，软件速度会明显提升。删除这个文件夹一般不会影响软件功能，但是软件速度会明显变慢。有Speed编译方式和Everything编译 dalvik-cache 里面有arm和arm64文件夹，存放软件编译后的文件，这些文件删除后会重新生成。 data 软件数据目录 media 0 手机内部存储分区 system locksettings.db 锁屏密码文件，删除此文件即可删除手机锁屏密码 dev 手机各分区文件 etc host 127.0.0.1 localhost :: 1ip6-localhost 可以修改此文件达到去广告或限制手机访问某些域名的目的比如加上127.0.0.1 baidu.com ，手机就访问不了百度了 misc wifi WifiConfigStore.xml 这个文件存放手机连接的WiFi信息，打开可以查看手机连接过的所有WiFi密码信息 sbin sdcard 实质上是一个快捷方式，指向data/media/0 storage storage/emulated/0 也是 data/media/0 手机内部存储目录 system app 系统级非核心软件，删除里面的软件系统不一定会崩溃 data-app 不是必有的文件夹，有些系统会预装很多软件，即使卸载后，再恢复出厂设置就又会出现，这些预装软件就是放在这里面的，系统第一次初始化时会把这些软件安装到data分区 priv-app 安卓4.4增加的新分区，主要是存放系统的系统级核心应用，比如电话，短信，设置，SystemUI等，这些应用需要系统级权限，而又不能被用户卸载掉，删除里面的软件后系统会崩溃 xbin 如果使用普通方式 root，里面会有su文件，可以通过此方式判断设备有没有被 root，但是如果是用的magisk进行root不会有这个文件，magisk可以隐藏 root（现在应该有别的方式去判断是否有root权限，Magisk应该也有别的方式去隐藏root） media 系统媒体文件夹 audio alarm 系统预设闹铃铃声 notification 系统预设通知铃声 ringtones 系统预设电话铃声 ui 系统各种UI提示音比如拍照快门声，充电音效，锁屏音效等 lockscreen，wallpager 系统预设壁纸 bootanimation.zip 开机动画，里面是包含一个desc.txt文件和若干个part文件夹part 文件夹里面是动画的每一帧desc 文件用来描述动画属性 build.prop 系统配置属性文件正确的修改可以自定义系统某些特性。下面是里面部分内容所代表的意思 ro.boot.selinux=permissive permissive模式 #音量阶数 ro.config.media_vol_steps = 30 #增加虚拟键 qemu.hw.mainkeys=0 #谷歌相机 persist.camera.HAL3.enabled=1 #增加虚拟键 qemu.hw.mainkeys=0 #渲染GPU的UI debug.sf.hw=1 #禁用开机动画 debug.sf.nobootanimation=1 vendor 安卓8新加的分区有vendor分区不一定支持PT（ProjectTreble），支持PT的一定有vendor分区这里面存放底层芯片硬件驱动等 Xposed Xposed 是一款开源框架，可以在不修改APK的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。Xposed 具有比较高的可定制化程度。用户可定制手机的外观、状态等几乎所有东西，Xposed的主要作用是hook应用方法，动态劫持方法的运行逻辑。需要用 Xposed管理器 配合相关 XP模块 来使用。目前Xposed 已经停止维护，在高版本安卓上面已经不能使用了，取而代之的有Edxposed、LSPosed等Xp模块也是一个apk，编写时引用的XposedBridgeApi.jar，Mainfest.xml文件加入以下标签 &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\"/&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"这是一个xposed应用\"/&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"54\"/&gt; 然后编写hook工具类，重写handleLoadPakage方法 public class XposedHookUtil implements IXposedHookLoadPackage { String class_name = \"com.hdc.xposeddemo.MainActivity\"; // 对指定包名,指定方法进行hook，将其修改成自己的方法 @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { Class clazz = loadPackageParam.classLoader.loadClass(class_name); XposedHelpers.findAndHookMethod(clazz, \"getTTAd\", new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { xxxx; } }); } } 常用的Xposed模块：QX，微X，应用变量等","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"ContentResolver","slug":"docs/Android/其他/ContentResolver","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/contentresolver/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/contentresolver/","excerpt":"","text":"ContentResolver 遍历其他类型文件 val cursor: Cursor? = requireContext().contentResolver.query( //数据源 MediaStore.Files.getContentUri(\"external\"), // 想要查询的信息 arrayOf( MediaStore.Files.FileColumns._ID, MediaStore.Files.FileColumns.TITLE, MediaStore.Files.FileColumns.DISPLAY_NAME, ), //条件为文件类型 MediaStore.Files.FileColumns.MIME_TYPE + \"= ?\", arrayOf( MimeTypeMap.getSingleton().getMimeTypeFromExtension(\"docx\"), MimeTypeMap.getSingleton().getMimeTypeFromExtension(\"pdf\"), MimeTypeMap.getSingleton().getMimeTypeFromExtension(\"doc\"), MimeTypeMap.getSingleton().getMimeTypeFromExtension(\"xls\"), MimeTypeMap.getSingleton().getMimeTypeFromExtension(\"xlsx\"), ), //默认排序 null )","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"WebRTC编译","slug":"docs/Android/其他/WebRTC编译","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/webrtc-bian-yi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/webrtc-bian-yi/","excerpt":"","text":"https://glumes.com/post/webrtc/webrtc-android-setup/ 安装工具 下载工具 // 安装一些基础的软件依赖 sudo apt-get update sudo apt-get install -y openssl vim git gcc g++ curl python build-essential inetutils-ping net-tools sudo lsb-release libxml2 下载depot_tools git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 配置环境 // 配置环境，打开.bashrc文件 gedit ~/.bashrc // 在这文件添加如下内容 # depot_tools_path export DEPOT_TOOLS_PATH=/root/work/webrtc/depot_tools export PATH=${PATH}:${DEPOT_TOOLS_PATH} // 使环境生效 source ~/.bashrc // 查看是否设置成功 echo $PATH fetch --help 建立源码路径，下载好源码（漫长的过程）后期更新只需要执行 gclient sync 即可 mkdir webrtc cd webrtc fetch --nohooks webrtc_android gclient sync 安装依赖 下载完 WebRTC 后需要安装相关的依赖，进入到 WebRTC 源码的 src 目录中，执行如下命令： cd src ./build/install-build-deps.sh --no-chromeos-fonts ./build/install-build-deps-android.sh --no-chromeos-fonts 执行shell脚本时报错：: 没有那个文件或目录是因为该文件在windows系统上打开过，关闭后其中的空格符号和Linux的不同，导致这个报错，我们可以通过sed命令与正则的配合将文件中的空格符号替换成linux的空格： sed -i 's/\\r$//' xxx.sh 编译 设置编译参数，生成ninja文件 # source ./build/android/envsetup.sh gn gen out/build --args='target_os=\"android\" target_cpu=\"arm64\" is_debug=false treat_warnings_as_errors=false' # out/build ： 编译生成文件的目录，随意指定 # target_os ： 编译目标平台 android ios 等 # target_cpu ： CPU架构平台 arm arm64 x86 x64等 # is_debug : Release模式或者Debug模式 清理目录 gn clean out/build 编译 #全量编译 ninja -C out/build ninja -C out/build AppRTCMobile #编译组合 a)编译arm debug版本 gn gen out/Debug_arm --args='target_os=\"android\" target_cpu=\"arm\" treat_warnings_as_errors=false' ninja -C out/Debug_arm b)编译arm64 debug版本 gn gen out/Debug_arm64 --args='target_os=\"android\" target_cpu=\"arm64\" treat_warnings_as_errors=false' ninja -C out/Debug_arm64 c)编译arm release版本 gn gen out/Release_arm --args='target_os=\"android\" target_cpu=\"arm\" is_debug=false treat_warnings_as_errors=false' ninja -C out/Release_arm d)编译arm64 release版本 gn gen out/Release_arm64 --args='target_os=\"android\" target_cpu=\"arm64\" is_debug=false treat_warnings_as_errors=false' ninja -C out/Release_arm64 生成aar cd webrtc/src python tools_webrtc/android/build_aar.py --output \"libwebrtc.aar\" --arch \"armeabi-v7a\" \"arm64-v8a\" --build-dir out/Release --extra-gn-args 'is_debug=false is_component_build=false is_clang=true rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false use_rtti=true use_custom_libcxx=false treat_warnings_as_errors=false' //只编译 arm64 python tools_webrtc/android/build_aar.py --output \"libwebrtc.aar\" --arch \"arm64-v8a\" --build-dir out/Release --extra-gn-args 'is_debug=false is_component_build=false is_clang=true rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false use_rtti=true use_custom_libcxx=false treat_warnings_as_errors=false' # 成功后你会在src目录下看到libwebrtc.aar文件，里面就是Android开发需要用到的SDK了。 # out/Release目录是编译目录，第一编译会全量编译速度很慢（预计30~40分钟），以后就增量编译很快（预计10s内）。 生成so文件，生成so文件首次会全量编译，后续增量编译速度非常快。如果以后只改C层代码不生成Java或者Object-C的API，这种方法非常适合测试。 ninja -C out/Release sdk/android:libjingle_peerconnection_so 编译mediasoupclient $ cd /root/work/libmediasoupclient $ cmake . -Bbuild \\ -DLIBWEBRTC_INCLUDE_PATH:PATH=/root/work/webrtc/webrtc_android/src \\ -DLIBWEBRTC_BINARY_PATH:PATH=/root/work/webrtc/webrtc_android/src/out/build/obj $ make -C build/ 安装包时可能会因为依赖其他包而安装失败，可以使用aptitude安装 // 安装aptitude sudo apt-get install aptitude // 安装所需要的包 sudo aptitude install xxxxx 或者 https://launchpad.net/ubuntu 搜索需要的deb包，然后到本地下载，然后dpkg -i xxx.deb","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"查看Apk签名信息","slug":"docs/Android/其他/查看Apk签名信息","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/cha-kan-apk-qian-ming-xin-xi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/cha-kan-apk-qian-ming-xin-xi/","excerpt":"","text":"查看apk签名信息 直接用Android-SDK中的工具查看 java -jar .\\apksigner.jar verify --verbose --print-certs xxx.apk 其中 apksigner.jar 工具包位置在 Android-SDK 目录下面，Android-SDK\\build-tools\\xx.x.x\\lib 使用JDK中的工具查看 转自：https://blog.csdn.net/findsafety/article/details/25365997 假定安装了JDK，如果想查HelloWorld.apk所使用的签名的fingerprint，可以这样做： 查找apk里的rsa文件 （Windows） jar tf HelloWorld.apk | findstr RSA （Linux） jar tf HelloWorld.apk | grep RSA 输出结果： META-INF/CERT.RSA 从apk中解压rsa文件 jar xf HelloWorld.apk META-INF/CERT.RSA 获取签名的fingerprints keytool -printcert -file META-INF/CERT.RSA 输出结果 ... Certificate fingerprints: MD5: BC:6D:BD:6E:49:69:2A:57:A8:B8:28:89:04:3B:93:A8 SHA1: 0D:DF:76:F4:85:96:DF:17:C2:68:1D:3D:FF:9B:0F:D2:A1:CF:14:60 Signature algorithm name: SHA1withRSA Version: 3 ... 清理工作，删除rsa文件 （Windows） rmdir /S /Q META-INF （Linux） rm -rf META-INF 如果你想知道两个apk是不是用的同一个签名，那比一下它们签名的MD5码（或SHA1码）是不是一样就行了。","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"系统广播","slug":"docs/Android/其他/系统广播","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/xi-tong-guang-bo/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/xi-tong-guang-bo/","excerpt":"","text":"一些系统广播 intent.action.AIRPLANE_MODE; //关闭或打开飞行模式时的广播 Intent.ACTION_BATTERY_CHANGED; //充电状态，或者电池的电量发生变化 //电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册 Intent.ACTION_BATTERY_LOW; //表示电池电量低 Intent.ACTION_BATTERY_OKAY; //表示电池电量充足，即从电池电量低变化到饱满时会发出广播 Intent.ACTION_BOOT_COMPLETED; //在系统启动完成后，这个动作被广播一次（只有一次）。 Intent.ACTION_CAMERA_BUTTON; //按下照相时的拍照按键(硬件按键)时发出的广播 Intent.ACTION_CLOSE_SYSTEM_DIALOGS; //当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息 Intent.ACTION_CONFIGURATION_CHANGED; //设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java) Intent.ACTION_DATE_CHANGED; //设备日期发生改变时会发出此广播 Intent.ACTION_DEVICE_STORAGE_LOW; //设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用？ Intent.ACTION_DEVICE_STORAGE_OK; //设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用？ Intent.ACTION_DOCK_EVENT; // //发出此广播的地方frameworks\\base\\services\\java\\com\\android\\server\\DockObserver.java Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE; ////移动APP完成之后，发出的广播(移动是指:APP2SD) Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE; //正在移动APP时，发出的广播(移动是指:APP2SD) Intent.ACTION_GTALK_SERVICE_CONNECTED; //Gtalk已建立连接时发出的广播 Intent.ACTION_GTALK_SERVICE_DISCONNECTED; //Gtalk已断开连接时发出的广播 Intent.ACTION_HEADSET_PLUG; //在耳机口上插入耳机时发出的广播 Intent.ACTION_INPUT_METHOD_CHANGED; //改变输入法时发出的广播 Intent.ACTION_LOCALE_CHANGED; //设备当前区域设置已更改时发出的广播 Intent.ACTION_MANAGE_PACKAGE_STORAGE; // Intent.ACTION_MEDIA_BAD_REMOVAL; //未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 //广播：扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount) Intent.ACTION_MEDIA_BUTTON; //按下\"Media Button\" 按键时发出的广播,假如有\"Media Button\" 按键的话(硬件按键) Intent.ACTION_MEDIA_CHECKING; //插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播? Intent.ACTION_MEDIA_EJECT; //已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播? //广播：用户想要移除扩展介质（拔掉扩展卡）。 Intent.ACTION_MEDIA_MOUNTED; //插入SD卡并且已正确安装（识别）时发出的广播 //广播：扩展介质被插入，而且已经被挂载。 Intent.ACTION_MEDIA_NOFS; // Intent.ACTION_MEDIA_REMOVED; //外部储存设备已被移除，不管有没正确卸载,都会发出此广播？ // 广播：扩展介质被移除。 Intent.ACTION_MEDIA_SCANNER_FINISHED; //广播：已经扫描完介质的一个目录 Intent.ACTION_MEDIA_SCANNER_SCAN_FILE; // Intent.ACTION_MEDIA_SCANNER_STARTED; //广播：开始扫描介质的一个目录 Intent.ACTION_MEDIA_SHARED; // 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。 Intent.ACTION_MEDIA_UNMOUNTABLE; // Intent.ACTION_MEDIA_UNMOUNTED // 广播：扩展介质存在，但是还没有被挂载 (mount)。 Intent.ACTION_NEW_OUTGOING_CALL; Intent.ACTION_PACKAGE_ADDED; //成功的安装APK之后 //广播：设备上新安装了一个应用程序包。 //一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播） Intent.ACTION_PACKAGE_CHANGED; //一个已存在的应用程序包已经改变，包括包名 Intent.ACTION_PACKAGE_DATA_CLEARED; //清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?) //用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播） Intent.ACTION_PACKAGE_INSTALL; //触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？ // Intent.ACTION_PACKAGE_REMOVED; //成功的删除某个APK之后发出的广播 //一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播） Intent.ACTION_PACKAGE_REPLACED; //替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？） Intent.ACTION_PACKAGE_RESTARTED; //用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播） Intent.ACTION_POWER_CONNECTED; //插上外部电源时发出的广播 Intent.ACTION_POWER_DISCONNECTED; //已断开外部电源连接时发出的广播 Intent.ACTION_PROVIDER_CHANGED; // Intent.ACTION_REBOOT; //重启设备时的广播 Intent.ACTION_SCREEN_OFF; //屏幕被关闭之后的广播 Intent.ACTION_SCREEN_ON; //屏幕被打开之后的广播 Intent.ACTION_SHUTDOWN; //关闭系统时发出的广播 Intent.ACTION_TIMEZONE_CHANGED; //时区发生改变时发出的广播 Intent.ACTION_TIME_CHANGED; //时间被设置时发出的广播 Intent.ACTION_TIME_TICK; //广播：当前时间已经变化（正常的时间流逝）。 //当前时间改变，每分钟都发送，不能通过组件声明来接收，只有通过Context.registerReceiver()方法来注册 Intent.ACTION_UID_REMOVED; //一个用户ID已经从系统中移除发出的广播 // Intent.ACTION_UMS_CONNECTED; //设备已进入USB大容量储存状态时发出的广播？ Intent.ACTION_UMS_DISCONNECTED; //设备已从USB大容量储存状态转为正常状态时发出的广播？ Intent.ACTION_USER_PRESENT; // Intent.ACTION_WALLPAPER_CHANGED; //设备墙纸已改变时发出的广播","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"安卓杂记","slug":"docs/Android/其他/安卓杂记","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/an-zhuo-za-ji/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/an-zhuo-za-ji/","excerpt":"","text":"Volley（网络请求） 依赖 implementation'com.android.volley:volley:1.1.1' 请求 RequestQueue queue = Volley.newRequestQueue(this); String url = \"\"; JsonObjectRequest request = new JsonObjectRequest(GET, url, object, new Response.Listener&lt;JSONObject&gt;(), new Response.ErrorListener()); queue.add(request); 停止请求： 方法一： request.setTag(TAG); queue.add(request); //为请求添加一个标签TAG，在activityonStop里停止包含TAG 的请求 @Override protected void onStop () { super.onStop(); if (mRequestQueue != null) { mRequestQueue.cancelAll(TAG); } } 方法二： // 停止所有请求： requestQueue.cancelAll(this) 透明状态栏 依赖 implementation 'com.jaeger.statusbarutil:library:1.5.1' 使用 StatusBarUtil.setTransparent(this); //如果是白色背景加上下面这一句将状态栏改成黑色字体 //getWindow().getDecorView().setSystemUiVisibility(SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); 防止手机转屏页面重建数据丢失 &lt;activity android:name=\".xxxActivity\" &lt;!---在活动下面加上这句话就可以防止转屏丢失数据---&gt; android:configChanges=\"orientation|keyboard|keyboardHidden|screenSize\"&gt; &lt;/activity&gt; 使用DataBinding也可以保持数据 安卓P允许访问http页面 &lt;application android:usesCleartextTraffic=\"true\"&gt; &lt;/application&gt; ViewModel、DataBinding / ViewBinding 依赖 dataBinding { enabled true } viewBinding { enabled true } Activity使用方法： MyViewModel viewModel; ActivityViewModelBinding binding; binding = DataBindingUtil.setContentView(this, R.layout.activity_view_model); viewModel = ViewModelProviders.of(this).get(MyViewModel.class); binding.setData(viewModel); binding.setLifecycleOwner(this); XML绑定语法 @{data.xxx} @{()-&gt;data.xxx()} // 与视图Text控件绑定时一定注意LiveData类型，不是String要进行转型（这个错误编译不会报错，但是运行就会FC）： android:text=\"@{String.valueOf(data.number)}\" 阻止按钮自动大写 &lt;item name=\"textAllCaps\"&gt;false&lt;/item&gt; Room简单使用流程 依赖 def room_version = \"2.2.2\" implementation \"androidx.room:room-runtime:$room_version\" annotationProcessor \"androidx.room:room-compiler:$room_version\" testImplementation \"androidx.room:room-testing:$room_version\" //下面这三个一般用不到 //implementation \"androidx.room:room-ktx:$room_version\" //implementation \"androidx.room:room-rxjava2:$room_version\" //implementation \"androidx.room:room-guava:$room_version\" 使用 新建一个@Entity XXX类，定义表格格式 定义一个@Dao接口interface xxxDao，编写数据库操作语句 @Insert @Update @Delete @Query(“”) 定义一个抽象类xxxDataBase @DataBase(entities = {xxx.class},version = x,exportSchema = boolen) // 里面定义一个抽象方法 abstract xxxDao getxxxDao; 调用： xxxDataBase x = Room.databaseBuilder(this,xxxDataBase.class,\"name\") //.allowMainThreadQueries() //设置允许在主线程运行，一般不要这样写 .build(); xxxDao xx = x.getxxxDao; 防止键盘遮挡输入框 将布局放到 ScrollView 中，然后在 MainFest 里 Activity 里面加入： android:windowSoftInputMode=\"adjustResize\" RecyclerView简单调用流程 定义Adapter： //定义一个内部类ViewHolder //Adapter继承RecyclerView.Adapter&lt;xxxAdapter.ViewHolder&gt; public class xxxAdapter extends RecyclerView.Adapter&lt;xxxAdapter.ViewHolder&gt; { public xxxAdapter(List&lt;xxx&gt; lists){ } static class ViewHolder extends RecyclerView.ViewHolder { public ViewHolder(@NonNull View itemView) { super(itemView); //初始化item上的控件 } } //IDE会引导生成三个需要实现的方法 public ViewHolder onCreateViewHolder(){ View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_recycler,parent,false); ViewHolder holder = new ViewHolder(view); return holder; } public void onBindViewHolder(){ //绑定视图，为item上的控件赋值 } public int getItemCount(){ //返回item个数 } } 具体调用： List&lt;xxx&gt; lists; //封装数据 RecyclerView recylcler = ..; recycler.setLayoutManager(new LinearLayoutManager(this)); // 如果可以确定每个item的高度是固定的，设置下面这个选项可以提高性能 recycler.setHasFixedSize(true); //Adapter xxxAdapter adapter = new xxxAdapter(lists); recycler.setAdapter(adapter); 广播接收器 发送广播时： 高版本的android系统，对于广播的接收变得越来越严格，发送广播时要在 Intent 后面加上 .setComponent 参数 Intent intent =new Intent( \"com.xxx.name\" );//参数是广播接收器name //参数1是广播接收器所在的包名，参数2是广播接收器name intent.setComponent(new ComponentName(\"com.xxx\",\"com.xxx.name\")); sendBroadcast(intent ); Retrofit（网络请求） //创建一个接口，通过注解定义请求方式格式等 public interface RetrofitUtil { //第二段请求地址 //加上第一段请求地址意思就是请求 https://a.b.b/de @GET(\"de\") Call&lt;UpdateInfo&gt; getUpdateInfo(); } //使用 //构建一个Retrofit Retrofit retrofit = new Retrofit .Builder() //这里是使用Gson将请求结果封装成对象 .addConverterFactory(GsonConverterFactory.create()) //第一段请求地址 .baseUrl(\"https://a.b.b/\") .build(); RetrofitUtil retrofitUtil = retrofit.create(RetrofitUtil.class); Call&lt;UpdateInfo&gt; call = retrofitUtil.getUpdateInfo(); //异步请求 call.enqueue(new Callback&lt;UpdateInfo&gt;() {}); EventBus（活动间发送接收信息） 发送： EventBus.getDefault().postSticky(city_id); startActivity(new Intent(this.getActivity(), B.class)); 接收： //接收前先注册 EventBus.getDefault().register(this); //活动销毁时反注册 protected void onDestroy() { super.onDestroy(); EventBus.getDefault().unregister(this); } //通过注解使用 //(线程模式，是否Stiky粘性注册) @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void eventGetCityId(String city_id) { this.city_id = city_id; } 改变Menu三个小点颜色 item下面可以继续包含Menu &lt;item android:icon=\"@drawable/ic_more_white_24\" app:showAsAction=\"always\" android:title=\"About\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/m_item_about\" android:title=\"关于\"/&gt; &lt;/menu&gt; &lt;/item&gt; 锁屏显示页面 //onCreat() getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED //锁屏显示 | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD //解锁 | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON //保持屏幕不息屏 | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);//点亮屏幕 //startActivity val pm = getSystemService(Context.POWER_SERVICE) as PowerManager val mKeyguardManager = getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager val wakeLock = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP or PowerManager.SCREEN_DIM_WAKE_LOCK, \"wakeLock\") wakeLock.acquire() val mKeyguardLock = mKeyguardManager.newKeyguardLock(\"\") mKeyguardLock.disableKeyguard() val i = Intent(this,CameraActivity::class.java) i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) startActivity(i) 查看内存 /** * 打印当前手机内存信息应用的内存信息 */ @TargetApi(Build.VERSION_CODES.JELLY_BEAN) public static void printMemoryInfo() { final String TAG = \"MemoryUtils.printMemoryInfo()\"; //打印当前APP内存信息 //开启了 android:largeHeap=\"true\" 后,就是启用了流氓应用的内存限制 //打印当前应用内存信息 Runtime rt = Runtime.getRuntime(); Log.d(TAG, \"APP当前内存状态: 最大可申请内存:\" + rt.maxMemory() / 1024 / 1024 + \"MB 已申请内存:\" + rt.totalMemory() / 1024 / 1024 + \"MB 空闲内存:\" + rt.freeMemory() / 1024 / 1024 + \"MB\"); } /** * 获得app可用内存的字节数 这个类不需要try,catch理论上不会报错 */ @TargetApi(Build.VERSION_CODES.HONEYCOMB) public static long getAppSurplusMe() { final String TAG = \"MemoryUtils.getAppSurplusMe()\"; Runtime rt = Runtime.getRuntime(); //一下参数单位为字节数 long totalMemory = rt.totalMemory();//这个是已经申请的内存,等于已经使用的内存加上空闲内存 long maxMemory = rt.maxMemory();//最大内存限制 long freeMemory = rt.freeMemory(); //假如最大内存限制是64M,已经申请了34M,空闲4M,那么其实当前使用的是:(34-4)M,而实际当前有效可使用的内存是:64-(34-4)=34; //64-(34-4)=34 请允许我引用高数老师的那句话:\"同理可得\" 64-34+4 //so long surplusMemory = maxMemory - totalMemory + freeMemory; Log.d(TAG, \"系统当前内存状态: 最大可申请内存:\" + rt.maxMemory() / 1024 / 1024 + \"MB 已申请内存:\" + rt.totalMemory() / 1024 / 1024 + \"MB 空闲内存:\" + rt.freeMemory() / 1024 / 1024 + \"MB\"); return surplusMemory; } /** * 获得手机可用内存的字节数 这个类不需要try,catch,理论上不会报错 * &lt;p&gt; * 这个方法要慎用 容易导致崩溃 特别在引导页的时候 低内存手机容易发生崩溃 * * @param context * @return */ public static long getPhoneSurplusMe(Context context) { ActivityManager am = (ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo(); am.getMemoryInfo(mi); return mi.availMem; } 传感器 #define SENSOR_TYPE_ACCELEROMETER 1 //加速度 #define SENSOR_TYPE_MAGNETIC_FIELD 2 //磁力 #define SENSOR_TYPE_ORIENTATION 3 //方向 #define SENSOR_TYPE_GYROSCOPE 4 //陀螺仪 #define SENSOR_TYPE_LIGHT 5 //光线感应 #define SENSOR_TYPE_PRESSURE 6 //压力 #define SENSOR_TYPE_TEMPERATURE 7 //温度 #define SENSOR_TYPE_PROXIMITY 8 //接近 #define SENSOR_TYPE_GRAVITY 9 //重力 #define SENSOR_TYPE_LINEAR_ACCELERATION 10//线性加速度 #define SENSOR_TYPE_ROTATION_VECTOR 11//旋转矢量 加速度传感器加速度传感器又叫 G-sensor ，返回x、y、z三轴的加速度数值。 该数值包含地心引力的影响，单位是m/s^2。将手机平放在桌面上，x轴默认为0，y轴默认0，z轴默认9.81。将手机朝下放在桌面上，z轴为-9.81。将手机向左倾斜，x轴为正值。将手机向右倾斜，x轴为负值。将手机向上倾斜，y轴为负值。将手机向下倾斜，y轴为正值。加速度传感器可能是最为成熟的一种mems产品，市场上的加速度传感器种类很多。手机中常用的加速度传感器有BOSCH（博世）的BMA系列，AMK的897X系列，ST的LIS3X系列等。这些传感器一般提供±2G至±16G的加速度测量范围，采用I2C或SPI接口和MCU相连，数据精度小于16bit。 磁力传感器磁力传感器简称为M-sensor，返回x、y、z三轴的环境磁场数据。 该数值的单位是微特斯拉（micro-Tesla），用uT表示。单位也可以是高斯（Gauss），1Tesla=10000Gauss。硬件上一般没有独立的磁力传感器，磁力数据由电子罗盘传感器提供（E-compass）。电子罗盘传感器同时提供下文的方向传感器数据。 方向传感器 方向传感器简称为O-sensor，返回三轴的角度数据，方向数据的单位是角度。 为了得到精确的角度数据，E-compass需要获取G-sensor的数据，经过计算生产O-sensor数据，否则只能获取水平方向的角度。方向传感器提供三个数据，分别为azimuth、pitch和roll。azimuth：方位，返回水平时磁北极和Y轴的夹角，范围为0°至360°。0°=北，90°=东，180°=南，270°=西。pitch：x轴和水平面的夹角，范围为-180°至180°。当z轴向y轴转动时，角度为正值。roll：y轴和水平面的夹角，由于历史原因，范围为-90°至90°。当x轴向z轴移动时，角度为正值。电子罗盘在获取正确的数据前需要进行校准，通常可用8字校准法。8字校准法要求用户使用需要校准的设备在空中做8字晃动，原则上尽量多的让设备法线方向指向空间的所有8个象限。手机中使用的电子罗盘芯片有AKM公司的897X系列，ST公司的LSM系列以及雅马哈公司等等。由于需要读取G-sensor数据并计算出M-sensor和O-sensor数据，因此厂商一般会提供一个后台daemon来完成工作，电子罗盘算法一般是公司私有产权。 陀螺仪传感器 陀螺仪传感器叫做Gyro-sensor，返回x、y、z三轴的角加速度数据。角加速度的单位是radians/second。根据Nexus S手机实测：水平逆时针旋转，Z轴为正。水平逆时针旋转，z轴为负。向左旋转，y轴为负。向右旋转，y轴为正。向上旋转，x轴为负。向下旋转，x轴为正。ST的L3G系列的陀螺仪传感器比较流行，iphone4和google的nexus s中使用该种传感器。 光线感应传感器 光线感应传感器检测实时的光线强度，光强单位是lux，其物理意义是照射到单位面积上的光通量。光线感应传感器主要用于Android系统的LCD自动亮度功能。可以根据采样到的光强数值实时调整LCD的亮度。 压力传感器 压力传感器返回当前的压强，单位是百帕斯卡hectopascal（hPa）。 温度传感器 温度传感器返回当前的温度。 接近传感器 接近传感器检测物体与手机的距离，单位是厘米。一些接近传感器只能返回远和近两个状态，因此，接近传感器将最大距离返回远状态，小于最大距离返回近状态。接近传感器可用于接听电话时自动关闭LCD屏幕以节省电量。一些芯片集成了接近传感器和光线传感器两者功能。下面三个传感器是Android2新提出的传感器类型，目前还不太清楚有哪些应用程序使用。 重力传感器 重力传感器简称GV-sensor，输出重力数据。在地球上，重力数值为9.8，单位是m/s^2。坐标系统与加速度传感器相同。当设备复位时，重力传感器的输出与加速度传感器相同。 线性加速度传感器 线性加速度传感器简称LA-sensor。线性加速度传感器是加速度传感器减去重力影响获取的数据。单位是m/s^2，坐标系统与加速度传感器相同。加速度传感器、重力传感器和线性加速度传感器的计算公式如下：加速度 = 重力 + 线性加速度 旋转矢量传感器 旋转矢量传感器简称RV-sensor。旋转矢量代表设备的方向，是一个将坐标轴和角度混合计算得到的数据。RV-sensor输出三个数据：xsin(theta/2)ysin(theta/2)z*sin(theta/2)sin(theta/2)是RV的数量级。RV的方向与轴旋转的方向相同。RV的三个数值，与cos(theta/2)组成一个四元组。RV的数据没有单位，使用的坐标系与加速度相同。举例： sensors_event_t.data[0] = x*sin(theta/2) sensors_event_t.data[1] = y*sin(theta/2) sensors_event_t.data[2] = z*sin(theta/2) sensors_event_t.data[3] = cos(theta/2) GV、LA和RV的数值没有物理传感器可以直接给出，需要G-sensor、O-sensor和Gyro-sensor经过算法计算后得出。算法一般是传感器公司的私有产权。 参考文献：android source code hardware\\libhardware\\include\\hardwaresensor.hhttp://www.dzsc.com/data/html/2010-11-29/87454.html 状态栏 // 隐藏状态栏 getWindow().addFlags(WindowManager. LayoutParams. FLAG_FULLSCREEN); // 显示状态栏 getWindow().clearFlags(WindowManager. LayoutParams.FLAG_FULLSCREEN); 控制状态栏和导航栏显示, setSystemUiVisibility View. SYSTEM_UI_FLAG_LAYOUT_STABLE //全屏显示时保证尺寸不变。 View. SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN //Activity全屏显示，状态栏显示在Activity页面上面。 View. SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION //效果同View. SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN View. SYSTEM_UI_FLAG_HIDE_NAVIGATION //隐藏导航栏 View. SYSTEM_UI_FLAG_FULLSCREEN //Activity全屏显示，且状态栏被隐藏覆盖掉。 View. SYSTEM_UI_FLAG_VISIBLE //Activity非全屏显示，显示状态栏和导航栏。 View. INVISIBLE //Activity伸展全屏显示，隐藏状态栏。 View. SYSTEM_UI_LAYOUT_FLAGS //效果同View. SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN View. SYSTEM_UI_FLAG_IMMERSIVE_STICKY //必须配合View.SYSTEM_UI_FLAG_FULLSCREEN和View.SYSTEM_UI_FLAG_HIDE_NAVIGATION组合使用，达到的效果是拉出状态栏和导航栏后显示一会儿消失。 // 全屏展示 if (Build. VERSION. SDK_INT &gt;= Build. VERSION_CODES. JELLY_BEAN) { if (Build. VERSION. SDK_INT &gt;= Build. VERSION_CODES. LOLLIPOP) { // 全屏显示，隐藏状态栏和导航栏，拉出状态栏和导航栏显示一会儿后消失。 activity.getWindow().getDecorView().setSystemUiVisibility( View. SYSTEM_UI_FLAG_LAYOUT_STABLE | View. SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View. SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View. SYSTEM_UI_FLAG_HIDE_NAVIGATION | View. SYSTEM_UI_FLAG_FULLSCREEN | View. SYSTEM_UI_FLAG_IMMERSIVE_STICKY); } else { // 全屏显示，隐藏状态栏 activity.getWindow().getDecorView().setSystemUiVisibility(View. SYSTEM_UI_FLAG_FULLSCREEN); } } // 非全屏显示，显示状态栏和导航栏 activity.getWindow().getDecorView().setSystemUiVisibility(View. SYSTEM_UI_FLAG_VISIBLE);","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"系统提供的Activity","slug":"docs/Android/其他/系统提供的Activity","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/xi-tong-ti-gong-de-activity/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/xi-tong-ti-gong-de-activity/","excerpt":"","text":"系统提供的Activity //1.拨打电话 // 给移动客服10086拨打电话 Uri uri = Uri.parse(\"tel:10086\"); Intent intent = new Intent(Intent.ACTION_DIAL, uri); startActivity(intent); //2.发送短信 // 给10086发送内容为“Hello”的短信 Uri uri = Uri.parse(\"smsto:10086\"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); intent.putExtra(\"sms_body\", \"Hello\"); startActivity(intent); //3.发送彩信（相当于发送带附件的短信） Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(\"sms_body\", \"Hello\"); Uri uri = Uri.parse(\"content://media/external/images/media/23\"); intent.putExtra(Intent.EXTRA_STREAM, uri); intent.setType(\"image/png\"); startActivity(intent); //4.打开浏览器: // 打开Google主页 Uri uri = Uri.parse(\"http://www.baidu.com\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //5.发送电子邮件:(阉割了Google服务的没戏!!!!) // 给someone@domain.com发邮件 Uri uri = Uri.parse(\"mailto:someone@domain.com\"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); startActivity(intent); // 给someone@domain.com发邮件发送内容为“Hello”的邮件 Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, \"someone@domain.com\"); intent.putExtra(Intent.EXTRA_SUBJECT, \"Subject\"); intent.putExtra(Intent.EXTRA_TEXT, \"Hello\"); intent.setType(\"text/plain\"); startActivity(intent); // 给多人发邮件 Intent intent=new Intent(Intent.ACTION_SEND); String[] tos = {\"1@abc.com\", \"2@abc.com\"}; // 收件人 String[] ccs = {\"3@abc.com\", \"4@abc.com\"}; // 抄送 String[] bccs = {\"5@abc.com\", \"6@abc.com\"}; // 密送 intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_BCC, bccs); intent.putExtra(Intent.EXTRA_SUBJECT, \"Subject\"); intent.putExtra(Intent.EXTRA_TEXT, \"Hello\"); intent.setType(\"message/rfc822\"); startActivity(intent); //6.显示地图: // 打开Google地图中国北京位置（北纬39.9，东经116.3） Uri uri = Uri.parse(\"geo:39.9,116.3\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //7.路径规划 // 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4） Uri uri = Uri.parse(\"http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //8.多媒体播放: Intent intent = new Intent(Intent.ACTION_VIEW); Uri uri = Uri.parse(\"file:///sdcard/foo.mp3\"); intent.setDataAndType(uri, \"audio/mp3\"); startActivity(intent); //获取SD卡下所有音频文件,然后播放第一首=-= Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, \"1\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //9.打开摄像头拍照: // 打开拍照程序 Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, 0); // 取出照片数据 Bundle extras = intent.getExtras(); Bitmap bitmap = (Bitmap) extras.get(\"data\"); //另一种: //调用系统相机应用程序，并存储拍下来的照片 Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); time = Calendar.getInstance().getTimeInMillis(); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment .getExternalStorageDirectory().getAbsolutePath()+\"/tucue\", time + \".jpg\"))); startActivityForResult(intent, ACTIVITY_GET_CAMERA_IMAGE); //10.获取并剪切图片 // 获取并剪切图片 Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\"); intent.putExtra(\"crop\", \"true\"); // 开启剪切 intent.putExtra(\"aspectX\", 1); // 剪切的宽高比为1：2 intent.putExtra(\"aspectY\", 2); intent.putExtra(\"outputX\", 20); // 保存图片的宽和高 intent.putExtra(\"outputY\", 40); intent.putExtra(\"output\", Uri.fromFile(new File(\"/mnt/sdcard/temp\"))); // 保存路径 intent.putExtra(\"outputFormat\", \"JPEG\");// 返回格式 startActivityForResult(intent, 0); // 剪切特定图片 Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setClassName(\"com.android.camera\", \"com.android.camera.CropImage\"); intent.setData(Uri.fromFile(new File(\"/mnt/sdcard/temp\"))); intent.putExtra(\"outputX\", 1); // 剪切的宽高比为1：2 intent.putExtra(\"outputY\", 2); intent.putExtra(\"aspectX\", 20); // 保存图片的宽和高 intent.putExtra(\"aspectY\", 40); intent.putExtra(\"scale\", true); intent.putExtra(\"noFaceDetection\", true); intent.putExtra(\"output\", Uri.parse(\"file:///mnt/sdcard/temp\")); startActivityForResult(intent, 0); //11.打开Google Market // 打开Google Market直接进入该程序的详细页面 Uri uri = Uri.parse(\"market://details?id=\" + \"com.demo.app\"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //12.进入手机设置界面: // 进入无线网络设置界面（其它可以举一反三） Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS); startActivityForResult(intent, 0); //13.安装apk: Uri installUri = Uri.fromParts(\"package\", \"xxx\", null); returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri); //14.卸载apk: Uri uri = Uri.fromParts(\"package\", strPackageName, null); Intent it = new Intent(Intent.ACTION_DELETE, uri); startActivity(it); //15.发送附件: Intent it = new Intent(Intent.ACTION_SEND); it.putExtra(Intent.EXTRA_SUBJECT, \"The email subject text\"); it.putExtra(Intent.EXTRA_STREAM, \"file:///sdcard/eoe.mp3\"); sendIntent.setType(\"audio/mp3\"); startActivity(Intent.createChooser(it, \"Choose Email Client\")); //16.进入联系人页面: Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(People.CONTENT_URI); startActivity(intent); //17.查看指定联系人: Uri personUri = ContentUris.withAppendedId(People.CONTENT_URI, info.id);//info.id联系人ID Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(personUri); startActivity(intent);","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"请求忽略电池优化","slug":"docs/Android/其他/请求忽略电池优化","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/qing-qiu-hu-lue-dian-chi-you-hua/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/qing-qiu-hu-lue-dian-chi-you-hua/","excerpt":"","text":"&lt;uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\"/&gt; /** * 忽略电池优化 */ private void ignoreBatteryOptimization(Activity activity) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE); boolean hasIgnored = powerManager.isIgnoringBatteryOptimizations(activity.getPackageName()); // 判断当前APP是否有加入电池优化的白名单，如果没有，弹出加入电池优化的白名单的设置对话框。 if (!hasIgnored) { Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\" + activity.getPackageName())); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } else { Log.d(\"ignoreBattery\", \"hasIgnored\"); } } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"系统信息获取","slug":"docs/Android/其他/系统信息获取","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/xi-tong-xin-xi-huo-qu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/xi-tong-xin-xi-huo-qu/","excerpt":"","text":"字段名 描述 android.os.Build.VERSION.RELEASE 获取系统版本字符串。如 4.1.2 或 7.1.2 等 android.os.Build.VERSION.SDK_INT 系统的 API 级别 数字表示 android.os.Build.BOARD 获取设备基板名称 android.os.Build.BOOTLOADER 获取设备引导程序版本号 android.os.Build.BRAND 获取设备品牌 android.os.Build.CPU_ABI 获取设备指令集名称（CPU 的类型） android.os.Build.CPU_ABI2 获取第二个指令集名称 android.os.Build.DEVICE 获取设备驱动名称 android.os.Build.DISPLAY 获取设备显示的版本包（在系统设置中显示为版本号）和 ID 一样 android.os.Build.FINGERPRINT 设备的唯一标识。由设备的多个信息拼接合成。 android.os.Build.HARDWARE 设备硬件名称,一般和基板名称一样（BOARD） android.os.Build.HOST 设备主机地址 android.os.Build.ID 设备版本号。 android.os.Build.MODEL 获取手机的型号 设备名称。如：SM-N9100（三星 Note4） android.os.Build.MANUFACTURER 获取设备制造商。如：samsung android.os.Build.PRODUCT 整个产品的名称 android.os.Build.RADIO 无线电固件版本号，通常是不可用的 显示 unknownandroid.os.Build.TAGS 设备标签。如 release-keys 或测试的 test-keys android.os.Build.TIME 时间 android.os.Build.TYPE 设备版本类型 主要为”user” 或”eng”. android.os.Build.USER 设备用户名 基本上都为 android-build android.os.Build.VERSION.CODENAME 设备当前的系统开发代号，一般使用 REL 代替 android.os.Build.VERSION.INCREMENTAL 系统源代码控制值，一个数字或者 git hash 值","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"软键盘相关操作","slug":"docs/Android/其他/软键盘相关操作","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/qi-ta/ruan-jian-pan-xiang-guan-cao-zuo/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/qi-ta/ruan-jian-pan-xiang-guan-cao-zuo/","excerpt":"","text":"禁止EditorText自动弹出软键盘 在控件父布局加上： &lt;androidx.constraintlayout.widget.ConstraintLayout ... android:focusable=\"true\" android:focusableInTouchMode=\"true\" ... &gt; 弹出软键盘 InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); if (imm != null) { imm.showSoftInput(view, InputMethodManager.SHOW_FORCED); } //推荐使用这种方式，针对不同Api有不同的实现 WindowInsetsControllerCompat( requireActivity().window, view ).show(WindowInsetsCompat.Type.ime()) 隐藏软键盘 InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); if (imm != null &amp;&amp; view != null) { imm.hideSoftInputFromWindow(view.getWindowToken(), 0); } //推荐使用这种方式，针对不同Api有不同的实现 WindowInsetsControllerCompat( requireActivity().window, view ).hide(WindowInsetsCompat.Type.ime()) 这些方法在大多数情况下都能凑效，但是有些情况可能怎么都无法通过代码隐藏软键盘，可以实现一个模拟返回键事件的功能，在子线程执行（目前未遇到这种情况，该方法未实际测试）： Instrumentation instrumentation = new Instrumentation(); instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK); 注意 控件设置enable为false时，不需要手动清除焦点（View.clearFocus()）或手动执行隐藏键盘的方法，因为在 setEnable() 方法里面已经执行隐藏键盘的相关逻辑了，手动调用 clearFocus 反而可能会引起异常。 //TextView.java ... @android.view.RemotableViewMethod @Override public void setEnabled(boolean enabled) { if (enabled == isEnabled()) { return; } if (!enabled) { // Hide the soft input if the currently active TextView is InputMethodManager imm = getInputMethodManager(); if (imm != null &amp;&amp; imm.isActive(this)) { imm.hideSoftInputFromWindow(getWindowToken(), 0); } } super.setEnabled(enabled); if (enabled) { // Make sure IME is updated with current editor info. InputMethodManager imm = getInputMethodManager(); if (imm != null) imm.restartInput(this); } // Will change text color if (mEditor != null) { mEditor.invalidateTextDisplayList(); mEditor.prepareCursorControllers(); // start or stop the cursor blinking as appropriate mEditor.makeBlink(); } } ...","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Android扩展知识点","slug":"docs/Android/知识汇总/Android扩展知识点","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/android-kuo-zhan-zhi-shi-dian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/android-kuo-zhan-zhi-shi-dian/","excerpt":"","text":"ART ART 功能 预先 (AOT) 编译 垃圾回收优化 开发和调试方面的优化 ART GC Hook 基本流程 使用示例 Proguard 规则 公共模板 常用的自定义混淆规则 aar中增加独立的混淆配置 检查混淆和追踪异常 架构 MVC MVP MVVM Jetpack 架构 使用示例 NDK 开发 JNI 基础 数据类型 String 字符串函数操作 常用 JNI 访问 Java 对象方法 NDK 开发 基础开发流程 System.loadLibrary() CMake 构建 NDK 项目 常用的 Android NDK 原生 API 类加载器 双亲委托模式 DexPathList ART ART 代表 Android Runtime，其处理应用程序执行的方式完全不同于 Dalvik，Dalvik 是依靠一个 Just-In-Time (JIT) 编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART 则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫 Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。 ART 功能 预先 (AOT) 编译 ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。该实用工具接受 DEX 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。 垃圾回收优化 垃圾回收 (GC) 可能有损于应用性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式对垃圾回收做了优化： 只有一次（而非两次）GC 暂停 在 GC 保持暂停状态期间并行处理 在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短 优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 GC_FOR_ALLOC 事件在典型用例中极为罕见 压缩 GC 以减少后台内存使用和碎片 开发和调试方面的优化 支持采样分析器 一直以来，开发者都使用 Traceview 工具（用于跟踪应用执行情况）作为分析器。虽然 Traceview 可提供有用的信息，但每次方法调用产生的开销会导致 Dalvik 分析结果出现偏差，而且使用该工具明显会影响运行时性能 ART 添加了对没有这些限制的专用采样分析器的支持，因而可更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。 支持更多调试功能 ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程；询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考；过滤特定实例的事件（如断点）等。 优化了异常和崩溃报告中的诊断详细信息 当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 java.lang.ClassCastException、java.lang.ClassNotFoundException 和 java.lang.NullPointerException 的更多异常详细信息（较高版本的 Dalvik 会提供 java.lang.ArrayIndexOutOfBoundsException 和 java.lang.ArrayStoreException 的更多异常详细信息，这些信息现在包括数组大小和越界偏移量；ART 也提供这类信息）。 ART GC ART 有多个不同的 GC 方案，这些方案包括运行不同垃圾回收器。默认方案是 CMS（并发标记清除）方案，主要使用粘性 CMS 和部分 CMS。粘性 CMS 是 ART 的不移动分代垃圾回收器。它仅扫描堆中自上次 GC 后修改的部分，并且只能回收自上次 GC 后分配的对象。除 CMS 方案外，当应用将进程状态更改为察觉不到卡顿的进程状态（例如，后台或缓存）时，ART 将执行堆压缩。 除了新的垃圾回收器之外，ART 还引入了一种基于位图的新内存分配程序，称为 RosAlloc（插槽运行分配器）。此新分配器具有分片锁，当分配规模较小时可添加线程的本地缓冲区，因而性能优于 DlMalloc。 与 Dalvik 相比，ART CMS 垃圾回收计划在很多方面都有一定的改善： 与 Dalvik 相比，暂停次数从 2 次减少到 1 次。Dalvik 的第一次暂停主要是为了进行根标记，即在 ART 中进行并发标记，让线程标记自己的根，然后马上恢复运行。 与 Dalvik 类似，ART GC 在清除过程开始之前也会暂停 1 次。两者在这方面的主要差异在于：在此暂停期间，某些 Dalvik 环节在 ART 中并发进行。这些环节包括 java.lang.ref.Reference 处理、系统弱清除（例如，jni 弱全局等）、重新标记非线程根和卡片预清理。在 ART 暂停期间仍进行的阶段包括扫描脏卡片以及重新标记线程根，这些操作有助于缩短暂停时间。 相对于 Dalvik，ART GC 改进的最后一个方面是粘性 CMS 回收器增加了 GC 吞吐量。不同于普通的分代 GC，粘性 CMS 不移动。系统会将年轻对象保存在一个分配堆栈（基本上是 java.lang.Object 数组）中，而非为其设置一个专属区域。这样可以避免移动所需的对象以维持低暂停次数，但缺点是容易在堆栈中加入大量复杂对象图像而使堆栈变长。 ART GC 与 Dalvik 的另一个主要区别在于 ART GC 引入了移动垃圾回收器。使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。 半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc/DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。 同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。 Hook 基本流程 1、根据需求确定 要 hook 的对象2、寻找要hook的对象的持有者，拿到要 hook 的对象3、定义“要 hook 的对象”的代理类，并且创建该类的对象4、使用上一步创建出来的对象，替换掉要 hook 的对象 使用示例 /** * hook的核心代码 * 这个方法的唯一目的：用自己的点击事件，替换掉 View 原来的点击事件 * * @param view hook的范围仅限于这个view */ @SuppressLint({\"DiscouragedPrivateApi\", \"PrivateApi\"}) public static void hook(Context context, final View view) {// try { // 反射执行View类的getListenerInfo()方法，拿到v的mListenerInfo对象，这个对象就是点击事件的持有者 Method method = View.class.getDeclaredMethod(\"getListenerInfo\"); method.setAccessible(true);//由于getListenerInfo()方法并不是public的，所以要加这个代码来保证访问权限 Object mListenerInfo = method.invoke(view);//这里拿到的就是mListenerInfo对象，也就是点击事件的持有者 // 要从这里面拿到当前的点击事件对象 Class&lt;?&gt; listenerInfoClz = Class.forName(\"android.view.View$ListenerInfo\");// 这是内部类的表示方法 Field field = listenerInfoClz.getDeclaredField(\"mOnClickListener\"); final View.OnClickListener onClickListenerInstance = (View.OnClickListener) field.get(mListenerInfo);//取得真实的mOnClickListener对象 // 2. 创建我们自己的点击事件代理类 // 方式1：自己创建代理类 // ProxyOnClickListener proxyOnClickListener = new ProxyOnClickListener(onClickListenerInstance); // 方式2：由于View.OnClickListener是一个接口，所以可以直接用动态代理模式 // Proxy.newProxyInstance的3个参数依次分别是： // 本地的类加载器; // 代理类的对象所继承的接口（用Class数组表示，支持多个接口） // 代理类的实际逻辑，封装在new出来的InvocationHandler内 Object proxyOnClickListener = Proxy.newProxyInstance(context.getClass().getClassLoader(), new Class[]{View.OnClickListener.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Log.d(\"HookSetOnClickListener\", \"点击事件被hook到了\");//加入自己的逻辑 return method.invoke(onClickListenerInstance, args);//执行被代理的对象的逻辑 } }); // 3. 用我们自己的点击事件代理类，设置到\"持有者\"中 field.set(mListenerInfo, proxyOnClickListener); } catch (Exception e) { e.printStackTrace(); } } // 自定义代理类 static class ProxyOnClickListener implements View.OnClickListener { View.OnClickListener oriLis; public ProxyOnClickListener(View.OnClickListener oriLis) { this.oriLis = oriLis; } @Override public void onClick(View v) { Log.d(\"HookSetOnClickListener\", \"点击事件被hook到了\"); if (oriLis != null) { oriLis.onClick(v); } } } Proguard Proguard 具有以下三个功能： 压缩（Shrink）: 检测和删除没有使用的类，字段，方法和特性 优化（Optimize） : 分析和优化Java字节码 混淆（Obfuscate）: 使用简短的无意义的名称，对类，字段和方法进行重命名 规则 关键字 关键字 描述 keep 保留类和类中的成员，防止被混淆或移除 keepnames 保留类和类中的成员，防止被混淆，成员没有被引用会被移除 keepclassmembers 只保留类中的成员，防止被混淆或移除 keepclassmembernames 只保留类中的成员，防止被混淆，成员没有引用会被移除 keepclasseswithmembers 保留类和类中的成员，防止被混淆或移除，保留指明的成员 keepclasseswithmembernames 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除 通配符 通配符 描述 &lt;field&gt; 匹配类中的所有字段 &lt;method&gt; 匹配类中所有的方法 &lt;init&gt; 匹配类中所有的构造函数 * 匹配任意长度字符，不包含包名分隔符(.) ** 匹配任意长度字符，包含包名分隔符(.) *** 匹配任意参数类型 指定混淆时可使用字典-applymapping filename 指定重用一个已经写好了的map文件作为新旧元素名的映射。 -obfuscationdictionary filename 指定一个文本文件用来生成混淆后的名字。 -classobfuscationdictionary filename 指定一个混淆类名的字典 -packageobfuscationdictionary filename 指定一个混淆包名的字典 -overloadaggressively 混淆的时候大量使用重载，多个方法名使用同一个混淆名（慎用） 公共模板 ############################################# # # 对于一些基本指令的添加 # ############################################# # 代码混淆压缩比，在 0~7 之间，默认为 5，一般不做修改 -optimizationpasses 5 # 混合时不使用大小写混合，混合后的类名为小写 -dontusemixedcaseclassnames # 指定不去忽略非公共库的类 -dontskipnonpubliclibraryclasses # 这句话能够使我们的项目混淆后产生映射文件 # 包含有类名-&gt;混淆后类名的映射关系 -verbose # 指定不去忽略非公共库的类成员 -dontskipnonpubliclibraryclassmembers # 不做预校验，preverify 是 proguard 的四个步骤之一，Android 不需要 preverify，去掉这一步能够加快混淆速度。 -dontpreverify # 保留 Annotation 不混淆 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型 -keepattributes Signature # 抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable # 指定混淆是采用的算法，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不做更改 -optimizations !code/simplification/cast,!field/*,!class/merging/* ############################################# # # Android开发中一些需要保留的公共部分 # ############################################# # 保留我们使用的四大组件，自定义的 Application 等等这些类不被混淆 # 因为这些子类都有可能被外部调用 -keep public class * extends android.app.Activity -keep public class * extends android.app.Appliction -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService # 保留 support 下的所有类及其内部类 -keep class android.support.** { *; } # 保留继承的 -keep public class * extends android.support.v4.** -keep public class * extends android.support.v7.** -keep public class * extends android.support.annotation.** # 保留 R 下面的资源 -keep class **.R$* { *; } # 保留本地 native 方法不被混淆 -keepclasseswithmembernames class * { native &lt;methods&gt;; } # 保留在 Activity 中的方法参数是view的方法， # 这样以来我们在 layout 中写的 onClick 就不会被影响 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } # 保留枚举类不被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 保留我们自定义控件（继承自 View）不被混淆 -keep public class * extends android.view.View { *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } # 保留 Parcelable 序列化类不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } # 保留 Serializable 序列化的类不被混淆 -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对于带有回调函数的 onXXEvent、**On*Listener 的，不能被混淆 -keepclassmembers class * { void *(**On*Event); void *(**On*Listener); } # webView 处理，项目中没有使用到 webView 忽略即可 -keepclassmembers class fqcn.of.javascript.interface.for.webview { public *; } -keepclassmembers class * extends android.webkit.webViewClient { public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String); } -keepclassmembers class * extends android.webkit.webViewClient { public void *(android.webkit.webView, java.lang.String); } # js -keepattributes JavascriptInterface -keep class android.webkit.JavascriptInterface { *; } -keepclassmembers class * { @android.webkit.JavascriptInterface &lt;methods&gt;; } # @Keep -keep,allowobfuscation @interface android.support.annotation.Keep -keep @android.support.annotation.Keep class * -keepclassmembers class * { @android.support.annotation.Keep *; } 常用的自定义混淆规则 # 通配符*，匹配任意长度字符，但不含包名分隔符(.) # 通配符**，匹配任意长度字符，并且包含包名分隔符(.) # 不混淆某个类 -keep public class com.jasonwu.demo.Test { *; } # 不混淆某个包所有的类 -keep class com.jasonwu.demo.test.** { *; } # 不混淆某个类的子类 -keep public class * com.jasonwu.demo.Test { *; } # 不混淆所有类名中包含了 ``model`` 的类及其成员 -keep public class **.*model*.** {*;} # 不混淆某个接口的实现 -keep class * implements com.jasonwu.demo.TestInterface { *; } # 不混淆某个类的构造方法 -keepclassmembers class com.jasonwu.demo.Test { public &lt;init&gt;(); } # 不混淆某个类的特定的方法 -keepclassmembers class com.jasonwu.demo.Test { public void test(java.lang.String); } aar中增加独立的混淆配置 build.gralde android { ··· defaultConfig { ··· consumerProguardFile 'proguard-rules.pro' } ··· } 检查混淆和追踪异常 开启 Proguard 功能，则每次构建时 ProGuard 都会输出下列文件： dump.txt说明 APK 中所有类文件的内部结构。 mapping.txt提供原始与混淆过的类、方法和字段名称之间的转换。 seeds.txt列出未进行混淆的类和成员。 usage.txt列出从 APK 移除的代码。 这些文件保存在 /build/outputs/mapping/release/ 中。我们可以查看 seeds.txt 里面是否是我们需要保留的，以及 usage.txt 里查看是否有误删除的代码。 mapping.txt 文件很重要，由于我们的部分代码是经过重命名的，如果该部分出现 bug，对应的异常堆栈信息里的类或成员也是经过重命名的，难以定位问题。我们可以用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 /tools/proguard/ 目录中。该脚本利用 mapping.txt 文件和你的异常堆栈文件生成没有经过混淆的异常堆栈文件,这样就可以看清是哪里出问题了。使用 retrace 工具的语法如下： retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;] 架构 MVC 在 Android 中，三者的关系如下： 由于在 Android 中 xml 布局的功能性太弱，所以 Activity 承担了绝大部分的工作，所以在 Android 中 mvc 更像： 总结： 具有一定的分层，model 解耦，controller 和 view 并没有解耦 controller 和 view 在 Android 中无法做到彻底分离，Controller 变得臃肿不堪 易于理解、开发速度快、可维护性高 MVP 通过引入接口 BaseView，让相应的视图组件如 Activity，Fragment去实现 BaseView，把业务逻辑放在 presenter 层中，弱化 Model 只有跟 view 相关的操作都由 View 层去完成。 总结： 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题 但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常多，会有非常多的 case，这样就会造成 View 的接口会很庞大 更容易单元测试 MVVM 在 MVP 中 View 和 Presenter 要相互持有，方便调用对方，而在 MVP 中 View 和 ViewModel 通过 Binding 进行关联，他们之前的关联处理通过 DataBinding 完成。 总结： 很好的解决了 MVC 和 MVP 的问题 视图状态较多，ViewModel 的构建和维护的成本都会比较高 但是由于数据和视图的双向绑定，导致出现问题时不太好定位来源 Jetpack 架构 使用示例 build.gradle android { ··· dataBinding { enabled = true } } dependencies { ··· implementation \"androidx.fragment:fragment-ktx:$rootProject.fragmentVersion\" implementation \"androidx.lifecycle:lifecycle-extensions:$rootProject.lifecycleVersion\" implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$rootProject.lifecycleVersion\" implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$rootProject.lifecycleVersion\" } fragment_plant_detail.xml &lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"viewModel\" type=\"com.google.samples.apps.sunflower.viewmodels.PlantDetailViewModel\" /&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView ··· android:text=\"@{viewModel.plant.name}\"/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; PlantDetailFragment.kt class PlantDetailFragment : Fragment() { private val args: PlantDetailFragmentArgs by navArgs() private lateinit var shareText: String private val plantDetailViewModel: PlantDetailViewModel by viewModels { InjectorUtils.providePlantDetailViewModelFactory(requireActivity(), args.plantId) } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { val binding = DataBindingUtil.inflate&lt;FragmentPlantDetailBinding&gt;( inflater, R.layout.fragment_plant_detail, container, false).apply { viewModel = plantDetailViewModel lifecycleOwner = this@PlantDetailFragment } plantDetailViewModel.plant.observe(this) { plant -&gt; // 更新相关 UI } return binding.root } } Plant.kt data class Plant ( val name: String ) PlantDetailViewModel.kt class PlantDetailViewModel( plantRepository: PlantRepository, private val plantId: String ) : ViewModel() { val plant: LiveData&lt;Plant&gt; override fun onCleared() { super.onCleared() viewModelScope.cancel() } init { plant = plantRepository.getPlant(plantId) } } PlantDetailViewModelFactory.kt class PlantDetailViewModelFactory( private val plantRepository: PlantRepository, private val plantId: String ) : ViewModelProvider.NewInstanceFactory() { @Suppress(\"UNCHECKED_CAST\") override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T { return PlantDetailViewModel(plantRepository, plantId) as T } } InjectorUtils.kt object InjectorUtils { private fun getPlantRepository(context: Context): PlantRepository { ··· } fun providePlantDetailViewModelFactory( context: Context, plantId: String ): PlantDetailViewModelFactory { return PlantDetailViewModelFactory(getPlantRepository(context), plantId) } } NDK 开发 NDK 全称是 Native Development Kit，是一组可以让你在 Android 应用中编写实现 C/C++ 的工具，可以在项目用自己写源代码构建，也可以利用现有的预构建库。 使用 NDK 的使用目的有： 从设备获取更好的性能以用于计算密集型应用，例如游戏或物理模拟 重复使用自己或其他开发者的 C/C++ 库，便利于跨平台。 NDK 集成了譬如 OpenSL、Vulkan 等 API 规范的特定实现，以实现在 java 层无法做到的功能如提升音频性能等 增加反编译难度 JNI 基础 数据类型 基本数据类型 Java 类型 Native 类型 符号属性 字长 boolean jboolean 无符号 8位 byte jbyte 无符号 8位 char jchar 无符号 16位 short jshort 有符号 16位 int jnit 有符号 32位 long jlong 有符号 64位 float jfloat 有符号 32位 double jdouble 有符号 64位 引用数据类型 Java 引用类型 Native 类型 Java 引用类型 Native 类型 All objects jobject char[] jcharArray java.lang.Class jclass short[] jshortArray java.lang.String jstring int[] jintArray Object[] jobjectArray long[] jlongArray boolean[] jbooleanArray float[] jfloatArray byte[] jbyteArray double[] jdoubleArray java.lang.Throwable jthrowable String 字符串函数操作 JNI 函数 描述 GetStringChars / ReleaseStringChars 获得或释放一个指向 Unicode 编码的字符串的指针（指 C/C++ 字符串） GetStringUTFChars / ReleaseStringUTFChars 获得或释放一个指向 UTF-8 编码的字符串的指针（指 C/C++ 字符串） GetStringLength 返回 Unicode 编码的字符串的长度 getStringUTFLength 返回 UTF-8 编码的字符串的长度 NewString 将 Unicode 编码的 C/C++ 字符串转换为 Java 字符串 NewStringUTF 将 UTF-8 编码的 C/C++ 字符串转换为 Java 字符串 GetStringCritical / ReleaseStringCritical 获得或释放一个指向字符串内容的指针(指 Java 字符串) GetStringRegion 获取或者设置 Unicode 编码的字符串的指定范围的内容 GetStringUTFRegion 获取或者设置 UTF-8 编码的字符串的指定范围的内容 常用 JNI 访问 Java 对象方法 MyJob.java package com.example.myjniproject; public class MyJob { public static String JOB_STRING = \"my_job\"; private int jobId; public MyJob(int jobId) { this.jobId = jobId; } public int getJobId() { return jobId; } } native-lib.cpp #include &lt;jni.h&gt; extern \"C\" JNIEXPORT jint JNICALL Java_com_example_myjniproject_MainActivity_getJobId(JNIEnv *env, jobject thiz, jobject job) { // 根据实力获取 class 对象 jclass jobClz = env-&gt;GetObjectClass(job); // 根据类名获取 class 对象 jclass jobClz = env-&gt;FindClass(\"com/example/myjniproject/MyJob\"); // 获取属性 id jfieldID fieldId = env-&gt;GetFieldID(jobClz, \"jobId\", \"I\"); // 获取静态属性 id jfieldID sFieldId = env-&gt;GetStaticFieldID(jobClz, \"JOB_STRING\", \"Ljava/lang/String;\"); // 获取方法 id jmethodID methodId = env-&gt;GetMethodID(jobClz, \"getJobId\", \"()I\"); // 获取构造方法 id jmethodID initMethodId = env-&gt;GetMethodID(jobClz, \"&lt;init&gt;\", \"(I)V\"); // 根据对象属性 id 获取该属性值 jint id = env-&gt;GetIntField(job, fieldId); // 根据对象方法 id 调用该方法 jint id = env-&gt;CallIntMethod(job, methodId); // 创建新的对象 jobject newJob = env-&gt;NewObject(jobClz, initMethodId, 10); return id; } NDK 开发 基础开发流程 在 java 中声明 native 方法 public class MainActivity extends AppCompatActivity { // Used to load the 'native-lib' library on application startup. static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"MainActivity\", stringFromJNI()); } private native String stringFromJNI(); } 在 app/src/main 目录下新建 cpp 目录，新建相关 cpp 文件，实现相关方法（AS 可用快捷键快速生成） native-lib.cpp #include &lt;jni.h&gt; extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_myjniproject_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str()); } 函数名的格式遵循遵循如下规则：Java_包名_类名_方法名。 extern “C” 指定采用 C 语言的命名风格来编译，否则由于 C 与 C++ 风格不同，导致链接时无法找到具体的函数 JNIEnv*：表示一个指向 JNI 环境的指针，可以通过他来访问 JNI 提供的接口方法 jobject：表示 java 对象中的 this JNIEXPORT 和 JNICALL：JNI 所定义的宏，可以在 jni.h 头文件中查找到 通过 CMake 或者 ndk-build 构建动态库 System.loadLibrary() java/lang/System.java: @CallerSensitive public static void load(String filename) { Runtime.getRuntime().load0(Reflection.getCallerClass(), filename); } 调用 Runtime 相关 native 方法 java/lang/Runtime.java: private static native String nativeLoad(String filename, ClassLoader loader, Class&lt;?&gt; caller); native 方法的实现如下： dalvik/vm/native/java_lang_Runtime.cpp: static void Dalvik_java_lang_Runtime_nativeLoad(const u4* args, JValue* pResult) { ··· bool success; assert(fileNameObj != NULL); // 将 Java 的 library path String 转换到 native 的 String fileName = dvmCreateCstrFromString(fileNameObj); success = dvmLoadNativeCode(fileName, classLoader, &amp;reason); if (!success) { const char* msg = (reason != NULL) ? reason : \"unknown failure\"; result = dvmCreateStringFromCstr(msg); dvmReleaseTrackedAlloc((Object*) result, NULL); } ··· } dvmLoadNativeCode 函数实现如下： dalvik/vm/Native.cpp bool dvmLoadNativeCode(const char* pathName, Object* classLoader, char** detail) { SharedLib* pEntry; void* handle; ··· *detail = NULL; // 如果已经加载过了，则直接返回 true pEntry = findSharedLibEntry(pathName); if (pEntry != NULL) { if (pEntry-&gt;classLoader != classLoader) { ··· return false; } ··· if (!checkOnLoadResult(pEntry)) return false; return true; } Thread* self = dvmThreadSelf(); ThreadStatus oldStatus = dvmChangeStatus(self, THREAD_VMWAIT); // 把.so mmap 到进程空间，并把 func 等相关信息填充到 soinfo 中 handle = dlopen(pathName, RTLD_LAZY); dvmChangeStatus(self, oldStatus); ··· // 创建一个新的 entry SharedLib* pNewEntry; pNewEntry = (SharedLib*) calloc(1, sizeof(SharedLib)); pNewEntry-&gt;pathName = strdup(pathName); pNewEntry-&gt;handle = handle; pNewEntry-&gt;classLoader = classLoader; dvmInitMutex(&amp;pNewEntry-&gt;onLoadLock); pthread_cond_init(&amp;pNewEntry-&gt;onLoadCond, NULL); pNewEntry-&gt;onLoadThreadId = self-&gt;threadId; // 尝试添加到列表中 SharedLib* pActualEntry = addSharedLibEntry(pNewEntry); if (pNewEntry != pActualEntry) { ··· freeSharedLibEntry(pNewEntry); return checkOnLoadResult(pActualEntry); } else { ··· bool result = true; void* vonLoad; int version; // 调用该 so 库的 JNI_OnLoad 方法 vonLoad = dlsym(handle, \"JNI_OnLoad\"); if (vonLoad == NULL) { ··· } else { // 调用 JNI_Onload 方法，重写类加载器。 OnLoadFunc func = (OnLoadFunc)vonLoad; Object* prevOverride = self-&gt;classLoaderOverride; self-&gt;classLoaderOverride = classLoader; oldStatus = dvmChangeStatus(self, THREAD_NATIVE); ··· version = (*func)(gDvmJni.jniVm, NULL); dvmChangeStatus(self, oldStatus); self-&gt;classLoaderOverride = prevOverride; if (version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp; version != JNI_VERSION_1_6) { ··· result = false; } else { ··· } } if (result) pNewEntry-&gt;onLoadResult = kOnLoadOkay; else pNewEntry-&gt;onLoadResult = kOnLoadFailed; pNewEntry-&gt;onLoadThreadId = 0; // 释放锁资源 dvmLockMutex(&amp;pNewEntry-&gt;onLoadLock); pthread_cond_broadcast(&amp;pNewEntry-&gt;onLoadCond); dvmUnlockMutex(&amp;pNewEntry-&gt;onLoadLock); return result; } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"常见面试算法题汇总","slug":"docs/Android/知识汇总/常见面试算法题汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/chang-jian-mian-shi-suan-fa-ti-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/chang-jian-mian-shi-suan-fa-ti-hui-zong/","excerpt":"","text":"排序 比较排序 冒泡排序 归并排序 快速排序 线性排序 计数排序 桶排序 二叉树 顺序遍历 层次遍历 左右翻转 最大值 最大深度 最小深度 平衡二叉树 链表 删除节点 翻转链表 中间元素 判断是否为循环链表 合并两个已排序链表 链表排序 删除倒数第N个节点 两个链表是否相交 栈 / 队列 带最小值操作的栈 有效括号 用栈实现队列 逆波兰表达式求值 二分 二分搜索 X的平方根 哈希表 两数之和 连续数组 最长无重复字符的子串 最多点在一条直线上 堆 / 优先队列 前K大的数 前K大的数II 第K大的数 二叉搜索树 验证二叉搜索树 第K小的元素 数组 / 双指针 加一 删除元素 删除排序数组中的重复数字 我的日程安排表 I 合并排序数组 贪心 买卖股票的最佳时机 买卖股票的最佳时机 II 最大子数组 主元素 字符串处理 生成括号 Excel表列标题 翻转游戏 翻转字符串中的单词 转换字符串到整数 最长公共前缀 回文数 动态规划 单词拆分 爬楼梯 打劫房屋 编辑距离 乘积最大子序列 矩阵 螺旋矩阵 判断数独是否合法 旋转图像 二进制 / 位运算 落单的数 格雷编码 其他 反转整数 LRU缓存策略 排序 比较排序 冒泡排序 重复地走访过要排序的数列，每次比较相邻两个元素，如果它们的顺序错误就把它们交换过来，越大的元素会经由交换慢慢“浮”到数列的尾端。 public void bubbleSort(int[] arr) { int temp = 0; boolean swap; for (int i = arr.length - 1; i &gt; 0; i--) { // 每次需要排序的长度 // 增加一个swap的标志，当前一轮没有进行交换时，说明数组已经有序 swap = false; for (int j = 0; j &lt; i; j++) { // 从第一个元素到第i个元素 if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swap = true; } } if (!swap){ break; } } } 归并排序 分解待排序的数组成两个各具 n/2 个元素的子数组，递归调用归并排序两个子数组，合并两个已排序的子数组成一个已排序的数组。 public void mergeSort(int[] arr) { int[] temp = new int[arr.length]; internalMergeSort(arr, temp, 0, arr.length - 1); } private void internalMergeSort(int[] arr, int[] temp, int left, int right) { // 当left == right时，不需要再划分 if (left &lt; right) { int mid = (left + right) / 2; internalMergeSort(arr, temp, left, mid); internalMergeSort(arr, temp, mid + 1, right); mergeSortedArray(arr, temp, left, mid, right); } } // 合并两个有序子序列 public void mergeSortedArray(int[] arr, int[] temp, int left, int mid, int right) { int i = left; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) { temp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++]; } while (i &lt;= mid) { temp[k++] = arr[i++]; } while (j &lt;= right) { temp[k++] = arr[j++]; } // 把temp数据复制回原数组 for (i = 0; i &lt; k; i++) { arr[left + i] = temp[i]; } } 快速排序 在待排序的数组选取一个元素作为基准，将待排序的元素进行分区，比基准元素大的元素放在一边，比其小的放另一边，递归调用快速排序对两边的元素排序。选取基准元素并分区的过程采用双指针左右交换。 public void quickSort(int[] arr){ quickSort(arr, 0, arr.length-1); } private void quickSort(int[] arr, int low, int high){ if (low &gt;= high) return; int pivot = partition(arr, low, high); //将数组分为两部分 quickSort(arr, low, pivot - 1); //递归排序左子数组 quickSort(arr, pivot + 1, high); //递归排序右子数组 } private int partition(int[] arr, int low, int high){ int pivot = arr[low]; //基准 while (low &lt; high){ while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) { high--; } arr[low] = arr[high]; //交换比基准大的记录到左端 while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { low++; } arr[high] = arr[low]; //交换比基准小的记录到右端 } //扫描完成，基准到位 arr[low] = pivot; //返回的是基准的位置 return low; } 线性排序 计数排序 根据待排序的数组中最大和最小的元素，统计数组中每个值为i的元素出现的次数，存入数组C的第i项，对所有的计数累加，然后反向填充目标数组。 public void countSort(int[] arr) { int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++){ max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); } int[] b = new int[arr.length]; // 存储数组 int[] count = new int[max - min + 1]; // 计数数组 for (int num = min; num &lt;= max; num++) { // 初始化各元素值为0，数组下标从0开始因此减min count[num - min] = 0; } for (int i = 0; i &lt; arr.length; i++) { int num = arr[i]; count[num - min]++; // 每出现一个值，计数数组对应元素的值+1 // 此时count[i]表示数值等于i的元素的个数 } for (int i = min + 1; i &lt;= max; i++) { count[i - min] += count[i - min - 1]; // 此时count[i]表示数值&lt;=i的元素的个数 } for (int i = 0; i &lt; arr.length; i++) { int num = arr[i]; // 原数组第i位的值 int index = count[num - min] - 1; //加总数组中对应元素的下标 b[index] = num; // 将该值存入存储数组对应下标中 count[num - min]--; // 加总数组中，该值的总和减少1。 } // 将存储数组的值替换给原数组 for(int i=0; i &lt; arr.length;i++){ arr[i] = b[i]; } } 桶排序 找出待排序数组中的最大值max、最小值min，数组ArrayList作为桶，桶里放的元素用ArrayList存储。计算每个元素 arr[i] 放的桶，每个桶各自排序，遍历桶数组，把排序好的元素放进输出数组。 public static void bucketSort(int[] arr){ int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++){ max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); } // 桶数 int bucketNum = (max - min) / arr.length + 1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum); for(int i = 0; i &lt; bucketNum; i++){ bucketArr.add(new ArrayList&lt;Integer&gt;()); } // 将每个元素放入桶 for(int i = 0; i &lt; arr.length; i++){ int num = (arr[i] - min) / (arr.length); bucketArr.get(num).add(arr[i]); } // 对每个桶进行排序 for(int i = 0; i &lt; bucketArr.size(); i++){ Collections.sort(bucketArr.get(i)); for (int j = 0; j &lt; bucketArr.get(i).size(); j++) { arr[j] = bucketArr.get(i).get(j); } } } 二叉树 class TreeNode { public TreeNode left, right; public int val; public TreeNode(int val) { this.val = val; } } 顺序遍历 先序遍历: 根-&gt;左-&gt;右中序遍历: 左-&gt;根-&gt;右后序遍历: 左-&gt;右-&gt;根 // 先序遍历 public void preTraverse(TreeNode root) { if (root != null) { System.out.println(root.val); preTraverse(root.left); preTraverse(root.right); } } // 中序遍历 public void inTraverse(TreeNode root) { if (root != null) { inTraverse(root.left); System.out.println(root.val); inTraverse(root.right); } } // 后序遍历 public void postTraverse(TreeNode root) { if (root != null) { postTraverse(root.left); postTraverse(root.right); System.out.println(root.val); } } 层次遍历 // 层次遍历(DFS) public static List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) { return res; } dfs(root, res, 0); return res; } private void dfs(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int level) { if (root == null) { return; } if (level == res.size()) { res.add(new ArrayList&lt;&gt;()); } res.get(level).add(root.val); dfs(root.left, res, level + 1); dfs(root.right, res, level + 1); } // 层次遍历(BFS) public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List result = new ArrayList(); if (root == null) { return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode head = queue.poll(); level.add(head.val); if (head.left != null) { queue.offer(head.left); } if (head.right != null) { queue.offer(head.right); } } result.add(level); } return result; } // \"Z\"字遍历 public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); boolean isFromLeft = false; while(!queue.isEmpty()){ int size = queue.size(); isFromLeft = !isFromLeft; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; size; i++){ TreeNode node; if (isFromLeft){ node = queue.pollFirst(); }else{ node = queue.pollLast(); } list.add(node.val); if (isFromLeft){ if (node.left != null){ queue.offerLast(node.left); } if (node.right != null){ queue.offerLast(node.right); } }else{ if (node.right != null){ queue.offerFirst(node.right); } if (node.left != null){ queue.offerFirst(node.left); } } } result.add(list); } return result; } 左右翻转 public void invert(TreeNode root) { if (root == null) { return; } TreeNode temp = root.left; root.left = root.right; root.right = temp; invert(root.left); invert(root.right); } 最大值 public int getMax(TreeNode root) { if (root == null) { return Integer.MIN_VALUE; } else { int left = getMax(root.left); int right = getMax(root.right); return Math.max(Math.max(left, rigth), root.val); } } 最大深度 public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; } 最小深度 public int minDepth(TreeNode root) { if (root == null) { return 0; } int left = minDepth(root.left); int right = minDepth(root.right); if (left == 0) { return right + 1; } else if (right == 0) { return left + 1; } else { return Math.min(left, right) + 1; } } 平衡二叉树 平衡二叉树每一个节点的左右两个子树的高度差不超过1 public boolean isBalanced(TreeNode root) { return maxDepth(root) != -1; } private int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) { return -1; } return Math.max(left, right) + 1; } 链表 public class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } 删除节点 public void deleteNode(ListNode node) { if (node.next == null){ node = null; return; } // 取缔下一节点 node.val = node.next.val node.next = node.next.next } 翻转链表 public ListNode reverse(ListNode head) { //prev表示前继节点 ListNode prev = null; while (head != null) { //temp记录下一个节点，head是当前节点 ListNode temp = head.next; head.next = prev; prev = head; head = temp; } return prev; } 中间元素 public ListNode findMiddle(ListNode head){ if(head == null){ return null; } ListNode slow = head; ListNode fast = head; // fast.next = null 表示 fast 是链表的尾节点 while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; } return slow; } 判断是否为循环链表 public Boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (fast != slow) { if(fast == null || fast.next == null) { return false; } fast = fast.next.next; slow = slow.next; } return true; } 合并两个已排序链表 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode lastNode = dummy; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { lastNode.next = l1; l1 = l1.next; } else { lastNode.next = l2; l2 = l2.next; } lastNode = lastNode.next; } if (l1 != null) { lastNode.next = l1; } else { lastNode.next = l2; } return dummy.next; } 链表排序 可利用归并、快排等算法实现 // 归并排序 public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode mid = findMiddle(head); ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); return mergeTwoLists(left, right); } // 快速排序 public ListNode sortList(ListNode head) { quickSort(head, null); return head; } private void quickSort(ListNode start, ListNode end) { if (start == end) { return; } ListNode pt = partition(start, end); quickSort(start, pt); quickSort(pt.next, end); } private ListNode partition(ListNode start, ListNode end) { int pivotKey = start.val; ListNode p1 = start, p2 = start.next; while (p2 != end) { if (p2.val &lt; pivotKey) { p1 = p1.next; swapValue(p1, p2); } p2 = p2.next; } swapValue(start, p1); return p1; } private void swapValue(ListNode node1, ListNode node2) { int tmp = node1.val; node1.val = node2.val; node2.val = tmp; } 删除倒数第N个节点 public ListNode removeNthFromEnd(ListNode head, int n) { if (n &lt;= 0) { return null; } ListNode dummy = new ListNode(0); dummy.next = head; ListNode preDelete = dummy; for (int i = 0; i &lt; n; i++) { if (head == null) { return null; } head = head.next; } // 此时head为正数第N个节点 while (head != null) { head = head.next; preDelete = preDelete.next; } preDelete.next = preDelete.next.next; return dummy.next; } 两个链表是否相交 public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode currA = headA; ListNode currB = headB; int lengthA = 0; int lengthB = 0; // 让长的先走到剩余长度和短的一样 while (currA != null) { currA = currA.next; lengthA++; } while (currB != null) { currB = currB.next; lengthB++; } currA = headA; currB = headB; while (lengthA &gt; lengthB) { currA = currA.next; lengthA--; } while (lengthB &gt; lengthA) { currB = currB.next; lengthB--; } // 然后同时走到第一个相同的地方 while (currA != currB) { currA = currA.next; currB = currB.next; } // 返回交叉开始的节点 return currA; } 栈 / 队列 带最小值操作的栈 实现一个栈, 额外支持一个操作：min() 返回栈中元素的最小值 public class MinStack { private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; // 维护一个辅助栈，传入当前栈的最小值 public MinStack() { stack = new Stack&lt;Integer&gt;(); minStack = new Stack&lt;Integer&gt;(); } public void push(int number) { stack.push(number); if (minStack.isEmpty()) { minStack.push(number); } else { minStack.push(Math.min(number, minStack.peek())); } } public int pop() { minStack.pop(); return stack.pop(); } public int min() { return minStack.peek(); } } 有效括号 给定一个字符串所表示的括号序列，包含以下字符： ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’， 判定是否是有效的括号序列。括号必须依照 “()” 顺序表示， “()[]{}” 是有效的括号，但 “([)]” 则是无效的括号。 public boolean isValidParentheses(String s) { Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (Character c : s.toCharArray()) { if (\"({[\".contains(String.valueOf(c))) { stack.push(c); } else { if (!stack.isEmpty() &amp;&amp; isValid(stack.peek(), c)) { stack.pop(); } else { return false; } } } return stack.isEmpty(); } private boolean isValid(char c1, char c2) { return (c1 == '(' &amp;&amp; c2 == ')') || (c1 == '{' &amp;&amp; c2 == '}') || (c1 == '[' &amp;&amp; c2 == ']'); } 用栈实现队列 public class MyQueue { private Stack&lt;Integer&gt; outStack; private Stack&lt;Integer&gt; inStack; public MyQueue() { outStack = new Stack&lt;Integer&gt;(); inStack = new Stack&lt;Integer&gt;(); } private void in2OutStack(){ while(!inStack.isEmpty()){ outStack.push(inStack.pop()); } } public void push(int element) { inStack.push(element); } public int pop() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.pop(); } public int top() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.peek(); } } 逆波兰表达式求值 在反向波兰表示法中计算算术表达式的值, [“2”, “1”, “+”, “3”, “*”] -&gt; (2 + 1) * 3 -&gt; 9 public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); String operators = \"+-*/\"; for (String token : tokens) { if (!operators.contains(token)) { s.push(Integer.valueOf(token)); continue; } int a = s.pop(); int b = s.pop(); if (token.equals(\"+\")) { s.push(b + a); } else if(token.equals(\"-\")) { s.push(b - a); } else if(token.equals(\"*\")) { s.push(b * a); } else { s.push(b / a); } } return s.pop(); } 二分 二分搜索 public int binarySearch(int[] arr, int start, int end, int hkey){ if (start &gt; end) { return -1; } int mid = start + (end - start) / 2; //防止溢位 if (arr[mid] &gt; hkey) { return binarySearch(arr, start, mid - 1, hkey); } if (arr[mid] &lt; hkey) { return binarySearch(arr, mid + 1, end, hkey); } return mid; } X的平方根 public int sqrt(int x) { if (x &lt; 0) { throw new IllegalArgumentException(); } else if (x &lt;= 1) { return x; } int start = 1, end = x; // 直接对答案可能存在的区间进行二分 =&gt; 二分答案 while (start + 1 &lt; end) { int mid = start + (end - start) / 2; if (mid == x / mid) { return mid; } else if (mid &lt; x / mid) { start = mid; } else { end = mid; } } if (end &gt; x / end) { return start; } return end; } 哈希表 两数之和 给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。需要实现的函数twoSum需要返回这两个数的下标。 用一个hashmap来记录，key记录target-numbers[i]的值，value记录numbers[i]的i的值，如果碰到一个numbers[j]在hashmap中存在，那么说明前面的某个numbers[i]和numbers[j]的和为target，i和j即为答案 public int[] twoSum(int[] numbers, int target) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numbers.length; i++) { if (map.containsKey(numbers[i])) { return new int[]{map.get(numbers[i]), i}; } map.put(target - numbers[i], i); } return new int[]{}; } 连续数组 给一个二进制数组，找到 0 和 1 数量相等的子数组的最大长度 使用一个数字sum维护到i为止1的数量与0的数量的差值。在loop i的同时维护sum并将其插入hashmap中。对于某一个sum值，若hashmap中已有这个值，则当前的i与sum上一次出现的位置之间的序列0的数量与1的数量相同。 public int findMaxLength(int[] nums) { Map&lt;Integer, Integer&gt; prefix = new HashMap&lt;&gt;(); int sum = 0; int max = 0; prefix.put(0, -1); // 当第一个0 1数量相等的情况出现时，数组下标减去-1得到正确的长度 for (int i = 0; i &lt; nums.length; i++) { int num = nums[i]; if (num == 0) { sum--; } else { sum++; } if (prefix.containsKey(sum)) { max = Math.max(max, i - prefix.get(sum)); } else { prefix.put(sum, i); } } return max; } 最长无重复字符的子串 用HashMap记录每一个字母出现的位置。设定一个左边界, 到当前枚举到的位置之间的字符串为不含重复字符的子串。若新碰到的字符的上一次的位置在左边界右边, 则需要向右移动左边界 public int lengthOfLongestSubstring(String s) { if (s == null || s.length() == 0) { return 0; } HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int start = -1; // 计算无重复字符子串开始的位置 int current = 0; for (int i = 0; i &lt; s.length(); i++) { if (map.containsKey(s.charAt(i))) { int tmp = map.get(s.charAt(i)); if (tmp &gt;= start) { // 上一次的位置在左边界右边, 则需要向右移动左边界 start = tmp; } } map.put(s.charAt(i), i); max = Math.max(max, i - start); } return max; } 最多点在一条直线上 给出二维平面上的n个点，求最多有多少点在同一条直线上 class Point { int x; int y; Point() { x = 0; y = 0; } Point(int a, int b) { x = a; y = b; } } 通过HashMap记录下两个点之间的斜率相同出现的次数，注意考虑点重合的情况 public int maxPoints(Point[] points) { if (points == null) { return 0; } int max = 0; for (int i = 0; i &lt; points.length; i++) { Map&lt;Double, Integer&gt; map = new HashMap&lt;&gt;(); int maxPoints = 0; int overlap = 0; for (int j = i + 1; j &lt; points.length; j++) { if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) { overlap++; // 两个点重合的情况记录下来 continue; } double rate = (double)(points[i].y - points[j].y) / (points[i].x - points[j].x); if (map.containsKey(rate)) { map.put(rate, map.get(rate) + 1); } else { map.put(rate, 2); } maxPoints = Math.max(maxPoints, map.get(rate)); } if (maxPoints == 0) maxPoints = 1; max = Math.max(max, maxPoints + overlap); } return max; } 堆 / 优先队列 前K大的数 // 维护一个 PriorityQueue，以返回前K的数 public int[] topk(int[] nums, int k) { int[] result = new int[k]; if (nums == null || nums.length &lt; k) { return result; } Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for (int num : nums) { pq.add(num); if (pq.size() &gt; k) { pq.poll(); } } for (int i = k - 1; i &gt;= 0; i--) { result[i] = pq.poll(); } return result; } 前K大的数II 实现一个数据结构，提供下面两个接口：1.add(number) 添加一个元素 2.topk() 返回前K大的数 public class Solution { private int maxSize; private Queue&lt;Integer&gt; minheap; public Solution(int k) { minheap = new PriorityQueue&lt;&gt;(); maxSize = k; } public void add(int num) { if (minheap.size() &lt; maxSize) { minheap.offer(num); return; } if (num &gt; minheap.peek()) { minheap.poll(); minheap.offer(num); } } public List&lt;Integer&gt; topk() { Iterator it = minheap.iterator(); List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); while (it.hasNext()) { result.add((Integer) it.next()); } Collections.sort(result, Collections.reverseOrder()); return result; } } 第K大的数 public int kthLargestElement(int k, int[] nums) { if (nums == null || nums.length == 0 || k &lt; 1 || k &gt; nums.length){ return -1; } return partition(nums, 0, nums.length - 1, nums.length - k); } private int partition(int[] nums, int start, int end, int k) { if (start &gt;= end) { return nums[k]; } int left = start, right = end; int pivot = nums[(start + end) / 2]; while (left &lt;= right) { while (left &lt;= right &amp;&amp; nums[left] &lt; pivot) { left++; } while (left &lt;= right &amp;&amp; nums[right] &gt; pivot) { right--; } if (left &lt;= right) { swap(nums, left, right); left++; right--; } } if (k &lt;= right) { return partition(nums, start, right, k); } if (k &gt;= left) { return partition(nums, left, end, k); } return nums[k]; } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } 二叉搜索树 验证二叉搜索树 public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean isValidBST(TreeNode root, long min, long max){ if (root == null) { return true; } if (root.val &lt;= min || root.val &gt;= max){ return false; } return isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max); } 第K小的元素 增加getCount方法来获取传入节点的子节点数（包括自己），从root节点开始判断k值和子节点数的大小决定递归路径是往左还是往右。 public int kthSmallest(TreeNode root, int k) { if (root == null) { return 0; } int leftCount = getCount(root.left); if (leftCount &gt;= k) { return kthSmallest(root.left, k); } else if (leftCount + 1 == k) { return root.val; } else { return kthSmallest(root.right, k - leftCount - 1); } } private int getCount(TreeNode root) { if (root == null) { return 0; } return getCount(root.left) + getCount(root.right) + 1; } 数组 / 双指针 加一 给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。该数字按照数位高低进行排列，最高位的数在列表的最前面。 public int[] plusOne(int[] digits) { int carries = 1; for(int i = digits.length - 1; i &gt;= 0 &amp;&amp; carries &gt; 0; i--){ int sum = digits[i] + carries; digits[i] = sum % 10; carries = sum / 10; } if(carries == 0) { return digits; } int[] rst = new int[digits.length + 1]; rst[0] = 1; for(int i = 1; i &lt; rst.length; i++){ rst[i] = digits[i - 1]; } return rst; } 删除元素 给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。 public int removeElement(int[] A, int elem) { if (A == null || A.length == 0) { return 0; } int index = 0; for (int i = 0; i &lt; A.length; i++) { if (A[i] != elem) { A[index++] = A[i]; } } return index; } 删除排序数组中的重复数字 在原数组中“删除”重复出现的数字，使得每个元素只出现一次，并且返回“新”数组的长度。 public int removeDuplicates(int[] A) { if (A == null || A.length == 0) { return 0; } int size = 0; for (int i = 0; i &lt; A.length; i++) { if (A[i] != A[size]) { A[++size] = A[i]; } } return size + 1; } 我的日程安排表 I 实现MyCalendar类来存储活动。如果新添加的活动没有重复，则可以添加。类将有方法book(int start，int end)。这代表左闭右开的间隔[start，end)有了预定，范围内的实数x，都满足start &lt;= x &lt; end，返回true。 否则，返回false，并且事件不会添加到日历中。 TreeMap 是一个有序的key-value集合，它通过 红黑树 实现，继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap可以查询小于等于某个值的最大的key，也可查询大于等于某个值的最小的key。元素的顺序可以改变，并且对新的数组不会有影响。 class MyCalendar { TreeMap&lt;Integer, Integer&gt; calendar; MyCalendar() { calendar = new TreeMap(); } public boolean book(int start, int end) { Integer previous = calendar.floorKey(start), next = calendar.ceilingKey(start); if ((previous == null || calendar.get(previous) &lt;= start) &amp;&amp; (next == null || end &lt;= next)) { calendar.put(start, end); return true; } return false; } } 合并排序数组 合并两个排序的整数数组A和B变成一个新的数组。可以假设A具有足够的空间去添加B中的元素。 public void mergeSortedArray(int[] A, int m, int[] B, int n) { int i = m - 1, j = n - 1, index = m + n - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) { if (A[i] &gt; B[j]) { A[index--] = A[i--]; } else { A[index--] = B[j--]; } } while (i &gt;= 0) { A[index--] = A[i--]; } while (j &gt;= 0) { A[index--] = B[j--]; } } 贪心 买卖股票的最佳时机 假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如，一次买卖股票)，设计一个算法来找出最大利润。 public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int min = Integer.MAX_VALUE; //记录最低的价格 int profit = 0; for (int price : prices) { min = Math.min(price, min); profit = Math.max(price - min, profit); } return profit; } 买卖股票的最佳时机 II 给定一个数组 prices 表示一支股票每天的价格。可以完成任意次数的交易, 不过不能同时参与多个交易，设计一个算法求出最大的利润。 贪心：只要相邻的两天股票的价格是上升的, 我们就进行一次交易, 获得一定利润。 public int maxProfit(int[] prices) { int profit = 0; for (int i = 0; i &lt; prices.length - 1; i++) { int diff = prices[i + 1] - prices[i]; if (diff &gt; 0) { profit += diff; } } return profit; } 最大子数组 给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。 public int maxSubArray(int[] A) { if (A == null || A.length == 0){ return 0; } //max记录全局最大值，sum记录区间和，如果当前sum&gt;0，那么可以继续和后面的数求和，否则就从0开始 int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) { sum += A[i]; max = Math.max(max, sum); sum = Math.max(sum, 0); } return max; } 主元素 给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一(可以假设数组非空，且数组中总是存在主元素)。 public int majorityNumber(List&lt;Integer&gt; nums) { int currentMajor = 0; int count = 0; for(Integer num : nums) { if(count == 0) { currentMajor = num; } if(num == currentMajor) { count++; } else { count--; } } return currentMajor; } 字符串处理 生成括号 给定 n，表示有 n 对括号, 请写一个函数以将其生成所有的括号组合，并返回组合结果。 public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(n, n, \"\", res); return res; } // DFS private void helper(int nL, int nR, String parenthesis, List&lt;String&gt; res) { // nL 和 nR 分别代表左右括号剩余的数量 if (nL &lt; 0 || nR &lt; 0) { return; } if (nL == 0 &amp;&amp; nR == 0) { res.add(parenthesis); return; } helper(nL - 1, nR, parenthesis + \"(\", res); if (nL &gt;= nR) { return; } helper(nL, nR - 1, parenthesis + \")\", res); } Excel表列标题 给定一个正整数，返回相应的列标题，如Excel表中所示。如1 -&gt; A，2 -&gt; B…26 -&gt; Z，27 -&gt; AA public String convertToTitle (int n) { StringBuilder str = new StringBuilder(); while (n &gt; 0) { n--; str.append ( (char) ( (n % 26) + 'A')); n /= 26; } return str.reverse().toString(); } 翻转游戏 翻转游戏：给定一个只包含两种字符的字符串：+和-，你和你的小伙伴轮流翻转”++”变成”–”。当一个人无法采取行动时游戏结束，另一个人将是赢家。编写一个函数，计算字符串在一次有效移动后的所有可能状态。 public List&lt;String&gt; generatePossibleNextMoves (String s) { List list = new ArrayList(); for (int i = -1; (i = s.indexOf (\"++\", i + 1)) &gt;= 0;) { list.add (s.substring (0, i) + \"--\" + s.substring (i + 2)); } return list; } 翻转字符串中的单词 给定一个字符串，逐个翻转字符串中的每个单词。 public String reverseWords(String s) { if(s.length() == 0 || s == null){ return \" \"; } //按照空格将s切分 String[] array = s.split(\" \"); StringBuilder sb = new StringBuilder(); //从后往前遍历array，在sb中插入单词 for(int i = array.length - 1; i &gt;= 0; i--){ if(!array[i].equals(\"\")) { if (sb.length() &gt; 0) { sb.append(\" \"); } sb.append(array[i]); } } return sb.toString(); } 转换字符串到整数 实现atoi这个函数，将一个字符串转换为整数。如果没有合法的整数，返回0。如果整数超出了32位整数的范围，返回INT_MAX(2147483647)如果是正整数，或者INT_MIN(-2147483648)如果是负整数。 public int myAtoi(String str) { if(str == null) { return 0; } str = str.trim(); if (str.length() == 0) { return 0; } int sign = 1; int index = 0; if (str.charAt(index) == '+') { index++; } else if (str.charAt(index) == '-') { sign = -1; index++; } long num = 0; for (; index &lt; str.length(); index++) { if (str.charAt(index) &lt; '0' || str.charAt(index) &gt; '9') { break; } num = num * 10 + (str.charAt(index) - '0'); if (num &gt; Integer.MAX_VALUE ) { break; } } if (num * sign &gt;= Integer.MAX_VALUE) { return Integer.MAX_VALUE; } if (num * sign &lt;= Integer.MIN_VALUE) { return Integer.MIN_VALUE; } return (int)num * sign; } 最长公共前缀 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } String prefix = strs[0]; for(int i = 1; i &lt; strs.length; i++) { int j = 0; while (j &lt; strs[i].length() &amp;&amp; j &lt; prefix.length() &amp;&amp; strs[i].charAt(j) == prefix.charAt(j)) { j++; } if( j == 0) { return \"\"; } prefix = prefix.substring(0, j); } return prefix; } 回文数 判断一个正整数是不是回文数。回文数的定义是，将这个数反转之后，得到的数仍然是同一个数。 public boolean palindromeNumber(int num) { // Write your code here if(num &lt; 0){ return false; } int div = 1; while(num / div &gt;= 10){ div *= 10; } while(num &gt; 0){ if(num / div != num % 10){ return false; } num = (num % div) / 10; div /= 100; } return true; } 动态规划 单词拆分 给定字符串 s 和单词字典 dict，确定 s 是否可以分成一个或多个以空格分隔的子串，并且这些子串都在字典中存在。 public boolean wordBreak(String s, Set&lt;String&gt; dict) { // write your code here int maxLength = getMaxLength(dict); // 长度为n的单词 有n + 1个切割点 比如: _l_i_n_t_ boolean[] canBreak = new boolean[s.length() + 1]; // 当s长度为0时 canBreak[0] = true; for(int i = 1; i &lt; canBreak.length; i++){ for(int j = 1; j &lt;= maxLength &amp;&amp; j &lt;= i; j++){ //i - j 表示从 i 点开始往前j个点的位置 String str = s.substring(i - j,i); //如果此str在词典中 并且 str之前的 字符串可以拆分 if(dict.contains(str) &amp;&amp; canBreak[i - j]){ canBreak[i] = true; break; } } } return canBreak[canBreak.length - 1]; } private int getMaxLength(Set&lt;String&gt; dict){ int max = 0; for(String s : dict){ max = Math.max(max,s.length()); } return max; } 爬楼梯 假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？ public int climbStairs(int n) { if (n == 0) return 0; int[] array = new int[n + 1]; array[0] = 1; if (array.length &gt; 1) { array[1] = 1; } for(int i = 2; i &lt; array.length; i++) { array[i] = array[i - 1] + array[i - 2]; } return array[n]; } 打劫房屋 假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，在不触动报警装置的情况下, 你最多可以得到多少钱 。 public long houseRobber(int[] A) { if (A.length == 0) return 0; long[] res = new long[A.length + 1]; res[0] = 0; res[1] = A[0]; for (int i = 2; i &lt; res.length; i++) { res[i] = Math.max(res[i - 2] + A[i - 1], res[i - 1]); } return res[A.length]; } 编辑距离 给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：插入一个字符、删除一个字符、替换一个字符。 public int minDistance(String word1, String word2) { // write your code here int n = word1.length(); int m = word2.length(); int[][] dp = new int[n + 1][m + 1]; for (int i = 0; i &lt; n + 1; i++){ dp[i][0] = i; } for (int j = 0; j &lt; m + 1; j++){ dp[0][j] = j; } for (int i = 1; i&lt; n + 1; i++){ for (int j = 1; j &lt; m + 1; j++){ if (word1.charAt(i - 1) == word2.charAt(j - 1)){ dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])); } } } return dp[n][m]; } 乘积最大子序列 public int maxProduct(List&lt;Integer&gt; nums) { // 分别记录正数最大值和负数最小值 int[] max = new int[nums.size()]; int[] min = new int[nums.size()]; min[0] = max[0] = nums.get(0); int result = nums.get(0); for (int i = 1; i &lt; nums.size(); i++) { min[i] = max[i] = nums.get(i); if (nums.get(i) &gt; 0) { max[i] = Math.max(max[i], max[i - 1] * nums.get(i)); min[i] = Math.min(min[i], min[i - 1] * nums.get(i)); } else if (nums.get(i) &lt; 0) { max[i] = Math.max(max[i], min[i - 1] * nums.get(i)); min[i] = Math.min(min[i], max[i - 1] * nums.get(i)); } result = Math.max(result, max[i]); } return result; } 矩阵 螺旋矩阵 给定一个包含 m x n 个要素的矩阵，（m 行, n 列），按照螺旋顺序，返回该矩阵中的所有要素。 public List&lt;Integer&gt; spiralOrder(int[][] matrix) { ArrayList&lt;Integer&gt; rst = new ArrayList&lt;Integer&gt;(); if(matrix == null || matrix.length == 0) { return rst; } int rows = matrix.length; int cols = matrix[0].length; int count = 0; while(count * 2 &lt; rows &amp;&amp; count * 2 &lt; cols){ for (int i = count; i &lt; cols - count; i++) { rst.add(matrix[count][i]); } for (int i = count + 1; i &lt; rows - count; i++) { rst.add(matrix[i][cols - count - 1]); } if (rows - 2 * count == 1 || cols - 2 * count == 1) { // 如果只剩1行或1列 break; } for (int i = cols - count - 2; i &gt;= count; i--) { rst.add(matrix[rows - count - 1][i]); } for (int i = rows - count - 2; i &gt;= count + 1; i--) { rst.add(matrix[i][count]); } count++; } return rst; } 判断数独是否合法 请判定一个数独是否有效。该数独可能只填充了部分数字，其中缺少的数字用 . 表示。 维护一个HashSet用来记同一行、同一列、同一九宫格是否存在相同数字 public boolean isValidSudoku(char[][] board) { Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) { for (int j=0; j&lt;9; ++j) { char number = board[i][j]; if (number != '.') if (!seen.add(number + \" in row \" + i) || !seen.add(number + \" in column \" + j) || !seen.add(number + \" in block \" + i / 3 + \"-\" + j / 3)) return false; } } return true; } 旋转图像 给定一个N×N的二维矩阵表示图像，90度顺时针旋转图像。 public void rotate(int[][] matrix) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { return; } int length = matrix.length; for (int i = 0; i &lt; length / 2; i++) { for (int j = 0; j &lt; (length + 1) / 2; j++){ int tmp = matrix[i][j]; matrix[i][j] = matrix[length - j - 1][i]; matrix[length -j - 1][i] = matrix[length - i - 1][length - j - 1]; matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1]; matrix[j][length - i - 1] = tmp; } } } 二进制 / 位运算 落单的数 给出 2 * n + 1个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。 异或运算具有很好的性质，相同数字异或运算后为0，并且具有交换律和结合律，故将所有数字异或运算后即可得到只出现一次的数字。 public int singleNumber(int[] A) { if(A == null || A.length == 0) { return -1; } int rst = 0; for (int i = 0; i &lt; A.length; i++) { rst ^= A[i]; } return rst; } 格雷编码 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个二进制的差异。给定一个非负整数 n ，表示该代码中所有二进制的总数，请找出其格雷编码顺序。一个格雷编码顺序必须以 0 开始，并覆盖所有的 2n 个整数。例子——输入：2；输出：[0, 1, 3, 2]；解释: 0 - 00，1 - 01，3 - 11，2 - 10 格雷码生成公式：G(i) = i ^ (i &gt;&gt; 2) public ArrayList&lt;Integer&gt; grayCode(int n) { ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; (1 &lt;&lt; n); i++) { result.add(i ^ (i &gt;&gt; 1)); } return result; } 其他 反转整数 将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)。 public int reverseInteger(int n) { int reversed_n = 0; while (n != 0) { int temp = reversed_n * 10 + n % 10; n = n / 10; if (temp / 10 != reversed_n) { reversed_n = 0; break; } reversed_n = temp; } return reversed_n; } LRU缓存策略 为最近最少使用（LRU）缓存策略设计一个数据结构，它应该支持以下操作：获取数据（get）和写入数据（set）。获取数据get(key)：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。 写入数据set(key, value)：如果key还没有在缓存中，则写入其数据值。当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。 public class LRUCache { private class Node{ Node prev; Node next; int key; int value; public Node(int key, int value) { this.key = key; this.value = value; this.prev = null; this.next = null; } } private int capacity; private HashMap&lt;Integer, Node&gt; hs = new HashMap&lt;Integer, Node&gt;(); private Node head = new Node(-1, -1); private Node tail = new Node(-1, -1); public LRUCache(int capacity) { this.capacity = capacity; tail.prev = head; head.next = tail; } public int get(int key) { if( !hs.containsKey(key)) { //key找不到 return -1; } // remove current Node current = hs.get(key); current.prev.next = current.next; current.next.prev = current.prev; // move current to tail move_to_tail(current); //每次get，使用次数+1，最近使用，放于尾部 return hs.get(key).value; } public void set(int key, int value) { //数据放入缓存 // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail if (get(key) != -1) { hs.get(key).value = value; return; } if (hs.size() == capacity) { //超出缓存上限 hs.remove(head.next.key); //删除头部数据 head.next = head.next.next; head.next.prev = head; } Node insert = new Node(key, value); //新建节点 hs.put(key, insert); move_to_tail(insert); //放于尾部 } private void move_to_tail(Node current) { //移动数据至尾部 current.prev = tail.prev; tail.prev = current; current.prev.next = current; current.next = tail; } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Android知识点汇总","slug":"docs/Android/知识汇总/Android知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/android-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/android-zhi-shi-dian-hui-zong/","excerpt":"","text":"Activity 生命周期 启动模式 启动过程 Fragment 特点 生命周期 与Activity通信 Service 启动过程 绑定过程 生命周期 启用前台服务 BroadcastReceiver 注册过程 ContentProvider 基本使用 数据存储 View MeasureSpec MotionEvent VelocityTracker GestureDetector Scroller View 的滑动 View 的事件分发 在 Activity 中获取某个 View 的宽高 Draw 的基本流程 自定义 View 进程 进程生命周期 多进程 进程存活 OOM_ADJ 进程被杀情况 进程保活方案 Parcelable 接口 使用示例 方法说明 Parcelable 与 Serializable 对比 IPC IPC方式 Binder 流程 AIDL 通信 Messenger Window / WindowManager Window 概念与分类 Window 的内部机制 Window 的创建过程 Activity 的 Window 创建过程 Dialog 的 Window 创建过程 Toast 的 Window 创建过程 Bitmap 配置信息与压缩方式 常用操作 裁剪、缩放、旋转、移动 保存与释放 图片压缩 BitmapFactory Bitmap创建流程 Option类 基本使用 内存回收 屏幕适配 单位 头条适配方案 刘海屏适配 Context SharedPreferences 获取方式 getPreferences getDefaultSharedPreferences getSharedPreferences 架构 apply / commit 注意 消息机制 Handler 机制 工作原理 ThreadLocal MessageQueue Looper Handler 线程异步 AsyncTask 基本使用 工作原理 HandlerThread IntentService 线程池 RecyclerView 优化 Webview 基本使用 WebView WebSettings WebViewClient WebChromeClient Webview 加载优化 内存泄漏 Activity 生命周期 Activity A 启动另一个Activity B，回调如下:Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop()；如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop； 使用onSaveInstanceState（）保存简单，轻量级的UI状态 lateinit var textView: TextView var gameState: String? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) gameState = savedInstanceState?.getString(GAME_STATE_KEY) setContentView(R.layout.activity_main) textView = findViewById(R.id.text_view) } override fun onRestoreInstanceState(savedInstanceState: Bundle?) { textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY) } override fun onSaveInstanceState(outState: Bundle?) { outState?.run { putString(GAME_STATE_KEY, gameState) putString(TEXT_VIEW_KEY, textView.text.toString()) } super.onSaveInstanceState(outState) } 启动模式 LaunchMode 说明 standard 系统在启动它的任务中创建 activity 的新实例 singleTop 如果activity的实例已存在于当前任务的顶部，则系统通过调用其onNewIntent()，否则会创建新实例 singleTask 系统创建新 task 并在 task 的根目录下实例化 activity。但如果 activity 的实例已存在于单独的任务中，则调用其 onNewIntent() 方法，其上面的实例会被移除栈。一次只能存在一个 activity 实例 singleInstance 相同 singleTask，activity始终是其task的唯一成员; 任何由此开始的activity 都在一个单独的 task 中打开 &nbsp; 启动过程 ActivityThread.java private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { //step 1: 创建LoadedApk对象 r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ... //component初始化过程 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //step 2: 创建Activity对象 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); ... //step 3: 创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) { //step 4: 创建ContextImpl对象 Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //step5: 将Application/ContextImpl都attach到Activity对象 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { //step 6: 执行回调onCreate mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); //执行回调onStart r.stopped = false; } if (!r.activity.mFinished) { //执行回调onRestoreInstanceState if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ... r.paused = true; mActivities.put(r.token, r); } return activity; } Fragment 特点 Fragment 解决 Activity 间的切换不流畅，轻量切换 可以从 startActivityForResult 中接收到返回结果，但是View不能 只能在 Activity 保存其状态（用户离开 Activity）之前使用 commit() 提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。 生命周期 与Activity通信 执行此操作的一个好方法是，在片段内定义一个回调接口，并要求宿主 Activity 实现它。 public static class FragmentA extends ListFragment { ... // Container Activity must implement this interface public interface OnArticleSelectedListener { public void onArticleSelected(Uri articleUri); } ... } public static class FragmentA extends ListFragment { OnArticleSelectedListener mListener; ... @Override public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (OnArticleSelectedListener) activity; } catch (ClassCastException e) { throw new ClassCastException(activity.toString()); } } ... } Service Service 分为两种工作状态，一种是启动状态，主要用于执行后台计算；另一种是绑定状态，主要用于其他组件和 Service 的交互。 启动过程 ActivityThread.java @UnsupportedAppUsage private void handleCreateService(CreateServiceData data) { ··· LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try { java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = packageInfo.getAppFactory() .instantiateService(cl, data.info.name, data.intent); } ··· try { if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); service.onCreate(); mServices.put(data.token, service); try { ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } ··· } 绑定过程 ActivityThread.java private void handleBindService(BindServiceData data) { Service s = mServices.get(data.token); ··· if (s != null) { try { data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try { if (!data.rebind) { IBinder binder = s.onBind(data.intent); ActivityManager.getService().publishService( data.token, data.intent, binder); } else { s.onRebind(data.intent); ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); } } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } ··· } } 生命周期 值 说明 START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务 启用前台服务 &lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/&gt; Notification notification = new Notification(icon, text, System.currentTimeMillis()); Intent notificationIntent = new Intent(this, ExampleActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, title, mmessage, pendingIntent); startForeground(ONGOING_NOTIFICATION_ID, notification); BroadcastReceiver target 26 之后，无法在 AndroidManifest 显示声明大部分广播，除了一部分必要的广播，如： ACTION_BOOT_COMPLETED ACTION_TIME_SET ACTION_LOCALE_CHANGEDLocalBroadcastManager.getInstance(MainActivity.this).registerReceiver(receiver, filter); 注册过程 ContentProvider ContentProvider 管理对结构化数据集的访问。它们封装数据，并提供用于定义数据安全性的机制。 内容提供程序是连接一个进程中的数据与另一个进程中运行的代码的标准界面。 ContentProvider 无法被用户感知，对于一个 ContentProvider 组件来说，它的内部需要实现增删该查这四种操作，它的内部维持着一份数据集合，这个数据集合既可以是数据库实现，也可以是其他任何类型，如 List 和 Map，内部的 insert、delete、update、query 方法需要处理好线程同步，因为这几个方法是在 Binder 线程池中被调用的。 ContentProvider 通过 Binder 向其他组件乃至其他应用提供数据。当 ContentProvider 所在的进程启动时，ContentProvider 会同时启动并发布到 AMS 中，需要注意的是，这个时候 ContentProvider 的 onCreate 要先于 Application 的 onCreate 而执行。 基本使用 // Queries the user dictionary and returns results mCursor = getContentResolver().query( UserDictionary.Words.CONTENT_URI, // The content URI of the words table mProjection, // The columns to return for each row mSelectionClause // Selection criteria mSelectionArgs, // Selection criteria mSortOrder); // The sort order for the returned rows public class Installer extends ContentProvider { @Override public boolean onCreate() { return true; } @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) { return null; } @Nullable @Override public String getType(@NonNull Uri uri) { return null; } @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) { return null; } @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) { return 0; } @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) { return 0; } } ContentProvider 和 sql 在实现上有什么区别? ContentProvider 屏蔽了数据存储的细节，内部实现透明化，用户只需关心 uri 即可(是否匹配) ContentProvider 能实现不同 app 的数据共享，sql 只能是自己程序才能访问 Contentprovider 还能增删本地的文件,xml等信息 数据存储 存储方式 说明 SharedPreferences 在键值对中存储私有原始数据 内部存储 在设备内存中存储私有数据 外部存储 在共享的外部存储中存储公共数据 SQLite 数据库 在私有数据库中存储结构化数据 View ViewRoot 对应于 ViewRootImpl 类，它是连接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 Activity 对象被创建完毕后，会将 DecorView 添加到 Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联 View 的整个绘制流程可以分为以下三个阶段： measure: 判断是否需要重新计算 View 的大小，需要的话则计算 layout: 判断是否需要重新计算 View 的位置，需要的话则计算 draw: 判断是否需要重新绘制 View，需要的话则重绘制 MeasureSpec MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec 是 View 类的一个静态内部类，用来说明应该如何测量这个 View Mode 说明 UNSPECIFIED 不指定测量模式, 父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。 EXACTLY 精确测量模式，视图宽高指定为 match_parent 或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值 AT_MOST 最大值测量模式，当视图的宽高指定为 wrap_content 时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸 对于 DecorView 而言，它的MeasureSpec 由窗口尺寸和其自身的 LayoutParams 共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其自身的 LayoutParams 共同决定 childLayoutParams/parentSpecMode EXACTLY AT_MOST dp/px EXACTLY(childSize) EXACTLY(childSize) match_parent EXACTLY(childSize) AT_MOST(parentSize) wrap_content AT_MOST(parentSize) AT_MOST(parentSize) 直接继承 View 的控件需要重写 onMeasure 方法并设置 wrap_content 时的自身大小，因为 View 在布局中使用 wrap_content，那么它的 specMode 是 AT_MOST 模式，在这种模式下，它的宽/高等于父容器当前剩余的空间大小，就相当于使用 match_parent。这解决方式如下： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); // 在 wrap_content 的情况下指定内部宽/高(mWidth 和 mHeight`) if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) { setMeasuredDimension(mWidth, mHeight); } else if (widthSpecMode == MeasureSpec.AT_MOST) { setMeasureDimension(mWidth, heightSpecSize); } else if (heightSpecMode == MeasureSpec.AT_MOST) { setMeasureDimension(widthSpecSize, mHeight); } } MotionEvent 事件 说明 ACTION_DOWN 手指刚接触到屏幕 ACTION_MOVE 手指在屏幕上移动 ACTION_UP 手机从屏幕上松开的一瞬间 ACTION_CANCEL 触摸事件取消 点击屏幕后松开，事件序列为 DOWN -&gt; UP，点击屏幕滑动松开，事件序列为 DOWN -&gt; MOVE -&gt; …&gt; MOVE -&gt; UP。 getX/getY 返回相对于当前View左上角的坐标，getRawX/getRawY 返回相对于屏幕左上角的坐标 TouchSlop是系统所能识别出的被认为滑动的最小距离，不同设备值可能不相同，可通过 ViewConfiguration.get(getContext()).getScaledTouchSlop() 获取。 VelocityTracker VelocityTracker 可用于追踪手指在滑动中的速度： view.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); velocityTracker.computeCurrentVelocity(1000); int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); velocityTracker.clear(); velocityTracker.recycle(); return false; } }); GestureDetector GestureDetector 辅助检测用户的单击、滑动、长按、双击等行为： final GestureDetector mGestureDetector = new GestureDetector(this, new GestureDetector.OnGestureListener() { @Override public boolean onDown(MotionEvent e) { return false; } @Override public void onShowPress(MotionEvent e) { } @Override public boolean onSingleTapUp(MotionEvent e) { return false; } @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { return false; } @Override public void onLongPress(MotionEvent e) { } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { return false; } }); mGestureDetector.setOnDoubleTapListener(new OnDoubleTapListener() { @Override public boolean onSingleTapConfirmed(MotionEvent e) { return false; } @Override public boolean onDoubleTap(MotionEvent e) { return false; } @Override public boolean onDoubleTapEvent(MotionEvent e) { return false; } }); // 解决长按屏幕后无法拖动的问题 mGestureDetector.setIsLongpressEnabled(false); imageView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return mGestureDetector.onTouchEvent(event); } }); 如果是监听滑动相关，建议在 onTouchEvent 中实现，如果要监听双击，那么就使用 GestureDectector。 Scroller 弹性滑动对象，用于实现 View 的弹性滑动，Scroller 本身无法让 View 弹性滑动，需要和 View 的 computeScroll 方法配合使用。startScroll 方法是无法让 View 滑动的，invalidate 会导致 View 重绘，重回后会在 draw 方法中又会去调用 computeScroll 方法，computeScroll 方法又会去向 Scroller 获取当前的 scrollX 和 scrollY，然后通过 scrollTo 方法实现滑动，接着又调用 postInvalidate 方法如此反复。 Scroller mScroller = new Scroller(mContext); private void smoothScrollTo(int destX) { int scrollX = getScrollX(); int delta = destX - scrollX; // 1000ms 内滑向 destX，效果就是慢慢滑动 mScroller.startScroll(scrollX, 0 , delta, 0, 1000); invalidate(); } @Override public void computeScroll() { if (mScroller.computeScrollOffset()) { scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); } } View 的滑动 scrollTo/scrollBy适合对 View 内容的滑动。scrollBy 实际上也是调用了 scrollTo 方法： public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } } } public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } mScrollX的值等于 View 的左边缘和 View 内容左边缘在水平方向的距离，mScrollY的值等于 View 上边缘和 View 内容上边缘在竖直方向的距离。scrollTo 和 scrollBy 只能改变 View 内容的位置而不能改变 View 在布局中的位置。 使用动画操作简单，主要适用于没有交互的 View 和实现复杂的动画效果。 改变布局参数操作稍微复杂，适用于有交互的 View. ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams(); params.width += 100; params.leftMargin += 100; view.requestLayout(); //或者 view.setLayoutParams(params); View 的事件分发 点击事件达到顶级 View(一般是一个 ViewGroup)，会调用 ViewGroup 的 dispatchTouchEvent 方法，如果顶级 ViewGroup 拦截事件即 onInterceptTouchEvent 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。也就是说如果都提供的话，onTouch 会屏蔽掉 onTouchEvent。在 onTouchEvent 中，如果设置了 mOnClickListenser，则 onClick 会被调用。如果顶级 ViewGroup 不拦截事件，则事件会传递给它所在的点击事件链上的子 View，这时子 View 的 dispatchTouchEvent 会被调用。如此循环。 ViewGroup 默认不拦截任何事件。ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，onTouchEvent 方法就会被调用。 View 在可点击状态下，onTouchEvent 默认会消耗事件。 ACTION_DOWN 被拦截了，onInterceptTouchEvent 方法执行一次后，就会留下记号（mFirstTouchTarget == null）那么往后的 ACTION_MOVE 和 ACTION_UP 都会拦截。` 在 Activity 中获取某个 View 的宽高 Activity/View#onWindowFocusChanged// 此时View已经初始化完毕 // 当Activity的窗口得到焦点和失去焦点时均会被调用一次 // 如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用 public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if (hasFocus) { int width = view.getMeasureWidth(); int height = view.getMeasuredHeight(); } } view.post(runnable)// 通过post可以将一个runnable投递到消息队列的尾部，// 然后等待Looper调用次runnable的时候，View也已经初 // 始化好了 protected void onStart() { super.onStart(); view.post(new Runnable() { @Override public void run() { int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); } }); } ViewTreeObserver// 当View树的状态发生改变或者View树内部的View的可见// 性发生改变时，onGlobalLayout方法将被回调 protected void onStart() { super.onStart(); ViewTreeObserver observer = view.getViewTreeObserver(); observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() { @SuppressWarnings(\"deprecation\") @Override public void onGlobalLayout() { view.getViewTreeObserver().removeGlobalOnLayoutListener(this); int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); } }); } Draw 的基本流程 // 绘制基本上可以分为六个步骤 public void draw(Canvas canvas) { ... // 步骤一：绘制View的背景 drawBackground(canvas); ... // 步骤二：如果需要的话，保持canvas的图层，为fading做准备 saveCount = canvas.getSaveCount(); ... canvas.saveLayer(left, top, right, top + length, null, flags); ... // 步骤三：绘制View的内容 onDraw(canvas); ... // 步骤四：绘制View的子View dispatchDraw(canvas); ... // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // 步骤六：绘制View的装饰(例如滚动条等等) onDrawForeground(canvas) } 自定义 View 继承 View 重写 onDraw 方法 主要用于实现一些不规则的效果，静态或者动态地显示一些不规则的图形，即重写 onDraw 方法。采用这种方式需要自己支持 wrap_content，并且 padding 也需要自己处理。 继承 ViewGroup 派生特殊的 Layout 主要用于实现自定义布局，采用这种方式需要合适地处理 ViewGroup 的测量、布局两个过程，并同时处理子元素的测量和布局过程。 继承特定的 View 用于扩张某种已有的View的功能 继承特定的 ViewGroup 用于扩张某种已有的ViewGroup的功能 进程 进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 各类组件元素的清单文件条目&lt;activity&gt;、&lt;service&gt;、&lt;receiver&gt; 和 &lt;provider&gt;—均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。 进程生命周期 1、前台进程 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service（服务已调用 startForeground()） 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()） 托管正执行其 onReceive() 方法的 BroadcastReceiver 2、可见进程 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果 re前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。 托管绑定到可见（或前台）Activity 的 Service 3、服务进程 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。 4、后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。 5、空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\\ 多进程 如果注册的四大组件中的任意一个组件时用到了多进程，运行该组件时，都会创建一个新的 Application 对象。对于多进程重复创建 Application 这种情况，只需要在该类中对当前进程加以判断即可。 public class MyApplication extends Application { @Override public void onCreate() { Log.d(\"MyApplication\", getProcessName(android.os.Process.myPid())); super.onCreate(); } /** * 根据进程 ID 获取进程名 * @param pid 进程id * @return 进程名 */ public String getProcessName(int pid){ ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfoList = am.getRunningAppProcesses(); if (processInfoList == null) { return null; } for (ActivityManager.RunningAppProcessInfo processInfo : processInfoList) { if (processInfo.pid == pid) { return processInfo.processName; } } return null; } } 一般来说，使用多进程会造成以下几个方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences 的可靠性下降 Application 会多次创建 进程存活 OOM_ADJ ADJ级别 取值 解释 UNKNOWN_ADJ 16 一般指将要会缓存进程，无法获取确定值 CACHED_APP_MAX_ADJ 15 不可见进程的adj最大值 CACHED_APP_MIN_ADJ 9 不可见进程的adj最小值 SERVICE_B_AD 8 B List 中的 Service（较老的、使用可能性更小） PREVIOUS_APP_ADJ 7 上一个App的进程(往往通过按返回键) HOME_APP_ADJ 6 Home进程 SERVICE_ADJ 5 服务进程(Service process) HEAVY_WEIGHT_APP_ADJ 4 后台的重量级进程，system/rootdir/init.rc 文件中设置 BACKUP_APP_ADJ 3 备份进程 PERCEPTIBLE_APP_ADJ 2 可感知进程，比如后台音乐播放 VISIBLE_APP_ADJ 1 可见进程(Visible process) FOREGROUND_APP_ADJ 0 前台进程（Foreground process) PERSISTENT_SERVICE_ADJ -11 关联着系统或persistent进程 PERSISTENT_PROC_ADJ -12 系统 persistent 进程，比如telephony SYSTEM_ADJ -16 系统进程 NATIVE_ADJ -17 native进程（不被系统管理） 进程被杀情况 进程保活方案 开启一个像素的 Activity 使用前台服务 多进程相互唤醒 JobSheduler 唤醒 粘性服务 &amp; 与系统服务捆绑 Parcelable 接口 只要实现了 Parcelable 接口，一个类的对象就可以实现序列化并可以通过 Intent 和 Binder 传递。 使用示例 import android.os.Parcel; import android.os.Parcelable; public class User implements Parcelable { private int userId; protected User(Parcel in) { userId = in.readInt(); } public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() { @Override public User createFromParcel(Parcel in) { return new User(in); } @Override public User[] newArray(int size) { return new User[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(userId); } public int getUserId() { return userId; } } 方法说明 Parcel 内部包装了可序列化的数据，可以在 Binder 中自由传输。序列化功能由 writeToParcel 方法完成，最终是通过 Parcel 中的一系列 write 方法完成。反序列化功能由 CREATOR 来完成，通过 Parcel 的一系列 read 方法来完成反序列化过程。 方法 功能 createFromParcel(Parcel in) 从序列化后的对象中创建原始对象 newArray(int size) 创建指定长度的原始对象数组 User(Parcel in) 从序列化后的对象中创建原始对象 writeToParcel(Parcel dest, int flags) 将当前对象写入序列化结构中，其中 flags 标识有两种值：0 或者 1。为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0 describeContents 返回当前对象的内容描述。如果含有文件描述符，返回 1，否则返回 0，几乎所有情况都返回 0 Parcelable 与 Serializable 对比 Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接在内存中读写 Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多 IPC IPC 即 Inter-Process Communication (进程间通信)。Android 基于 Linux，而 Linux 出于安全考虑，不同进程间不能之间操作对方的数据，这叫做“进程隔离”。 在 Linux 系统中，虚拟内存机制为每个进程分配了线性连续的内存空间，操作系统将这种虚拟内存空间映射到物理内存空间，每个进程有自己的虚拟内存空间，进而不能操作其他进程的内存空间，只有操作系统才有权限操作物理内存空间。 进程隔离保证了每个进程的内存安全。 IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输 Bundle 支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景，并且无法做到进程间即时通信 无并发访问情形，交换简单的数据实时性不高的场景 AIDL 功能强大，支持一对多并发通信，支持实时通信 使用稍复杂，需要处理好线程同步 一对多通信且有 RPC 需求 Messenger 功能一般，支持一对多串行通信，支持实时通信 不能很处理高并发清醒，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型 低并发的一对多即时通信，无RPC需求，或者无需返回结果的RPC需求 ContentProvider 在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其他操作 可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作 一对多的进程间数据共享 Socket 可以通过网络传输字节流，支持一对多并发实时通信 实现细节稍微有点烦琐，不支持直接的RPC 网络数据交换 Binder Binder 是 Android 中的一个类，实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种扩进程通信方方式。从 Android 应用层来说，Binder 是客户端和服务器端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象。 Binder 相较于传统 IPC 来说更适合于Android系统，具体原因的包括如下三点： Binder 本身是 C/S 架构的，这一点更符合 Android 系统的架构 性能上更有优势：管道，消息队列，Socket 的通讯都需要两次数据拷贝，而 Binder 只需要一次。要知道，对于系统底层的 IPC 形式，少一次数据拷贝，对整体性能的影响是非常之大的 安全性更好：传统 IPC 形式，无法得到对方的身份标识（UID/GID)，而在使用 Binder IPC 时，这些身份标示是跟随调用过程而自动传递的。Server 端很容易就可以知道 Client 端的身份，非常便于做安全检查 示例： 新建AIDL接口文件 RemoteService.aidl package com.example.mystudyapplication3; interface IRemoteService { int getUserId(); } 系统会自动生成 IRemoteService.java: /* * This file is auto-generated. DO NOT MODIFY. */ package com.example.mystudyapplication3; // Declare any non-default types here with import statements //import com.example.mystudyapplication3.IUserBean; public interface IRemoteService extends android.os.IInterface { /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.mystudyapplication3.IRemoteService { private static final java.lang.String DESCRIPTOR = \"com.example.mystudyapplication3.IRemoteService\"; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.example.mystudyapplication3.IRemoteService interface, * generating a proxy if needed. */ public static com.example.mystudyapplication3.IRemoteService asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.mystudyapplication3.IRemoteService))) { return ((com.example.mystudyapplication3.IRemoteService) iin); } return new com.example.mystudyapplication3.IRemoteService.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getUserId: { data.enforceInterface(descriptor); int _result = this.getUserId(); reply.writeNoException(); reply.writeInt(_result); return true; } default: { return super.onTransact(code, data, reply, flags); } } } private static class Proxy implements com.example.mystudyapplication3.IRemoteService { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public int getUserId() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getUserId, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); } finally { _reply.recycle(); _data.recycle(); } return _result; } } static final int TRANSACTION_getUserId = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); } public int getUserId() throws android.os.RemoteException; } 方法 含义 DESCRIPTOR Binder 的唯一标识，一般用当前的 Binder 的类名表示 asInterface(IBinder obj) 将服务端的 Binder 对象成客户端所需的 AIDL 接口类型对象，这种转换过程是区分进程的，如果位于同一进程，返回的就是 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象。 asBinder 用于返回当前 Binder 对象 onTransact 运行在服务端中的 Binder 线程池中，远程请求会通过系统底层封装后交由此方法来处理 定向 tag 含义 in 数据只能由客户端流向服务端，服务端将会收到客户端对象的完整数据，客户端对象不会因为服务端对传参的修改而发生变动。 out 数据只能由服务端流向客户端，服务端将会收到客户端对象，该对象不为空，但是它里面的字段为空，但是在服务端对该对象作任何修改之后客户端的传参对象都会同步改动。 inout 服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。 流程 AIDL 通信 Android Interface Definition Language 使用示例： 新建AIDL接口文件// RemoteService.aidl package com.example.mystudyapplication3; interface IRemoteService { int getUserId(); } 创建远程服务public class RemoteService extends Service { private int mId = -1; private Binder binder = new IRemoteService.Stub() { @Override public int getUserId() throws RemoteException { return mId; } }; @Nullable @Override public IBinder onBind(Intent intent) { mId = 1256; return binder; } } 声明远程服务&lt;service android:name=\".RemoteService\" android:process=\":aidl\" /&gt; 绑定远程服务public class MainActivity extends AppCompatActivity { public static final String TAG = \"wzq\"; IRemoteService iRemoteService; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { iRemoteService = IRemoteService.Stub.asInterface(service); try { Log.d(TAG, String.valueOf(iRemoteService.getUserId())); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { iRemoteService = null; } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bindService(new Intent(MainActivity.this, RemoteService.class), mConnection, Context.BIND_AUTO_CREATE); } } Messenger Messenger可以在不同进程中传递 Message 对象，在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递了。Messenger 是一种轻量级的 IPC 方案，底层实现是 AIDL。 Window / WindowManager Window 概念与分类 Window 是一个抽象类，它的具体实现是 PhoneWindow。WindowManager 是外界访问 Window 的入口，Window 的具体实现位于 WindowManagerService 中，WindowManager 和 WindowManagerService 的交互是一个 IPC 过程。Android 中所有的视图都是通过 Window 来呈现，因此 Window 实际是 View 的直接管理者。 Window 类型 说明 层级 Application Window 对应着一个 Activity 1~99 Sub Window 不能单独存在，只能附属在父 Window 中，如 Dialog 等 1000~1999 System Window 需要权限声明，如 Toast 和 系统状态栏等 2000~2999 Window 的内部机制 Window 是一个抽象的概念，每一个 Window 对应着一个 View 和一个 ViewRootImpl。Window 实际是不存在的，它是以 View 的形式存在。对 Window 的访问必须通过 WindowManager，WindowManager 的实现类是 WindowManagerImpl： WindowManagerImpl.java @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.updateViewLayout(view, params); } @Override public void removeView(View view) { mGlobal.removeView(view, false); } WindowManagerImpl 没有直接实现 Window 的三大操作，而是全部交给 WindowManagerGlobal 处理，WindowManagerGlobal 以工厂的形式向外提供自己的实例： WindowManagerGlobal.java // 添加 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ··· // 子 Window 的话需要调整一些布局参数 final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) { parentWindow.adjustLayoutParamsForSubWindow(wparams); } else { ··· } ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // 新建一个 ViewRootImpl，并通过其 setView 来更新界面完成 Window 的添加过程 ··· root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) { removeViewLocked(index, true); } throw e; } } } // 删除 @UnsupportedAppUsage public void removeView(View view, boolean immediate) { ··· synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); ··· } } private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } // 更新 public void updateViewLayout(View view, ViewGroup.LayoutParams params) { ··· final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) { int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); } } 在 ViewRootImpl 中最终会通过 WindowSession 来完成 Window 的添加、更新、删除工作，mWindowSession 的类型是 IWindowSession，是一个 Binder 对象，真正地实现类是 Session，是一个 IPC 过程。 Window 的创建过程 Activity 的 Window 创建过程 在 Activity 的创建过程中，最终会由 ActivityThread 的 performLaunchActivity() 来完成整个启动过程，该方法内部会通过类加载器创建 Activity 的实例对象，并调用 attach 方法关联一系列上下文环境变量。在 Activity 的 attach 方法里，系统会创建所属的 Window 对象并设置回调接口，然后在 Activity 的 setContentView 方法中将视图附属在 Window 上： Activity.java final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } ··· } ··· public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } PhoneWindow.java @Override public void setContentView(int layoutResID) { if (mContentParent == null) { // 如果没有 DecorView，就创建 installDecor(); } else { mContentParent.removeAllViews(); } mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { // 回调 Activity 的 onContentChanged 方法通知 Activity 视图已经发生改变 cb.onContentChanged(); } } 这个时候 DecorView 还没有被 WindowManager 正式添加。在 ActivityThread 的 handleResumeActivity 方法中，首先会调用 Activity 的 onResume 方法，接着调用 Activity 的 makeVisible()，完成 DecorView 的添加和显示过程： Activity.java void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } Dialog 的 Window 创建过程 Dialog 的 Window 的创建过程和 Activity 类似，创建同样是通过 PolicyManager 的 makeNewWindow 方法完成的，创建后的对象实际就是 PhoneWindow。当 Dialog 被关闭时，会通过 WindowManager 来移除 DecorView：mWindowManager.removeViewImmediate(mDecor)。 Dialog.java Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ··· mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setOnWindowSwipeDismissedCallback(() -&gt; { if (mCancelable) { cancel(); } }); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 普通 Dialog 必须采用 Activity 的 Context，采用 Application 的 Context 就会报错，是因为应用 token 所导致，应用 token 一般只有 Activity 拥有。系统 Window 比较特殊，不需要 token。 Toast 的 Window 创建过程 Toast 属于系统 Window ，由于其具有定时取消功能，所以系统采用了 Handler。Toast 的内部有两类 IPC 过程，第一类是 Toast 访问 NotificationManagerService，第二类是 NotificationManagerService 回调 Toast 里的 TN 接口。 Toast 内部的视图由两种方式，一种是系统默认的样式，另一种是 setView 指定一个自定义 View，它们都对应 Toast 的一个内部成员 mNextView。 Toast.java public void show() { if (mNextView == null) { throw new RuntimeException(\"setView must have been called\"); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } ··· public void cancel() { mTN.cancel(); } NotificationManagerService.java private void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, \"Show pkg=\" + record.pkg + \" callback=\" + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record, false); return; } catch (RemoteException e) { Slog.w(TAG, \"Object died trying to show notification \" + record.callback + \" in package \" + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } ··· private void scheduleTimeoutLocked(ToastRecord r, boolean immediate) { Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = immediate ? 0 : (r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY); mHandler.removeCallbacksAndMessages(r); mHandler.sendMessageDelayed(m, delay); } Bitmap 配置信息与压缩方式 Bitmap 中有两个内部枚举类： Config 是用来设置颜色配置信息 CompressFormat 是用来设置压缩方式 Config 单位像素所占字节数 解析 Bitmap.Config.ALPHA_8 1 颜色信息只由透明度组成，占8位 Bitmap.Config.ARGB_4444 2 颜色信息由rgba四部分组成，每个部分都占4位，总共占16位 Bitmap.Config.ARGB_8888 4 颜色信息由rgba四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置 Bitmap.Config.RGB_565 2 颜色信息由rgb三部分组成，R占5位，G占6位，B占5位，总共占16位 RGBA_F16 8 Android 8.0 新增（更丰富的色彩表现HDR） HARDWARE Special Android 8.0 新增 （Bitmap直接存储在graphic memory） 通常我们优化 Bitmap 时，当需要做性能优化或者防止 OOM，我们通常会使用 Bitmap.Config.RGB_565 这个配置，因为 Bitmap.Config.ALPHA_8 只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444 显示图片不清楚， Bitmap.Config.ARGB_8888 占用内存最多。 CompressFormat 解析 Bitmap.CompressFormat.JPEG 表示以 JPEG 压缩算法进行图像压缩，压缩后的格式可以是 .jpg 或者 .jpeg，是一种有损压缩 Bitmap.CompressFormat.PNG 颜色信息由 rgba 四部分组成，每个部分都占 4 位，总共占 16 位 Bitmap.Config.ARGB_8888 颜色信息由 rgba 四部分组成，每个部分都占 8 位，总共占 32 位。是 Bitmap 默认的颜色配置信息，也是最占空间的一种配置 Bitmap.Config.RGB_565 颜色信息由 rgb 三部分组成，R 占 5 位，G 占 6 位，B 占 5 位，总共占 16 位 常用操作 裁剪、缩放、旋转、移动 Matrix matrix = new Matrix(); // 缩放 matrix.postScale(0.8f, 0.9f); // 左旋，参数为正则向右旋 matrix.postRotate(-45); // 平移, 在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作 matrix.postTranslate(100, 80); // 裁剪并执行以上操作 Bitmap bitmap = Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true); ```` &gt; 虽然Matrix还可以调用postSkew方法进行倾斜操作，但是却不可以在此时创建Bitmap时使用。 ### Bitmap与Drawable转换 ```java // Drawable -&gt; Bitmap public static Bitmap drawableToBitmap(Drawable drawable) { Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(); drawable.draw(canvas); return bitmap; } // Bitmap -&gt; Drawable public static Drawable bitmapToDrawable(Resources resources, Bitmap bm) { Drawable drawable = new BitmapDrawable(resources, bm); return drawable; } 保存与释放 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test); File file = new File(getFilesDir(),\"test.jpg\"); if(file.exists()){ file.delete(); } try { FileOutputStream outputStream=new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG,90,outputStream); outputStream.flush(); outputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } //释放bitmap的资源，这是一个不可逆转的操作 bitmap.recycle(); 图片压缩 public static Bitmap compressImage(Bitmap image) { if (image == null) { return null; } ByteArrayOutputStream baos = null; try { baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos); byte[] bytes = baos.toByteArray(); ByteArrayInputStream isBm = new ByteArrayInputStream(bytes); Bitmap bitmap = BitmapFactory.decodeStream(isBm); return bitmap; } catch (OutOfMemoryError e) { e.printStackTrace(); } finally { try { if (baos != null) { baos.close(); } } catch (IOException e) { e.printStackTrace(); } } return null; } BitmapFactory Bitmap创建流程 Option类 常用方法 说明 boolean inJustDecodeBounds 如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息 int inSampleSize 图片缩放的倍数 int outWidth 获取图片的宽度值 int outHeight 获取图片的高度值 int inDensity 用于位图的像素压缩比 int inTargetDensity 用于目标位图的像素压缩比（要生成的位图） byte[] inTempStorage 创建临时文件，将图片存储 boolean inScaled 设置为true时进行图片压缩，从inDensity到inTargetDensity boolean inDither 如果为true,解码器尝试抖动解码 Bitmap.Config inPreferredConfig 设置解码器这个值是设置色彩模式，默认值是ARGB_8888，在这个模式下，一个像素点占用4bytes空间，一般对透明度不做要求的话，一般采用RGB_565模式，这个模式下一个像素点占用2bytes String outMimeType 设置解码图像 boolean inPurgeable 当存储Pixel的内存空间在系统内存不足时是否可以被回收 boolean inInputShareable inPurgeable为true情况下才生效，是否可以共享一个InputStream boolean inPreferQualityOverSpeed 为true则优先保证Bitmap质量其次是解码速度 boolean inMutable 配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段 int inScreenDensity 当前屏幕的像素密度 基本使用 try { FileInputStream fis = new FileInputStream(filePath); BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; // 设置inJustDecodeBounds为true后，再使用decodeFile()等方法，并不会真正的分配空间，即解码出来的Bitmap为null，但是可计算出原始图片的宽度和高度，即options.outWidth和options.outHeight BitmapFactory.decodeFileDescriptor(fis.getFD(), null, options); float srcWidth = options.outWidth; float srcHeight = options.outHeight; int inSampleSize = 1; if (srcHeight &gt; height || srcWidth &gt; width) { if (srcWidth &gt; srcHeight) { inSampleSize = Math.round(srcHeight / height); } else { inSampleSize = Math.round(srcWidth / width); } } options.inJustDecodeBounds = false; options.inSampleSize = inSampleSize; return BitmapFactory.decodeFileDescriptor(fis.getFD(), null, options); } catch (Exception e) { e.printStackTrace(); } 内存回收 if(bitmap != null &amp;&amp; !bitmap.isRecycled()){ // 回收并且置为null bitmap.recycle(); bitmap = null; } Bitmap 类的构造方法都是私有的，所以开发者不能直接 new 出一个 Bitmap 对象，只能通过 BitmapFactory 类的各种静态方法来实例化一个 Bitmap。仔细查看 BitmapFactory 的源代码可以看到，生成 Bitmap 对象最终都是通过 JNI 调用方式实现的。所以，加载 Bitmap 到内存里以后，是包含两部分内存区域的。简单的说，一部分是Java 部分的，一部分是 C 部分的。这个 Bitmap 对象是由 Java 部分分配的，不用的时候系统就会自动回收了，但是那个对应的 C 可用的内存区域，虚拟机是不能直接回收的，这个只能调用底层的功能释放。所以需要调用 recycle() 方法来释放 C 部分的内存。从 Bitmap 类的源代码也可以看到，recycle() 方法里也的确是调用了 JNI 方法了的。 屏幕适配 单位 dpi每英寸像素数(dot per inch) dp密度无关像素 - 一种基于屏幕物理密度的抽象单元。 这些单位相对于 160 dpi 的屏幕，因此一个 dp 是 160 dpi 屏幕上的一个 px。 dp 与像素的比率将随着屏幕密度而变化，但不一定成正比。为不同设备的 UI 元素的实际大小提供了一致性。 sp与比例无关的像素 - 这与 dp 单位类似，但它也可以通过用户的字体大小首选项进行缩放。建议在指定字体大小时使用此单位，以便根据屏幕密度和用户偏好调整它们。 dpi = px / inch density = dpi / 160 dp = px / density 头条适配方案 private static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application) { final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics(); if (sNoncompatDensity == 0) { sNoncompatDensity = appDisplayMetrics.density; sNoncompatScaledDensity = appDisplayMetrics.scaledDensity; // 监听字体切换 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) { sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); } // 适配后的dpi将统一为360dpi final float targetDensity = appDisplayMetrics.widthPixels / 360; final float targetScaledDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity); final int targetDensityDpi = (int)(160 * targetDensity); appDisplayMetrics.density = targetDensity; appDisplayMetrics.scaledDensity = targetScaledDensity; appDisplayMetrics.densityDpi = targetDensityDpi; final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics(); activityDisplayMetrics.density = targetDensity; activityDisplayMetrics.scaledDensity = targetScaledDensity; activityDisplayMetrics.densityDpi = targetDensityDpi } 刘海屏适配 Android P 刘海屏适配方案 Android P 支持最新的全面屏以及为摄像头和扬声器预留空间的凹口屏幕。通过全新的 DisplayCutout 类，可以确定非功能区域的位置和形状，这些区域不应显示内容。要确定这些凹口屏幕区域是否存在及其位置，使用 getDisplayCutout() 函数。 DisplayCutout 类方法 说明 getBoundingRects() 返回Rects的列表，每个Rects都是显示屏上非功能区域的边界矩形 getSafeInsetLeft () 返回安全区域距离屏幕左边的距离，单位是px getSafeInsetRight () 返回安全区域距离屏幕右边的距离，单位是px getSafeInsetTop () 返回安全区域距离屏幕顶部的距离，单位是px getSafeInsetBottom() 返回安全区域距离屏幕底部的距离，单位是px Android P 中 WindowManager.LayoutParams 新增了一个布局参数属性 layoutInDisplayCutoutMode： 模式 模式说明 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 只有当DisplayCutout完全包含在系统栏中时，才允许窗口延伸到DisplayCutout区域。 否则，窗口布局不与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 该窗口决不允许与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 Android P 之前的刘海屏适配 不同厂商的刘海屏适配方案不尽相同，需分别查阅各自的开发者文档。 Context Context 本身是一个抽象类，是对一系列系统服务接口的封装，包括：内部资源、包、类加载、I/O操作、权限、主线程、IPC 和组件启动等操作的管理。ContextImpl, Activity, Service, Application 这些都是 Context 的直接或间接子类, 关系如下: ContextWrapper是代理Context的实现，简单地将其所有调用委托给另一个Context（mBase）。 Application、Activity、Service通过attach() 调用父类ContextWrapper的attachBaseContext(), 从而设置父类成员变量 mBase 为 ContextImpl 对象, ContextWrapper 的核心工作都是交给 mBase(ContextImpl) 来完成，这样可以子类化 Context 以修改行为而无需更改原始 Context。 SharedPreferences SharedPreferences 采用key-value（键值对）形式, 主要用于轻量级的数据存储, 尤其适合保存应用的配置参数, 但不建议使用 SharedPreferences 来存储大规模的数据, 可能会降低性能. SharedPreferences采用xml文件格式来保存数据, 该文件所在目录位于 /data/data/&lt;package name&gt;/shared_prefs，如： &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt; &lt;map&gt; &lt;string name=\"blog\"&gt;https://github.com/JasonWu1111/Android-Review&lt;/string&gt; &lt;/map&gt; 从Android N开始, 创建的 SP 文件模式, 不允许 MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 模块, 否则会直接抛出异常 SecurityException。 MODE_MULTI_PROCESS 这种多进程的方式也是 Google 不推荐的方式, 后续同样会不再支持。 当设置 MODE_MULTI_PROCESS 模式, 则每次 getSharedPreferences 过程, 会检查 SP 文件上次修改时间和文件大小, 一旦所有修改则会重新从磁盘加载文件。 获取方式 getPreferences Activity.getPreferences(mode): 以当前 Activity 的类名作为 SP 的文件名. 即 xxxActivity.xmlActivity.java public SharedPreferences getPreferences(int mode) { return getSharedPreferences(getLocalClassName(), mode); } getDefaultSharedPreferences PreferenceManager.getDefaultSharedPreferences(Context): 以包名加上 _preferences 作为文件名, 以 MODE_PRIVATE 模式创建 SP 文件. 即 packgeName_preferences.xml. public static SharedPreferences getDefaultSharedPreferences(Context context) { return context.getSharedPreferences(getDefaultSharedPreferencesName(context), getDefaultSharedPreferencesMode()); } getSharedPreferences 直接调用 Context.getSharedPreferences(name, mode)，所有的方法最终都是调用到如下方法： class ContextImpl extends Context { private ArrayMap&lt;String, File&gt; mSharedPrefsPaths; public SharedPreferences getSharedPreferences(String name, int mode) { File file; synchronized (ContextImpl.class) { if (mSharedPrefsPaths == null) { mSharedPrefsPaths = new ArrayMap&lt;&gt;(); } //先从mSharedPrefsPaths查询是否存在相应文件 file = mSharedPrefsPaths.get(name); if (file == null) { //如果文件不存在, 则创建新的文件 file = getSharedPreferencesPath(name); mSharedPrefsPaths.put(name, file); } } return getSharedPreferences(file, mode); } } 架构 SharedPreferences 与 Editor 只是两个接口. SharedPreferencesImpl 和 EditorImpl 分别实现了对应接口。另外, ContextImpl 记录着 SharedPreferences 的重要数据。 putxxx() 操作把数据写入到EditorImpl.mModified； apply()/commit() 操作先调用 commitToMemory(), 将数据同步到 SharedPreferencesImpl 的 mMap, 并保存到 MemoryCommitResult 的 mapToWriteToDisk，再调用 enqueueDiskWrite(), 写入到磁盘文件; 先之前把原有数据保存到 .bak 为后缀的文件,用于在写磁盘的过程出现任何异常可恢复数据; getxxx() 操作从 SharedPreferencesImpl.mMap 读取数据. apply / commit apply 没有返回值, commit 有返回值能知道修改是否提交成功 apply 是将修改提交到内存，再异步提交到磁盘文件，而 commit 是同步的提交到磁盘文件 多并发的提交 commit 时，需等待正在处理的 commit 数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而 apply 只是原子更新到内存，后调用 apply 函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 注意 强烈建议不要在 sp 里面存储特别大的 key/value，有助于减少卡顿 / anr 不要高频地使用 apply，尽可能地批量提交 不要使用 MODE_MULTI_PROCESS 高频写操作的 key 与高频读操作的 key 可以适当地拆分文件，由于减少同步锁竞争 不要连续多次 edit()，应该获取一次获取 edit()，然后多次执行 putxxx()，减少内存波动 消息机制 Handler 机制 Handler 有两个主要用途：（1）安排 Message 和 runnables 在将来的某个时刻执行; （2）将要在不同于自己的线程上执行的操作排入队列。(在多个线程并发更新UI的同时保证线程安全。) Android 规定访问 UI 只能在主线程中进行，因为 Android 的 UI 控件不是线程安全的，多线程并发访问会导致 UI 控件处于不可预期的状态。为什么系统不对 UI 控件的访问加上锁机制？缺点有两个：加锁会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率。如果子线程访问 UI，那么程序就会抛出异常。ViewRootImpl 对UI操作做了验证，这个验证工作是由 ViewRootImpl的 checkThread 方法完成： ViewRootImpl.java void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); } } Message：Handler 接收和处理的消息对象 MessageQueue：Message 的队列，先进先出，每一个线程最多可以拥有一个 Looper：消息泵，是 MessageQueue 的管理者，会不断从 MessageQueue 中取出消息，并将消息分给对应的 Handler 处理，每个线程只有一个 Looper。 Handler 创建的时候会采用当前线程的 Looper 来构造消息循环系统，需要注意的是，线程默认是没有 Looper 的，直接使用 Handler 会报错，如果需要使用 Handler 就必须为线程创建 Looper，因为默认的 UI 主线程，也就是 ActivityThread，ActivityThread 被创建的时候就会初始化 Looper，这也是在主线程中默认可以使用 Handler 的原因。 工作原理 ThreadLocal ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，其他线程则无法获取。Looper、ActivityThread 以及 AMS 中都用到了 ThreadLocal。当不同线程访问同一个ThreadLocal 的 get方法，ThreadLocal 内部会从各自的线程中取出一个数组，然后再从数组中根据当前 ThreadLcoal 的索引去查找对应的value值。ThreadLocal.java public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ··· public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } MessageQueue MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别是 enqueueMessage 和 next。MessageQueue 内部实现并不是用的队列，实际上通过一个单链表的数据结构来维护消息列表。next 方法是一个无限循环的方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新消息到来时，next 方法会放回这条消息并将其从单链表中移除。 MessageQueue.java boolean enqueueMessage(Message msg, long when) { ··· synchronized (this) { ··· msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } ··· Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. ··· for (;;) { ··· synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } ··· } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } Looper Looper 会不停地从 MessageQueue 中 查看是否有新消息，如果有新消息就会立刻处理，否则会一直阻塞。Looper.java private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 可通过 Looper.prepare() 为当前线程创建一个 Looper： new Thread(\"Thread#2\") { @Override public void run() { Looper.prepare(); Handler handler = new Handler(); Looper.loop(); } }.start(); 除了 prepare 方法外，Looper 还提供了 prepareMainLooper 方法，主要是给 ActivityThread 创建 Looper 使用，本质也是通过 prepare 方法实现的。由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLooper 方法来获取主线程的 Looper。 Looper 提供了 quit 和 quitSafely 来退出一个 Looper，二者的区别是：quit 会直接退出 Looper，而 quitSafly 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper 退出后，通过 Handler 发送的消息会失败，这个时候 Handler 的 send 方法会返回 false。因此在不需要的时候应终止 Looper。 Looper.java public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; ··· for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } ··· try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } ··· msg.recycleUnchecked(); } } loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了null。当 Looper 的 quit 方法被调用时，Looper就会调用 MessageQueue 的 quit 或者 qutiSafely 方法来通知消息队列退出，当消息队列被标记为退出状态时，它的 next 方法就会返回 null。loop 方法会调用 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 会一直阻塞，导致 loop 方法一直阻塞。Looper 处理这条消息： msg.target.dispatchMessage(msg)，这里的 msg.target 是发送这条消息的 Handler 对象。 Handler Handler 的工作主要包含消息的发送和接收的过程。消息的发送可以通过 post/send 的一系列方法实现，post 最终也是通过send来实现的。 线程异步 线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 应用启动时，系统会为应用创建一个名为“主线程”的执行线程( UI 线程)。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。 系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。 Android 的单线程模式必须遵守两条规则: 不要阻塞 UI 线程 不要在 UI 线程之外访问 Android UI 工具包 为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程: Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) AsyncTask AsyncTask 封装了 Thread 和 Handler，并不适合特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。 基本使用 方法 说明 onPreExecute() 异步任务执行前调用，用于做一些准备工作 doInBackground(Params…params) 用于执行异步任务，此方法中可以通过 publishProgress 方法来更新任务的进度，publishProgress 会调用 onProgressUpdate 方法 onProgressUpdate 在主线程中执行，后台任务的执行进度发生改变时调用 onPostExecute 在主线程中执行，在异步任务执行之后 import android.os.AsyncTask; public class DownloadTask extends AsyncTask&lt;String, Integer, Boolean&gt; { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected Boolean doInBackground(String... strings) { return null; } @Override protected void onProgressUpdate(Integer... values) { super.onProgressUpdate(values); } @Override protected void onPostExecute(Boolean aBoolean) { super.onPostExecute(aBoolean); } } 异步任务的实例必须在 UI 线程中创建，即 AsyncTask 对象必须在UI线程中创建。 execute(Params… params)方法必须在UI线程中调用。 不要手动调用 onPreExecute()，doInBackground()，onProgressUpdate()，onPostExecute() 这几个方法。 不能在 doInBackground() 中更改UI组件的信息。 一个任务实例只能执行一次，如果执行第二次将会抛出异常。 execute() 方法会让同一个进程中的 AsyncTask 串行执行，如果需要并行，可以调用 executeOnExcutor 方法。 工作原理 AsyncTask.java @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } sDefaultExecutor 是一个串行的线程池，一个进程中的所有的 AsyncTask 全部在该线程池中执行。AysncTask 中有两个线程池（SerialExecutor 和 THREAD_POOL_EXECUTOR）和一个 Handler（InternalHandler），其中线程池 SerialExecutor 用于任务的排队，THREAD_POOL_EXECUTOR 用于真正地执行任务，InternalHandler 用于将执行环境从线程池切换到主线程。 AsyncTask.java private static Handler getMainHandler() { synchronized (AsyncTask.class) { if (sHandler == null) { sHandler = new InternalHandler(Looper.getMainLooper()); } return sHandler; } } private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } private Result postResult(Result result) { @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } HandlerThread HandlerThread 集成了 Thread，却和普通的 Thread 有显著的不同。普通的 Thread 主要用于在 run 方法中执行一个耗时任务，而 HandlerThread 在内部创建了消息队列，外界需要通过 Handler 的消息方式通知 HanderThread 执行一个具体的任务。 HandlerThread.java @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } IntentService IntentService 可用于执行后台耗时的任务，当任务执行后会自动停止，由于其是 Service 的原因，它的优先级比单纯的线程要高，所以 IntentService 适合执行一些高优先级的后台任务。在实现上，IntentService 封装了 HandlerThread 和 Handler。 IntentService.java @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } IntentService 第一次启动时，会在 onCreatea 方法中创建一个 HandlerThread，然后使用的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。每次启动 IntentService，它的 onStartCommand 方法就会调用一次，onStartCommand 中处理每个后台任务的 Intent，onStartCommand 调用了 onStart 方法： IntentService.java private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } ··· @Override public void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 可以看出，IntentService 仅仅是通过 mServiceHandler 发送了一个消息，这个消息会在 HandlerThread 中被处理。mServiceHandler 收到消息后，会将 Intent 对象传递给 onHandlerIntent 方法中处理，执行结束后，通过 stopSelf(int startId) 来尝试停止服务。（stopSelf() 会立即停止服务，而 stopSelf(int startId) 则会等待所有的消息都处理完毕后才终止服务）。 线程池 线程池的优点有以下： 重用线程池中的线程，避免因为线程的创建和销毁带来性能开销。 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。 能够对线程进行管理，并提供定时执行以及定间隔循环执行等功能。 java 中，ThreadPoolExecutor 是线程池的真正实现： ThreadPoolExecutor.java /** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters. * * @param corePoolSize 核心线程数 * @param maximumPoolSize 最大线程数 * @param keepAliveTime 非核心线程闲置的超时时长 * @param unit 用于指定 keepAliveTime 参数的时间单位 * @param 任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个参数中 * @param threadFactory 线程工厂，用于创建新线程 * @param handler 任务队列已满或者是无法成功执行任务时调用 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { ··· } 类型 创建方法 说明 FixedThreadPool Executors.newFixedThreadPool(int nThreads) 一种线程数量固定的线程池，只有核心线程并且不会被回收，没有超时机制 CachedThreadPool Executors.newCachedThreadPool() 一种线程数量不定的线程池，只有非核心线程，当线程都处于活动状态时，会创建新线程来处理新任务，否则会利用空闲的线程，超时时长为60s ScheduledThreadPool Executors.newScheduledThreadPool(int corePoolSize) 核心线程数是固定的，非核心线程数没有限制，非核心线程闲置时立刻回收，主要用于执行定时任务和固定周期的重复任务 SingleThreadExecutor Executors.newSingleThreadExecutor() 只有一个核心线程，确保所有任务在同一线程中按顺序执行 RecyclerView 优化 数据处理和视图加载分离：数据的处理逻辑尽可能放在异步处理，onBindViewHolder 方法中只处理数据填充到视图中。 数据优化：分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。 示例 public class AdapterDiffCallback extends DiffUtil.Callback { private List&lt;String&gt; mOldList; private List&lt;String&gt; mNewList; public AdapterDiffCallback(List&lt;String&gt; oldList, List&lt;String&gt; newList) { mOldList = oldList; mNewList = newList; DiffUtil.DiffResult } @Override public int getOldListSize() { return mOldList.size(); } @Override public int getNewListSize() { return mNewList.size(); } @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) { return mOldList.get(oldItemPosition).getClass().equals(mNewList.get(newItemPosition).getClass()); } @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) { return mOldList.get(oldItemPosition).equals(mNewList.get(newItemPosition)); } } DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new AdapterDiffCallback(oldList, newList)); diffResult.dispatchUpdatesTo(mAdapter); 布局优化：减少布局层级，简化 ItemView 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool)，来共用一个 RecycledViewPool。 Webview 基本使用 WebView // 获取当前页面的URL public String getUrl(); // 获取当前页面的原始URL(重定向后可能当前url不同) // 就是http headers的Referer参数，loadUrl时为null public String getOriginalUrl(); // 获取当前页面的标题 public String getTitle(); // 获取当前页面的favicon public Bitmap getFavicon(); // 获取当前页面的加载进度 public int getProgress(); // 通知WebView内核网络状态 // 用于设置JS属性`window.navigator.isOnline`和产生HTML5事件`online/offline` public void setNetworkAvailable(boolean networkUp) // 设置初始缩放比例 public void setInitialScale(int scaleInPercent)； WebSettings WebSettings settings = web.getSettings(); // 存储(storage) // 启用HTML5 DOM storage API，默认值 false settings.setDomStorageEnabled(true); // 启用Web SQL Database API，这个设置会影响同一进程内的所有WebView，默认值 false // 此API已不推荐使用，参考：https://www.w3.org/TR/webdatabase/ settings.setDatabaseEnabled(true); // 启用Application Caches API，必需设置有效的缓存路径才能生效，默认值 false // 此API已废弃，参考：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache settings.setAppCacheEnabled(true); settings.setAppCachePath(context.getCacheDir().getAbsolutePath()); // 定位(location) settings.setGeolocationEnabled(true); // 是否保存表单数据 settings.setSaveFormData(true); // 是否当webview调用requestFocus时为页面的某个元素设置焦点，默认值 true settings.setNeedInitialFocus(true); // 是否支持viewport属性，默认值 false // 页面通过`&lt;meta name=\"viewport\" ... /&gt;`自适应手机屏幕 settings.setUseWideViewPort(true); // 是否使用overview mode加载页面，默认值 false // 当页面宽度大于WebView宽度时，缩小使页面宽度等于WebView宽度 settings.setLoadWithOverviewMode(true); // 布局算法 settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NORMAL); // 是否支持Javascript，默认值false settings.setJavaScriptEnabled(true); // 是否支持多窗口，默认值false settings.setSupportMultipleWindows(false); // 是否可用Javascript(window.open)打开窗口，默认值 false settings.setJavaScriptCanOpenWindowsAutomatically(false); // 资源访问 settings.setAllowContentAccess(true); // 是否可访问Content Provider的资源，默认值 true settings.setAllowFileAccess(true); // 是否可访问本地文件，默认值 true // 是否允许通过file url加载的Javascript读取本地文件，默认值 false settings.setAllowFileAccessFromFileURLs(false); // 是否允许通过file url加载的Javascript读取全部资源(包括文件,http,https)，默认值 false settings.setAllowUniversalAccessFromFileURLs(false); // 资源加载 settings.setLoadsImagesAutomatically(true); // 是否自动加载图片 settings.setBlockNetworkImage(false); // 禁止加载网络图片 settings.setBlockNetworkLoads(false); // 禁止加载所有网络资源 // 缩放(zoom) settings.setSupportZoom(true); // 是否支持缩放 settings.setBuiltInZoomControls(false); // 是否使用内置缩放机制 settings.setDisplayZoomControls(true); // 是否显示内置缩放控件 // 默认文本编码，默认值 \"UTF-8\" settings.setDefaultTextEncodingName(\"UTF-8\"); settings.setDefaultFontSize(16); // 默认文字尺寸，默认值16，取值范围1-72 settings.setDefaultFixedFontSize(16); // 默认等宽字体尺寸，默认值16 settings.setMinimumFontSize(8); // 最小文字尺寸，默认值 8 settings.setMinimumLogicalFontSize(8); // 最小文字逻辑尺寸，默认值 8 settings.setTextZoom(100); // 文字缩放百分比，默认值 100 // 字体 settings.setStandardFontFamily(\"sans-serif\"); // 标准字体，默认值 \"sans-serif\" settings.setSerifFontFamily(\"serif\"); // 衬线字体，默认值 \"serif\" settings.setSansSerifFontFamily(\"sans-serif\"); // 无衬线字体，默认值 \"sans-serif\" settings.setFixedFontFamily(\"monospace\"); // 等宽字体，默认值 \"monospace\" settings.setCursiveFontFamily(\"cursive\"); // 手写体(草书)，默认值 \"cursive\" settings.setFantasyFontFamily(\"fantasy\"); // 幻想体，默认值 \"fantasy\" if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { // 用户是否需要通过手势播放媒体(不会自动播放)，默认值 true settings.setMediaPlaybackRequiresUserGesture(true); } if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { // 5.0以上允许加载http和https混合的页面(5.0以下默认允许，5.0+默认禁止) settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); } if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { // 是否在离开屏幕时光栅化(会增加内存消耗)，默认值 false settings.setOffscreenPreRaster(false); } if (isNetworkConnected(context)) { // 根据cache-control决定是否从网络上取数据 settings.setCacheMode(WebSettings.LOAD_DEFAULT); } else { // 没网，离线加载，优先加载缓存(即使已经过期) settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); } // deprecated settings.setRenderPriority(WebSettings.RenderPriority.HIGH); settings.setDatabasePath(context.getDir(\"database\", Context.MODE_PRIVATE).getPath()); settings.setGeolocationDatabasePath(context.getFilesDir().getPath()); WebViewClient // 拦截页面加载，返回true表示宿主app拦截并处理了该url，否则返回false由当前WebView处理 // 此方法在API24被废弃，不处理POST请求 public boolean shouldOverrideUrlLoading(WebView view, String url) { return false; } // 拦截页面加载，返回true表示宿主app拦截并处理了该url，否则返回false由当前WebView处理 // 此方法添加于API24，不处理POST请求，可拦截处理子frame的非http请求 @TargetApi(Build.VERSION_CODES.N) public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { return shouldOverrideUrlLoading(view, request.getUrl().toString()); } // 此方法废弃于API21，调用于非UI线程 // 拦截资源请求并返回响应数据，返回null时WebView将继续加载资源 public WebResourceResponse shouldInterceptRequest(WebView view, String url) { return null; } // 此方法添加于API21，调用于非UI线程 // 拦截资源请求并返回数据，返回null时WebView将继续加载资源 @TargetApi(Build.VERSION_CODES.LOLLIPOP) public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) { return shouldInterceptRequest(view, request.getUrl().toString()); } // 页面(url)开始加载 public void onPageStarted(WebView view, String url, Bitmap favicon) { } // 页面(url)完成加载 public void onPageFinished(WebView view, String url) { } // 将要加载资源(url) public void onLoadResource(WebView view, String url) { } // 这个回调添加于API23，仅用于主框架的导航 // 通知应用导航到之前页面时，其遗留的WebView内容将不再被绘制。 // 这个回调可以用来决定哪些WebView可见内容能被安全地回收，以确保不显示陈旧的内容 // 它最早被调用，以此保证WebView.onDraw不会绘制任何之前页面的内容，随后绘制背景色或需要加载的新内容。 // 当HTTP响应body已经开始加载并体现在DOM上将在随后的绘制中可见时，这个方法会被调用。 // 这个回调发生在文档加载的早期，因此它的资源(css,和图像)可能不可用。 // 如果需要更细粒度的视图更新，查看 postVisualStateCallback(long, WebView.VisualStateCallback). // 请注意这上边的所有条件也支持 postVisualStateCallback(long ,WebView.VisualStateCallback) public void onPageCommitVisible(WebView view, String url) { } // 此方法废弃于API23 // 主框架加载资源时出错 public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) { } // 此方法添加于API23 // 加载资源时出错，通常意味着连接不到服务器 // 由于所有资源加载错误都会调用此方法，所以此方法应尽量逻辑简单 @TargetApi(Build.VERSION_CODES.M) public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) { if (request.isForMainFrame()) { onReceivedError(view, error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString()); } } // 此方法添加于API23 // 在加载资源(iframe,image,js,css,ajax...)时收到了 HTTP 错误(状态码&gt;=400) public void onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse) { } // 是否重新提交表单，默认不重发 public void onFormResubmission(WebView view, Message dontResend, Message resend) { dontResend.sendToTarget(); } // 通知应用可以将当前的url存储在数据库中，意味着当前的访问url已经生效并被记录在内核当中。 // 此方法在网页加载过程中只会被调用一次，网页前进后退并不会回调这个函数。 public void doUpdateVisitedHistory(WebView view, String url, boolean isReload) { } // 加载资源时发生了一个SSL错误，应用必需响应(继续请求或取消请求) // 处理决策可能被缓存用于后续的请求，默认行为是取消请求 public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) { handler.cancel(); } // 此方法添加于API21，在UI线程被调用 // 处理SSL客户端证书请求，必要的话可显示一个UI来提供KEY。 // 有三种响应方式：proceed()/cancel()/ignore()，默认行为是取消请求 // 如果调用proceed()或cancel()，Webview 将在内存中保存响应结果且对相同的\"host:port\"不会再次调用 onReceivedClientCertRequest // 多数情况下，可通过KeyChain.choosePrivateKeyAlias启动一个Activity供用户选择合适的私钥 @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void onReceivedClientCertRequest(WebView view, ClientCertRequest request) { request.cancel(); } // 处理HTTP认证请求，默认行为是取消请求 public void onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm) { handler.cancel(); } // 通知应用有个已授权账号自动登陆了 public void onReceivedLoginRequest(WebView view, String realm, String account, String args) { } // 给应用一个机会处理按键事件 // 如果返回true，WebView不处理该事件，否则WebView会一直处理，默认返回false public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) { return false; } // 处理未被WebView消费的按键事件 // WebView总是消费按键事件，除非是系统按键或shouldOverrideKeyEvent返回true // 此方法在按键事件分派时被异步调用 public void onUnhandledKeyEvent(WebView view, KeyEvent event) { super.onUnhandledKeyEvent(view, event); } // 通知应用页面缩放系数变化 public void onScaleChanged(WebView view, float oldScale, float newScale) { } WebChromeClient // 获得所有访问历史项目的列表，用于链接着色。 public void getVisitedHistory(ValueCallback&lt;String[]&gt; callback) { } // &lt;video /&gt; 控件在未播放时，会展示为一张海报图，HTML中可通过它的'poster'属性来指定。 // 如果未指定'poster'属性，则通过此方法提供一个默认的海报图。 public Bitmap getDefaultVideoPoster() { return null; } // 当全屏的视频正在缓冲时，此方法返回一个占位视图(比如旋转的菊花)。 public View getVideoLoadingProgressView() { return null; } // 接收当前页面的加载进度 public void onProgressChanged(WebView view, int newProgress) { } // 接收文档标题 public void onReceivedTitle(WebView view, String title) { } // 接收图标(favicon) public void onReceivedIcon(WebView view, Bitmap icon) { } // Android中处理Touch Icon的方案 // http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/index.html public void onReceivedTouchIconUrl(WebView view, String url, boolean precomposed) { } // 通知应用当前页进入了全屏模式，此时应用必须显示一个包含网页内容的自定义View public void onShowCustomView(View view, CustomViewCallback callback) { } // 通知应用当前页退出了全屏模式，此时应用必须隐藏之前显示的自定义View public void onHideCustomView() { } // 显示一个alert对话框 public boolean onJsAlert(WebView view, String url, String message, JsResult result) { return false; } // 显示一个confirm对话框 public boolean onJsConfirm(WebView view, String url, String message, JsResult result) { return false; } // 显示一个prompt对话框 public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) { return false; } // 显示一个对话框让用户选择是否离开当前页面 public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) { return false; } // 指定源的网页内容在没有设置权限状态下尝试使用地理位置API。 // 从API24开始，此方法只为安全的源(https)调用，非安全的源会被自动拒绝 public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) { } // 当前一个调用 onGeolocationPermissionsShowPrompt() 取消时，隐藏相关的UI。 public void onGeolocationPermissionsHidePrompt() { } // 通知应用打开新窗口 public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) { return false; } // 通知应用关闭窗口 public void onCloseWindow(WebView window) { } // 请求获取取焦点 public void onRequestFocus(WebView view) { } // 通知应用网页内容申请访问指定资源的权限(该权限未被授权或拒绝) @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void onPermissionRequest(PermissionRequest request) { request.deny(); } // 通知应用权限的申请被取消，隐藏相关的UI。 @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void onPermissionRequestCanceled(PermissionRequest request) { } // 为'&lt;input type=\"file\" /&gt;'显示文件选择器，返回false使用默认处理 @TargetApi(Build.VERSION_CODES.LOLLIPOP) public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) { return false; } // 接收JavaScript控制台消息 public boolean onConsoleMessage(ConsoleMessage consoleMessage) { return false; } Webview 加载优化 使用本地资源替代 可以 将一些资源文件放在本地的 asset s目录, 然后重 写WebViewClient 的 shouldInterceptRequest 方法，对访问地址进行拦截，当 url 地址命中本地配置的url时，使用本地资源替代，否则就使用网络上的资源。 mWebview.setWebViewClient(new WebViewClient() { // 设置不用系统浏览器打开, @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } @Override public WebResourceResponse shouldInterceptRequest(WebView view, String url) { // 如果命中本地资源, 使用本地资源替代 if (mDataHelper.hasLocalResource(url)){ WebResourceResponse response = mDataHelper.getReplacedWebResourceResponse(getApplicationContext(), url); if (response != null) { return response; } } return super.shouldInterceptRequest(view, url); } @TargetApi(VERSION_CODES.LOLLIPOP)@Override public WebResourceResponse shouldInterceptRequest(WebView view,WebResourceRequest request) { String url = request.getUrl().toString(); if (mDataHelper.hasLocalResource(url)) { WebResourceResponse response = mDataHelper.getReplacedWebResourceResponse(getApplicationContext(), url); if (response != null) { return response; } } return super.shouldInterceptRequest(view, request); } }); WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。 后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。 脚本执行慢，就让脚本在最后运行，不阻塞页面解析。 同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。 WebView初始化慢，就随时初始化好一个WebView待用。 DNS和链接慢，想办法复用客户端使用的域名和链接。 脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。 内存泄漏 直接 new WebView 并传入 application context 代替在 XML 里面声明以防止 activity 引用被滥用，能解决90+%的 WebView 内存泄漏。 vWeb = new WebView(getContext().getApplicationContext()); container.addView(vWeb); 销毁 WebView if (vWeb != null) { vWeb.setWebViewClient(null); vWeb.setWebChromeClient(null); vWeb.loadDataWithBaseURL(null, \"\", \"text/html\", \"utf-8\", null); vWeb.clearHistory(); ((ViewGroup) vWeb.getParent()).removeView(vWeb); vWeb.destroy(); vWeb = null; }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"计算机网络基础","slug":"docs/Android/知识汇总/计算机网络基础","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/ji-suan-ji-wang-luo-ji-chu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/ji-suan-ji-wang-luo-ji-chu/","excerpt":"","text":"网络体系的分层结构 HTTP 相关 通用头部 请求报文 请求行 请求方法 请求头 请求体 响应报文 常见状态码 响应头 缓存机制 HTTP 1.1 HTTP 2.0 HTTPS 加密原理 TCP/IP 三次握手 四次挥手 TCP 与 UDP 的区别 Socket 使用示例 网络体系的分层结构 分层 说明 应用层（HTTP、FTP、DNS、SMTP 等） 定义了如何包装和解析数据，应用层是 http 协议的话，则会按照协议规定包装数据，如按照请求行、请求头、请求体包装，包装好数据后将数据传至运输层 运输层（TCP、UDP 等） 运输层有 TCP 和 UDP 两种，分别对应可靠和不可靠的运输。在这一层，一般都是和 Socket 打交道，Socket 是一组封装的编程调用接口，通过它，我们就能操作 TCP、UDP 进行连接的建立等。这一层指定了把数据送到对应的端口号 网络层（IP 等） 这一层IP协议，以及一些路由选择协议等等，所以这一层的指定了数据要传输到哪个IP地址。中间涉及到一些最优线路，路由选择算法等 数据链路层（ARP） 负责把 IP 地址解析为 MAC 地址，即硬件地址，这样就找到了对应的唯一的机器 物理层 提供二进制流传输服务，也就是真正开始通过传输介质（有线、无线）开始进行数据的传输 HTTP 相关 通用头部 请求报文 http 请求由三部分组成，分别是：请求行、请求头、请求体 请求行 请求行以一个方法符号开头，以空格分开，格式如下：Method Request-URI HTTP-Version CRLF 名称 说明 Method 请求方法如 post/get Request-URI 资源标识符（请求路径） HTTP-Version 请求的HTTP协议版本 CRLF 回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符） 请求方法 HTTP 1.0 名称 说明 GET 请求获取 Request-URI 所标识的资源 POST 在 Request-URI 所标识的资源后附加新的数据 HEAD 请求获取由 Request-URI 所标识的资源的响应消息报头 HTTP 1.1 新增 名称 说明 PUT 请求服务器存储一个资源，并用 Request-URI 作为其标识 DELETE 请求服务器删除 Request-URI 所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 GET &amp; POST 的区别 区别 说明 数据传输方式 GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输。 安全性 POST的数据因为在请求主体内，所以有一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。 数据类型不同 GET只允许 ASCII 字符，而 POST 无限制 特性 GET 是安全无害（只读）且幂等（多次提交等于一次提交），而 POST 是非安全非幂等，可能重复提交表单 请求头 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html,application/json Accept-Charset 浏览器可以接受的字符编码集 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/ Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives… TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 请求体 响应报文 响应报文 名称 组成 状态行 状态码如 200、协议版本等 响应头 即返回的 header 响应体 响应的正文数据 常见状态码 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和 302 含义相同 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 响应头 缓存机制 Cache-control 主要包含以下几个字段： 字段 说明 private 只有客户端可以缓存 public 客户端和代理服务器都可以缓存 max-age 缓存的过期时间 no-cache 需要使用对比缓存来验证缓存数据，如果服务端确认资源没有更新，则返回304，取本地缓存即可，如果有更新，则返回最新的资源。做对比缓存与 Etag 有关。 no-store 这个字段打开，则不会进行缓存，也不会取缓存 Etag：当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag ，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回304。 HTTP 1.1 对比 1.0，HTTP 1.1 主要区别主要体现在： 缓存处理：在 HTTP 1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用：HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），避免带宽浪费。 错误通知管理：HTTP 1.1 新增了 24 个错误状态响应码，410（Gone）表示服务器上的某个资源被永久性的删除。 Host 头处理：HTTP 1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接：HTTP 1.1 支持长连接和请求的流水线理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive。 HTTP 2.0 Okhttp 支持配置使用 HTTP 2.0 协议，HTTP 2.0 相对于 Http1.x 来说提升是巨大的，主要有以下几点： 二进制格式：http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request，使得网络传输变得十分灵活。 多路复用：多个请求共用一个 TCP 连接，多个请求可以同时在这个 TCP 连接上并发，一个request 对应一个 id。 header 压缩：HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自cache一份 header fields 表，避免了重复传输，流量消耗，提高效率。 支持服务端推送 HTTPS HTTP 的端口号是 80，HTTPS 是 443，HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费 SSL 的全称是 Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持 SSL，其最新的版本是 3.0 TLS 的全称是 Transport Layer Security，即安全传输层协议，最新版本的 TLS是 IETF 制定的一种新的协议，它建立在 SSL 3.0 协议规范之上，是SSL 3.0的后续版本。在 TLS 与SSL 3.0 之间存在着显著的差别，主要是它们所支持的加密算法不同，所以 TLS 与 SSL3.0 不能互操作。虽然 TLS 与 SSL 3.0 在加密算法上不同，但在理解 HTTPS 的过程中，可以把 SSL 和 TLS 看做是同一个协议。 SSL（Secure Sockets Layer 安全套接层)，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 加密原理 HTTPS 为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。 TCP/IP IP（Internet Protocol）协议提供了主机和主机间的通信，为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的 IP 地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。 TCP 的全称是 Transmission Control Protocol，TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。 三次握手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号 (Sequence Number) 字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 四次挥手 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 TCP 与 UDP 的区别 区别点 TCP UDP 连接性 面向连接 无连接 可靠性 可靠 不可靠 有序性 有序 无序 面向 字节流 报文（保留报文的边界） 有界性 有界 无界 流量控制 有（滑动窗口） 无 拥塞控制 有（慢开始、拥塞避免、快重传、快恢复） 无 传输速度 慢 快 量级 重量级 轻量级 双工性 全双工 一对一、一对多、多对一、多对多 头部 大（20-60 字节） 小（8 字节） 应用 文件传输、邮件传输、浏览器等 即时通讯、视频通话等 Socket Socket 是一组操作 TCP/UDP 的 API，像 HttpURLConnection 和 Okhttp 这种涉及到比较底层的网络请求发送的，最终当然也都是通过 Socket 来进行网络请求连接发送，而像 Volley、Retrofit 则是更上层的封装。 使用示例 使用 socket 的步骤如下： 创建 ServerSocket 并监听客户连接； 使用 Socket 连接服务端； 通过 Socket.getInputStream()/getOutputStream() 获取输入输出流进行通信。 public class EchoClient { private final Socket mSocket; public EchoClient(String host, int port) throws IOException { // 创建 socket 并连接服务器 mSocket = new Socket(host, port); } public void run() { // 和服务端进行通信 Thread readerThread = new Thread(this::readResponse); readerThread.start(); OutputStream out = mSocket.getOutputStream(); byte[] buffer = new byte[1024]; int n; while ((n = System.in.read(buffer)) &gt; 0) { out.write(buffer, 0, n); } } private void readResponse() { try { InputStream in = mSocket.getInputStream(); byte[] buffer = new byte[1024]; int n; while ((n = in.read(buffer)) &gt; 0) { System.out.write(buffer, 0, n); } } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] argv) { try { // 由于服务端运行在同一主机，这里我们使用 localhost EchoClient client = new EchoClient(\"localhost\", 9877); client.run(); } catch (IOException e) { e.printStackTrace(); } } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Android开源库源码分析","slug":"docs/Android/知识汇总/Android开源库源码分析","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/android-kai-yuan-ku-yuan-ma-fen-xi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/android-kai-yuan-ku-yuan-ma-fen-xi/","excerpt":"","text":"OKHttp OKHttp请求流程 新建OKHttpClient客户端 同步请求流程 异步请求流程 网络请求缓存处理 连接池 Retrofit 基本使用流程 Retrofit构建过程 Retrofit核心对象解析 Builder内部构造 添加baseUrl 添加GsonConverterFactory build过程 创建网络请求接口实例过程 创建网络请求接口类实例并执行请求过程 Retrofit源码流程图 Glide 基本使用流程 GlideApp.with(context)源码详解 load(url)源码详解 into(iv)源码详解 完整Glide加载流程图 GreenDao 基本使用流程 GreenDao使用流程分析 创建数据库帮助类对象DaoMaster.DevOpenHelper 创建DaoMaster对象 创建DaoSession对象 插入源码分析 查询源码分析 GreenDao是如何与ReactiveX结合？ RxJava RxJava是什么？ RxJava的订阅流程 创建被观察者过程 订阅过程 RxJava的线程切换 LeakCanary 原理概述 简单示例 源码分析 LeakCanary运作流程 ButterKnife 简单示例 源码分析 模板代码解析 ButterKnife 是怎样实现代码注入的 ButterKnife是如何在编译时生成代码的？ Dagger 2 预备知识 @Inject @Module @Singleton @Providers @Component @Scope @Qualifier dependencies @SubComponent 简单示例 源码分析 EventBus 简单示例 源码分析 OKHttp OKHttp请求流程 OKHttp内部的大致请求流程图如下所示： 如下为使用OKHttp进行Get请求的步骤： //1.新建OKHttpClient客户端 OkHttpClient client = new OkHttpClient(); //新建一个Request对象 Request request = new Request.Builder() .url(url) .build(); //2.Response为OKHttp中的响应 Response response = client.newCall(request).execute(); 新建OKHttpClient客户端 OkHttpClient client = new OkHttpClient(); public OkHttpClient() { this(new Builder()); } OkHttpClient(Builder builder) { .... } 可以看到，OkHttpClient使用了建造者模式，Builder里面的可配置参数如下： public static final class Builder { Dispatcher dispatcher;// 分发器 @Nullable Proxy proxy; List&lt;Protocol&gt; protocols; List&lt;ConnectionSpec&gt; connectionSpecs;// 传输层版本和连接协议 final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();// 拦截器 final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;(); EventListener.Factory eventListenerFactory; ProxySelector proxySelector; CookieJar cookieJar; @Nullable Cache cache; @Nullable InternalCache internalCache;// 内部缓存 SocketFactory socketFactory; @Nullable SSLSocketFactory sslSocketFactory;// 安全套接层socket 工厂，用于HTTPS @Nullable CertificateChainCleaner certificateChainCleaner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。 HostnameVerifier hostnameVerifier;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。 CertificatePinner certificatePinner;// 证书锁定，使用CertificatePinner来约束哪些认证机构被信任。 Authenticator proxyAuthenticator;// 代理身份验证 Authenticator authenticator;// 身份验证 ConnectionPool connectionPool;// 连接池 Dns dns; boolean followSslRedirects; // 安全套接层重定向 boolean followRedirects;// 本地重定向 boolean retryOnConnectionFailure;// 重试连接失败 int callTimeout; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; // 这里是默认配置的构建参数 public Builder() { dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; ... } // 这里传入自己配置的构建参数 Builder(OkHttpClient okHttpClient) { this.dispatcher = okHttpClient.dispatcher; this.proxy = okHttpClient.proxy; this.protocols = okHttpClient.protocols; this.connectionSpecs = okHttpClient.connectionSpecs; this.interceptors.addAll(okHttpClient.interceptors); this.networkInterceptors.addAll(okHttpClient.networkInterceptors); ... } 同步请求流程 Response response = client.newCall(request).execute(); /** * Prepares the {@code request} to be executed at some point in the future. */ @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false /* for web socket */); } // RealCall为真正的请求执行者 static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } @Override public Response execute() throws IOException { synchronized (this) { // 每个Call只能执行一次 if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try { // 通知dispatcher已经进入执行状态 client.dispatcher().executed(this); // 通过一系列的拦截器请求处理和响应处理得到最终的返回结果 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; } catch (IOException e) { e = timeoutExit(e); eventListener.callFailed(this, e); throw e; } finally { // 通知 dispatcher 自己已经执行完毕 client.dispatcher().finished(this); } } Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 在配置 OkHttpClient 时设置的 interceptors； interceptors.addAll(client.interceptors()); // 负责失败重试以及重定向 interceptors.add(retryAndFollowUpInterceptor); // 请求时，对必要的Header进行一些添加，接收响应时，移除必要的Header interceptors.add(new BridgeInterceptor(client.cookieJar())); // 负责读取缓存直接返回、更新缓存 interceptors.add(new CacheInterceptor(client.internalCache())); // 负责和服务器建立连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { // 配置 OkHttpClient 时设置的 networkInterceptors interceptors.addAll(client.networkInterceptors()); } // 负责向服务器发送请求数据、从服务器读取响应数据 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 使用责任链模式开启链式调用 return chain.proceed(originalRequest); } // StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流 // 和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { ... // Call the next interceptor in the chain. // 实例化下一个拦截器对应的RealIterceptorChain对象 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 得到当前的拦截器 Interceptor interceptor = interceptors.get(index); // 调用当前拦截器的intercept()方法，并将下一个拦截器的RealIterceptorChain对象传递下去,最后得到响应 Response response = interceptor.intercept(next); ... return response; } 异步请求流程 Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { e.printStackTrace(); } @Override public void onResponse(Call call, Response response) throws IOException { ... } void enqueue(AsyncCall call) { synchronized (this) { readyAsyncCalls.add(call); } promoteAndExecute(); } // 正在准备中的异步请求队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); // 运行中的异步请求 private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); // 同步请求 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); // Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs // them on the executor service. Must not be called with synchronization because executing calls // can call into user code. private boolean promoteAndExecute() { assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) { for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall asyncCall = i.next(); // 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行， // 同时利用线程池执行call；否者将call加入到readyAsyncCalls中。 if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); } isRunning = runningCallsCount() &gt; 0; } for (int i = 0, size = executableCalls.size(); i &lt; size; i++) { AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); } return isRunning; } 最后，我们在看看AsynCall的代码。 final class AsyncCall extends NamedRunnable { private final Callback responseCallback; AsyncCall(Callback responseCallback) { super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; } String host() { return originalRequest.url().host(); } Request request() { return originalRequest; } RealCall get() { return RealCall.this; } /** * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. */ void executeOn(ExecutorService executorService) { assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try { executorService.execute(this); success = true; } catch (RejectedExecutionException e) { InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\"); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); } finally { if (!success) { client.dispatcher().finished(this); // This call is no longer running! } } } @Override protected void execute() { boolean signalledCallback = false; timeout.enter(); try { // 跟同步执行一样，最后都会调用到这里 Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { e = timeoutExit(e); if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } 从上面的源码可以知道，拦截链的处理OKHttp帮我们默认做了五步拦截处理，其中RetryAndFollowUpInterceptor、BridgeInterceptor、CallServerInterceptor内部的源码很简洁易懂，此处不再多说。 网络请求缓存处理之CacheInterceptor @Override public Response intercept(Chain chain) throws IOException { // 根据request得到cache中缓存的response Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // request判断缓存的策略，是否要使用了网络，缓存或两者都使用 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null &amp;&amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. } // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // If we don't need the network, we're done. if (networkRequest == null) { return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); } Response networkResponse = null; try { // 调用下一个拦截器，决定从网络上来得到response networkResponse = chain.proceed(networkRequest); } finally { // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // If we have a cache response too, then we're doing a conditional get. // 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse if (cacheResponse != null) { if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) { if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) { // Offer this request to the cache. // 缓存未经缓存过的response CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } 缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存给用户，否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。 ConnectInterceptor之连接池 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); // HttpCodec是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。在这个方法的内部实现连接池的复用处理 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } // Returns a connection to host a new stream. This // prefers the existing connection if it exists, // then the pool, finally building a new connection. // 调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列 // 的判断到达 StreamAllocation 中的 findConnection() 方法 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { ... // Attempt to use an already-allocated connection. We need to be careful here because our // already-allocated connection may have been restricted from creating new streams. // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流 releasedConnection = this.connection; // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接 toClose = releaseIfNoNewStreams(); if (this.connection != null) { // We had an already-allocated connection and it's good. result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // If the connection was never reported acquired, don't report it as released! // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire() 方法修改 releasedConnection = null; } if (result == null) { // Attempt to get a connection from the pool. // 尝试供连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) { foundPooledConnection = true; result = connection; } else { selectedRoute = route; } } } // 关闭连接 closeQuietly(toClose); if (releasedConnection != null) { eventListener.connectionReleased(call, releasedConnection); } if (foundPooledConnection) { eventListener.connectionAcquired(call, result); } if (result != null) { // If we found an already-allocated or pooled connection, we're done. // 如果已经从连接池中获取到了一个连接，就将其返回 return result; } // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) { newRouteSelection = true; routeSelection = routeSelector.next(); } synchronized (connectionPool) { if (canceled) throw new IOException(\"Canceled\"); if (newRouteSelection) { // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. // 根据一系列的 IP地址从连接池中获取一个链接 List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size;i++) { Route route = routes.get(i); // 从连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, route); if (connection != null) { foundPooledConnection = true; result = connection; this.route = route; break; } } } if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. // 在连接池中如果没有该连接，则创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端 route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); } } // If we found a pooled connection on the 2nd time around, we're done. if (foundPooledConnection) { // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回 eventListener.connectionAcquired(call, result); return result; } // Do TCP + TLS handshakes. This is a blocking operation. // 进行 TCP 和 TLS 握手 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) { reportedAcquired = true; // Pool the connection. // 将该连接放进连接池中 Internal.instance.put(connectionPool, result); // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接 if (result.isMultiplexed()) { socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; } } closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; } 从以上的源码分析可知： 判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流； 如果当前的连接无法使用，就从连接池中获取一个连接； 连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。 在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。并且，从中我们明白了连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。 接下来详细分析下ConnectionPool是如何实现连接管理的。 OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。 private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; // 使用线程池执行清理任务 executor.execute(cleanupRunnable); } // 将新建的连接插入到双端队列中 connections.add(connection); } private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { // 内部调用 cleanup() 方法来清理无效的连接 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } }; long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. synchronized (this) { // 遍历所有的连接 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // If the connection is in use, keep searching. // 遍历所有的连接 if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // If the connection is ready to be evicted, we're done. // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } // maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。 // 默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // We've found a connection to evict. Remove it from the list, then close it below (outside // of the synchronized block). // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除 connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // A connection will be ready to evict soon. // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候） return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // All connections are in use. It'll be at least the keep alive duration 'til we run again. // 所有的连接都在使用中，5分钟后再清理 return keepAliveDurationNs; } else { // No connections, idle or in use. // 没有连接 cleanupRunning = false; return -1; } } 从以上的源码分析可知，首先会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。 经过上面对OKHttp内部工作机制的一系列分析，相信你已经对OKHttp已经有了一个比较深入的了解了。首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。 其中，除了OKHttp的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，相信经过讲解，大家对这三部分重点内容已经有了自己的理解。 Retrofit 基本使用流程 定义HTTP API，用于描述请求 public interface GitHubService { @GET(\"users/{user}/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user); } 创建Retrofit并生成API的实现 （注意： 方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数） // 1.Retrofit构建过程 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build(); // 2.创建网络请求接口类实例过程 GitHubService service = retrofit.create(GitHubService.class); 调用API方法，生成Call，执行请求 // 3.生成并执行请求过程 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); repos.execute() or repos.enqueue() Retrofit的基本使用流程很简洁，但是简洁并不代表简单，Retrofit为了实现这种简洁的使用流程，内部使用了优秀的架构设计和大量的设计模式，在分析过Retrofit最新版的源码和大量优秀的Retrofit源码分析文章后发现，要想真正理解Retrofit内部的核心源码流程和设计思想，首先，需要对这九大设计模式有一定的了解，如下： 1.Retrofit构建过程 建造者模式、工厂方法模式 2.创建网络请求接口实例过程 外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式） 3.生成并执行请求过程 适配器模式（代理模式、装饰模式） 其次，需要对OKHttp源码有一定的了解。让我们按以上流程去深入Retrofit源码内部，领悟它带给我们的设计之美。 Retrofit构建过程 Retrofit核心对象解析 首先Retrofit中有一个全局变量非常关键，在V2.5之前的版本，使用的是LinkedHashMap()，它是一个网络请求配置对象，是由网络请求接口中方法注解进行解析后得到的。 public final class Retrofit { // 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等 private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); Retrofit使用了建造者模式通过内部类Builder类建立一个Retrofit实例，如下： public static final class Builder { // 平台类型对象（Platform -&gt; Android) private final Platform platform; // 网络请求工厂，默认使用OkHttpCall（工厂方法模式） private @Nullable okhttp3.Call.Factory callFactory; // 网络请求的url地址 private @Nullable HttpUrl baseUrl; // 数据转换器工厂的集合 private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); // 网络请求适配器工厂的集合，默认是ExecutorCallAdapterFactory private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(); // 回调方法执行器，在 Android 上默认是封装了 handler 的 MainThreadExecutor, 默认作用是：切换线程（子线程 -&gt; 主线程） private @Nullable Executor callbackExecutor; // 一个开关，为true则会缓存创建的ServiceMethod private boolean validateEagerly; Builder内部构造 下面看看Builder内部构造做了什么。 public static final class Builder { ... Builder(Platform platform) { this.platform = platform; } public Builder() { this(Platform.get()); } ... } class Platform { private static final Platform PLATFORM = findPlatform(); static Platform get() { return PLATFORM; } private static Platform findPlatform() { try { // 使用JVM加载类的方式判断是否是Android平台 Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) { return new Android(); } } catch (ClassNotFoundException ignored) { } try { // 同时支持Java平台 Class.forName(\"java.util.Optional\"); return new Java8(); } catch (ClassNotFoundException ignored) { } return new Platform(); } static class Android extends Platform { ... @Override public Executor defaultCallbackExecutor() { //切换线程（子线程 -&gt; 主线程） return new MainThreadExecutor(); } // 创建默认的网络请求适配器工厂，如果是Android7.0或Java8上，则使 // 用了并发包中的CompletableFuture保证了回调的同步 // 在Retrofit中提供了四种CallAdapterFactory(策略模式)： // ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、 // va8CallAdapterFactory、RxJavaCallAdapterFactory @Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories( @Nullable Executor callbackExecutor) { if (callbackExecutor == null) throw new AssertionError(); ExecutorCallAdapterFactory executorFactory = new ExecutorCallAdapterFactory(callbackExecutor); return Build.VERSION.SDK_INT &gt;= 24 ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory) : singletonList(executorFactory); } ... @Override List&lt;? extends Converter.Factory&gt; defaultConverterFactories() { return Build.VERSION.SDK_INT &gt;= 24 ? singletonList(OptionalConverterFactory.INSTANCE) : Collections.&lt;Converter.Factory&gt;emptyList(); } ... static class MainThreadExecutor implements Executor { // 获取Android 主线程的Handler private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) { // 在UI线程对网络请求返回数据处理 handler.post(r); } } } 可以看到，在Builder内部构造时设置了默认Platform、callAdapterFactories和callbackExecutor。 添加baseUrl 很简单，就是将String类型的url转换为OkHttp的HttpUrl过程如下： /** * Set the API base URL. * * @see #baseUrl(HttpUrl) */ public Builder baseUrl(String baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); return baseUrl(HttpUrl.get(baseUrl)); } public Builder baseUrl(HttpUrl baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) { throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl); } this.baseUrl = baseUrl; return this; } 添加GsonConverterFactory 首先，看到GsonConverterFactory.creat()的源码。 public final class GsonConverterFactory extends Converter.Factory { public static GsonConverterFactory create() { return create(new Gson()); } public static GsonConverterFactory create(Gson gson) { if (gson == null) throw new NullPointerException(\"gson == null\"); return new GsonConverterFactory(gson); } private final Gson gson; // 创建了一个含有Gson对象实例的GsonConverterFactory private GsonConverterFactory(Gson gson) { this.gson = gson; } 然后，看看addConverterFactory()方法内部。 public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, \"factory null\")); return this; } 可知，这一步是将一个含有Gson对象实例的GsonConverterFactory放入到了数据转换器工厂converterFactories里。 build过程 public Retrofit build() { if (baseUrl == null) { throw new IllegalStateException(\"Base URL required.\"); } okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { // 默认使用okhttp callFactory = new OkHttpClient(); } Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { // Android默认的callbackExecutor callbackExecutor = platform.defaultCallbackExecutor(); } // Make a defensive copy of the adapters and add the defaultCall adapter. List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); // 添加默认适配器工厂在集合尾部 callAdapterFactories.addAll(platform.defaultCallAdapterFactorisca llbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters thatconsumeall types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories(); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); } 可以看到，最终我们在Builder类中看到的6大核心对象都已经配置到Retrofit对象中了。 创建网络请求接口实例过程 retrofit.create()使用了外观模式和代理模式创建了网络请求的接口实例，我们分析下create方法。 public &lt;T&gt; T create(final Class&lt;T&gt; service) { Utils.validateServiceInterface(service); if (validateEagerly) { // 判断是否需要提前缓存ServiceMethod对象 eagerlyValidateMethods(service); } // 使用动态代理拿到请求接口所有注解配置后，创建网络请求接口实例 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } }); } private void eagerlyValidateMethods(Class&lt;?&gt; service) { Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) { if (!platform.isDefaultMethod(method)) { loadServiceMethod(method); } } } 继续看看loadServiceMethod的内部流程 ServiceMethod&lt;?&gt; loadServiceMethod(Method method) { ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { // 解析注解配置得到了ServiceMethod result = ServiceMethod.parseAnnotations(this, method); // 可以看到，最终加入到ConcurrentHashMap缓存中 serviceMethodCache.put(method, result); } } return result; } abstract class ServiceMethod&lt;T&gt; { static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) { // 通过RequestFactory解析注解配置（工厂模式、内部使用了建造者模式） RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) { throw methodError(method, \"Method return type must not include a type variable or wildcard: %s\", returnType); } if (returnType == void.class) { throw methodError(method, \"Service methods cannot return void.\"); } // 最终是通过HttpServiceMethod构建的请求方法 return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); } abstract T invoke(Object[] args); } 请求构造核心流程 根据RequestFactory#Builder构造方法和parseAnnotations方法的源码，可知的它的作用就是用来解析注解配置的。 Builder(Retrofit retrofit, Method method) { this.retrofit = retrofit; this.method = method; // 获取网络请求接口方法里的注释 this.methodAnnotations = method.getAnnotations(); // 获取网络请求接口方法里的参数类型 this.parameterTypes = method.getGenericParameterTypes(); // 获取网络请求接口方法里的注解内容 this.parameterAnnotationsArray = method.getParameterAnnotations(); } 接着看HttpServiceMethod.parseAnnotations()的内部流程。 static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { //1.根据网络请求接口方法的返回值和注解类型， // 从Retrofit对象中获取对应的网络请求适配器 CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit,method); // 得到响应类型 Type responseType = callAdapter.responseType(); ... //2.根据网络请求接口方法的返回值和注解类型从Retrofit对象中获取对应的数据转换器 Converter&lt;ResponseBody, ResponseT&gt;responseConverter = createResponseConverter(retrofit,method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; return newHttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter,responseConverter); } createCallAdapter(retrofit, method) private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter( Retrofit retrofit, Method method) { // 获取网络请求接口里方法的返回值类型 Type returnType = method.getGenericReturnType(); // 获取网络请求接口接口里的注解 Annotation[] annotations = method.getAnnotations(); try { //noinspection unchecked return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations); } catch (RuntimeException e) { // Wide exception range because factories are user code. throw methodError(method, e, \"Unable to create call adapter for %s\", returnType); } } public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) { return nextCallAdapter(null, returnType, annotations); } public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) { ... int start = callAdapterFactories.indexOf(skipPast) + 1; // 遍历 CallAdapter.Factory 集合寻找合适的工厂 for (int i = start, count = callAdapterFactories.size(); i &lt;count; i++) { CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) { return adapter; } } } createResponseConverter(Retrofit retrofit, Method method, Type responseType) private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter( Retrofit retrofit, Method method, Type responseType) { Annotation[] annotations = method.getAnnotations(); try { return retrofit.responseBodyConverter(responseType,annotations); } catch (RuntimeException e) { // Wide exception range because factories are user code. throw methodError(method, e, \"Unable to create converter for%s\", responseType); } } public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) { return nextResponseBodyConverter(null, type, annotations); } public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) { ... int start = converterFactories.indexOf(skipPast) + 1; // 遍历 Converter.Factory 集合并寻找合适的工厂, 这里是GsonResponseBodyConverter for (int i = start, count = converterFactories.size(); i &lt; count; i++) { Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) { //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; } } 执行HttpServiceMethod的invoke方法 @Override ReturnT invoke(Object[] args) { return callAdapter.adapt( new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter)); } 最终在adapt中创建了一个ExecutorCallbackCall对象，它是一个装饰者，而在它内部真正去执行网络请求的还是OkHttpCall。 创建网络请求接口类实例并执行请求过程 service.listRepos() 1、Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); service对象是动态代理对象Proxy.newProxyInstance()，当调用getCall()时会被 它拦截，然后调用自身的InvocationHandler#invoke()，得到最终的Call对象。 同步执行流程 repos.execute() @Override public Response&lt;T&gt; execute() throws IOException { okhttp3.Call call; synchronized (this) { if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; if (creationFailure != null) { if (creationFailure instanceof IOException) { throw (IOException) creationFailure; } else if (creationFailure instanceof RuntimeException) { throw (RuntimeException) creationFailure; } else { throw (Error) creationFailure; } } call = rawCall; if (call == null) { try { // 创建一个OkHttp的Request对象请求 call = rawCall = createRawCall(); } catch (IOException | RuntimeException | Error e) { throwIfFatal(e); // Do not assign a fatal error to creationFailure. creationFailure = e; throw e; } } } if (canceled) { call.cancel(); } // 调用OkHttpCall的execute()发送网络请求（同步）， // 并解析网络请求返回的数据 return parseResponse(call.execute()); } private okhttp3.Call createRawCall() throws IOException { // 创建 一个okhttp3.Request okhttp3.Call call = callFactory.newCall(requestFactory.create(args)); if (call == null) { throw new NullPointerException(\"Call.Factory returned null.\"); } return call; } Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException { ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // 根据响应返回的状态码进行处理 int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) { try { // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); } finally { rawBody.close(); } } if (code == 204 || code == 205) { rawBody.close(); return Response.success(null, rawResponse); } ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody); try { // 将响应体转为Java对象 T body = responseConverter.convert(catchingBody); return Response.success(body, rawResponse); } catch (RuntimeException e) { // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; } } 异步请求流程 reponse.enqueque @Override public void enqueue(final Callback&lt;T&gt; callback) { // 使用静态代理 delegate进行异步请求 delegate.enqueue(new Callback&lt;T&gt;() { @Override public void onResponse(Call&lt;T&gt; call, finalResponse&lt;T&gt;response) { // 线程切换，在主线程显示结果 callbackExecutor.execute(new Runnable() { @Override public void run() { if (delegate.isCanceled()) { callback.onFailure(ExecutorCallbackCall.this, newIOException(\"Canceled\")); } else { callback.onResponse(ExecutorCallbackCall.this,respons); } } }); } @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) { callbackExecutor.execute(new Runnable() { @Override public void run() { callback.onFailure(ExecutorCallbackCall.this, t); } }); } }); } 看看 delegate.enqueue 内部流程。 @Override public void enqueue(final Callback&lt;T&gt; callback) { okhttp3.Call call; Throwable failure; synchronized (this) { if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) { try { // 创建OkHttp的Request对象，再封装成OkHttp.call // 方法同发送同步请求，此处上面已分析 call = rawCall = createRawCall(); } catch (Throwable t) { failure = creationFailure = t; } } @Override public void enqueue(final Callback&lt;T&gt; callback) { checkNotNull(callback, \"callback == null\"); okhttp3.Call call; Throwable failure; ... call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response&lt;T&gt; response; try { // 此处上面已分析 response = parseResponse(rawResponse); } catch (Throwable e) { throwIfFatal(e); callFailure(e); return; } try { callback.onResponse(OkHttpCall.this, response); } catch (Throwable t) { t.printStackTrace(); } } @Override public void onFailure(okhttp3.Call call, IOException e) { callFailure(e); } private void callFailure(Throwable e) { try { callback.onFailure(OkHttpCall.this, e); } catch (Throwable t) { t.printStackTrace(); } } }); } Retrofit源码流程图 建议大家自己主动配合着Retrofit最新版的源码一步步去彻底地认识它，只有这样，你才能看到它真实的内心，附上一张Retrofit源码流程图，要注意的是，这是V2.5之前版本的流程，但是，在看完上面的源码分析后，我们知道，主体流程是没有变化的。 从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了 OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理的方式，动态将网络请求接口的注解解析成HTTP请求，最后执行请求的过程。 Glide 基本使用流程 Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。 GlideApp.with(context).load(url).into(iv); 其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。 @GlideModule public class MyAppGlideModule extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { // 实际使用中根据情况可以添加如下配置 &lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt; &lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt; &lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt; &lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt; &lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt; &lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt; &lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt; } } 接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。 GlideApp.with(context)源码详解 首先，用这份Glide框架图让我们对Glide的总体框架有一个初步的了解。 从GlideApp.with这行代码开始，内部主线执行流程如下。 GlideApp#with return (GlideRequests) Glide.with(context); Glide#with return getRetriever(context).get(context); return Glide.get(context).getRequestManagerRetriever(); // 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化 checkAndInitializeGlide(context); initializeGlide(context); // 最终执行到Glide的另一个重载方法 initializeGlide(context, new GlideBuilder()); @SuppressWarnings(\"deprecation\") private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) { Context applicationContext = context.getApplicationContext(); // 1、获取前面应用中带注解的GlideModule GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(); // 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面 // 配置的GlideModule模块（manifestModules）。 List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList(); if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled( )) { manifestModules = new ManifestParser(applicationContext).parse(); } ... RequestManagerRetriever.RequestManagerFactory factory = annotationGeneratedModule != null ? annotationGeneratedModule.getRequestManag erFactory() : null; builder.setRequestManagerFactory(factory); for (com.bumptech.glide.module.GlideModule module : manifestModules) { module.applyOptions(applicationContext, builder); } if (annotationGeneratedModule != null) { annotationGeneratedModule.applyOptions(applicatio nContext, builder); } // 3、初始化各种配置信息 Glide glide = builder.build(applicationContext); // 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder // 里面（applyOptions）替换glide默认组件（registerComponents） for (com.bumptech.glide.module.GlideModule module : manifestModules) { module.registerComponents(applicationContext, glide, glide.registry); } if (annotationGeneratedModule != null) { annotationGeneratedModule.registerComponents(appl icationContext, glide, glide.registry); } applicationContext.registerComponentCallbacks(glide ); Glide.glide = glide; } GlideBuilder#build @NonNull Glide build(@NonNull Context context) { // 创建请求图片线程池sourceExecutor if (sourceExecutor == null) { sourceExecutor = GlideExecutor.newSourceExecutor(); } // 创建硬盘缓存线程池diskCacheExecutor if (diskCacheExecutor == null) { diskCacheExecutor = GlideExecutor.newDiskCacheExecutor(); } // 创建动画线程池animationExecutor if (animationExecutor == null) { animationExecutor = GlideExecutor.newAnimationExecutor(); } if (memorySizeCalculator == null) { memorySizeCalculator = new MemorySizeCalculator.Builder(context).build(); } if (connectivityMonitorFactory == null) { connectivityMonitorFactory = new DefaultConnectivityMonitorFactory(); } if (bitmapPool == null) { // 依据设备的屏幕密度和尺寸设置各种pool的size int size = memorySizeCalculator.getBitmapPoolSize(); if (size &gt; 0) { // 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap // 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。 // 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap bitmapPool = new LruBitmapPool(size); } else { bitmapPool = new BitmapPoolAdapter(); } } // 创建对象数组缓存池LruArrayPool，默认4M if (arrayPool == null) { arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSiz eInBytes()); } // 创建LruResourceCache，内存缓存 if (memoryCache == null) { memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCa cheSize()); } if (diskCacheFactory == null) { diskCacheFactory = new InternalCacheDiskCacheFactory(context); } // 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象） if (engine == null) { engine = new Engine( memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, GlideExecutor.newUnlimitedSourceExecutor( ), GlideExecutor.newAnimationExecutor(), isActiveResourceRetentionAllowed); } RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(requestManagerFactory); return new Glide( context, engine, memoryCache, bitmapPool, arrayPool, requestManagerRetriever, connectivityMonitorFactory, logLevel, defaultRequestOptions.lock(), defaultTransitionOptions); } Glide#Glide构造方法 Glide(...) { ... // 注册管理任务执行对象的类(Registry) // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时， // 根据当前任务的性质，分发给相应员工进行处理 registry = new Registry(); ... // 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件） registry .append(ByteBuffer.class, new ByteBufferEncoder()) .append(InputStream.class, new StreamEncoder(arrayPool)) // 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget) ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory(); glideContext = new GlideContext( context, arrayPool, registry, imageViewTargetFactory, defaultRequestOptions, defaultTransitionOptions, engine, logLevel); } RequestManagerRetriever#get @NonNull public RequestManager get(@NonNull Context context) { if (context == null) { throw new IllegalArgumentException(\"You cannot start a load on a null Context\"); } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) { // 如果当前线程是主线程且context不是Application走相应的get重载方法 if (context instanceof FragmentActivity) { return get((FragmentActivity) context); } else if (context instanceof Activity) { return get((Activity) context); } else if (context instanceof ContextWrapper) { return get(((ContextWrapper) context).getBaseContext()); } } // 否则直接将请求与ApplicationLifecycle关联 return getApplicationManager(context); } 这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(RequestManagerFragment)。 GlideApp#with小结 初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象。 将glide请求和application/SupportFragment/Fragment的生命周期绑定在一块。 with方法的执行流程 load(url)源码详解 GlideRequest(RequestManager)#load return (GlideRequest&lt;Drawable&gt;) super.load(string); return asDrawable().load(string); // 1、asDrawable部分 return (GlideRequest&lt;Drawable&gt;) super.asDrawable(); return as(Drawable.class); // 最终返回了一个GlideRequest（RequestManager的子类） return new GlideRequest&lt;&gt;(glide, this, resourceClass, context); // 2、load部分 return (GlideRequest&lt;TranscodeType&gt;) super.load(string); return loadGeneric(string); @NonNull private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) { // model则为设置的url this.model = model; // 记录url已设置 isModelSet = true; return this; } 可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。 load方法的执行流程 into(iv)源码详解 真正复杂的地方要开始了。 RequestBuilder.into @NonNull public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); RequestOptions requestOptions = this.requestOptions; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don't retain the transformation applied based on the previous // View's scale type. switch (view.getScaleType()) { // 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、 // FitCenter、CenterInside四种规格。 case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside() ; break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside() ; break; case CENTER: case MATRIX: default: // Do nothing. } } // 注意，这个transcodeClass是指的drawable或bitmap return into( glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions); } GlideContext#buildImageViewTarget return imageViewTargetFactory.buildTarget(imageView, transcodeClass); ImageViewTargetFactory#buildTarget @NonNull @SuppressWarnings(\"unchecked\") public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt; buildTarget(@NonNull ImageView view, @NonNull Class&lt;Z&gt; clazz) { // 返回展示Bimtap/Drawable资源的目标对象 if (Bitmap.class.equals(clazz)) { return (ViewTarget&lt;ImageView, Z&gt;) new BitmapImageViewTarget(view); } else if (Drawable.class.isAssignableFrom(clazz)) { return (ViewTarget&lt;ImageView, Z&gt;) new DrawableImageViewTarget(view); } else { throw new IllegalArgumentException( \"Unhandled class: \" + clazz + \", try .as*(Class).transcode(ResourceTranscoder)\"); } } 可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。 RequestBuilder#into private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options) { Util.assertMainThread(); Preconditions.checkNotNull(target); if (!isModelSet) { throw new IllegalArgumentException(\"You must call #load() before calling #into()\"); } options = options.autoClone(); // 分析1.建立请求 Request request = buildRequest(target, targetListener, options); Request previous = target.getRequest(); if (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques t(options, previous)) { request.recycle(); // If the request is completed, beginning again will ensure the result is re-delivered, // triggering RequestListeners and Targets. If the request is failed, beginning again will // restart the request, giving it another chance to complete. If the request is already // running, we can let it continue running without interruption. if (!Preconditions.checkNotNull(previous).isRunni ng()) { // Use the previous request rather than the new one to allow for optimizations like skipping // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions // that are done in the individual Request. previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); // 分析2.真正追踪请求的地方 requestManager.track(target, request); return target; } // 分析1 private Request buildRequest( Target&lt;TranscodeType&gt; target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, RequestOptions requestOptions) { return buildRequestRecursive( target, targetListener, /*parentCoordinator=*/ null, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions); } // 分析1 private Request buildRequestRecursive( Target&lt;TranscodeType&gt; target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) { // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator. ErrorRequestCoordinator errorRequestCoordinator = null; if (errorBuilder != null) { // 创建errorRequestCoordinator（异常处理对象） errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator); parentCoordinator = errorRequestCoordinator; } // 递归建立缩略图请求 Request mainRequest = buildThumbnailRequestRecursive( target, targetListener, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, requestOptions); if (errorRequestCoordinator == null) { return mainRequest; } ... Request errorRequest = errorBuilder.buildRequestRecursive( target, targetListener, errorRequestCoordinator, errorBuilder.transitionOptions, errorBuilder.requestOptions.getPriority(), errorOverrideWidth, errorOverrideHeight, errorBuilder.requestOptions); errorRequestCoordinator.setRequests(mainRequest, errorRequest); return errorRequestCoordinator; } // 分析1 private Request buildThumbnailRequestRecursive( Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) { if (thumbnailBuilder != null) { // Recursive case: contains a potentially recursive thumbnail request builder. ... ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); // 获取一个正常请求对象 Request fullRequest = obtainRequest( target, targetListener, requestOptions, coordinator, transitionOptions, priority, overrideWidth, overrideHeight); isThumbnailBuilt = true; // Recursively generate thumbnail requests. // 使用递归的方式建立一个缩略图请求对象 Request thumbRequest = thumbnailBuilder.buildRequestRecursive( target, targetListener, coordinator, thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight, thumbnailBuilder.requestOptions); isThumbnailBuilt = false; // coordinator（ThumbnailRequestCoordinator）是作为两者的协调者， // 能够同时加载缩略图和正常的图的请求 coordinator.setRequests(fullRequest, thumbRequest); return coordinator; } else if (thumbSizeMultiplier != null) { // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse. // 当设置了缩略的比例thumbSizeMultiplier(0 ~ 1)时， // 不需要递归建立缩略图请求 ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator); Request fullRequest = obtainRequest( target, targetListener, requestOptions, coordinator, transitionOptions, priority, overrideWidth, overrideHeight); RequestOptions thumbnailOptions = requestOptions.clone() .sizeMultiplier(thumbSizeMultiplier); Request thumbnailRequest = obtainRequest( target, targetListener, thumbnailOptions, coordinator, transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight); coordinator.setRequests(fullRequest, thumbnailRequest); return coordinator; } else { // Base case: no thumbnail. // 没有缩略图请求时，直接获取一个正常图请求 return obtainRequest( target, targetListener, requestOptions, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight); } } private Request obtainRequest( Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, RequestOptions requestOptions, RequestCoordinator requestCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight) { // 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target return SingleRequest.obtain( context, glideContext, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, glideContext.getEngine(), transitionOptions.getTransitionFactory()); } 从上源码分析可知，我们在分析1处的buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)方法，接着看看track里面做了什么。 RequestManager#track // 分析2 void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) { // 加入一个target目标集合(Set) targetTracker.track(target); requestTracker.runRequest(request); } RequestTracker#runRequest /** * Starts tracking the given request. */ // 分析2 public void runRequest(@NonNull Request request) { requests.add(request); if (!isPaused) { // 如果不是暂停状态则开始请求 request.begin(); } else { request.clear(); if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, \"Paused, delaying request\"); } // 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现） pendingRequests.add(request); } } SingleRequest#begin // 分析2 @Override public void begin() { ... if (model == null) { ... // model（url）为空，回调加载失败 onLoadFailed(new GlideException(\"Received null model\"), logLevel); return; } if (status == Status.RUNNING) { throw new IllegalArgumentException(\"Cannot restart a running request\"); } if (status == Status.COMPLETE) { onResourceReady(resource, DataSource.MEMORY_CACHE); return; } status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) { // 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady， // 最终的核心处理位于onSizeReady onSizeReady(overrideWidth, overrideHeight); } else { // 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady target.getSize(this); } if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) &amp;&amp; canNotifyStatusChanged()) { // 预先加载设置的缩略图 target.onLoadStarted(getPlaceholderDrawable()); } if (IS_VERBOSE_LOGGABLE) { logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime)); } } 从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~ SingleRequest#onSizeReady // 分析2 @Override public void onSizeReady(int width, int height) { stateVerifier.throwIfRecycled(); ... status = Status.RUNNING; float sizeMultiplier = requestOptions.getSizeMultiplier(); this.width = maybeApplySizeMultiplier(width, sizeMultiplier); this.height = maybeApplySizeMultiplier(height, sizeMultiplier); ... // 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类 loadStatus = engine.load( glideContext, model, requestOptions.getSignature(), this.width, this.height, requestOptions.getResourceClass(), transcodeClass, priority, requestOptions.getDiskCacheStrategy(), requestOptions.getTransformations(), requestOptions.isTransformationRequired(), requestOptions.isScaleOnlyOrNoTransform(), requestOptions.getOptions(), requestOptions.isMemoryCacheable(), requestOptions.getUseUnlimitedSourceGeneratorsP ool(), requestOptions.getUseAnimationPool(), requestOptions.getOnlyRetrieveFromCache(), this); ... } 终于看到Engine类了，感觉距离成功不远了，继续~ Engine#load public &lt;R&gt; LoadStatus load( GlideContext glideContext, Object model, Key signature, int width, int height, Class&lt;?&gt; resourceClass, Class&lt;R&gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, boolean isTransformationRequired, boolean isScaleOnlyOrNoTransform, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, boolean useAnimationPool, boolean onlyRetrieveFromCache, ResourceCallback cb) { ... // 先从弱引用中查找，如果有的话回调onResourceReady并直接返回 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) { cb.onResourceReady(active, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key); } return null; } // 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) { cb.onResourceReady(cached, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(\"Loaded resource from cache\", startTime, key); } return null; } EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache); if (current != null) { current.addCallback(cb); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(\"Added to existing load\", startTime, key); } return new LoadStatus(cb, current); } // 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态） EngineJob&lt;R&gt; engineJob = engineJobFactory.build( key, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache); // 创建解析工作对象 DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build( glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob); // 放在Jobs内部维护的HashMap中 jobs.put(key, engineJob); // 关注点8 后面分析会用到 // 注册ResourceCallback接口 engineJob.addCallback(cb); // 内部开启线程去请求 engineJob.start(decodeJob); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(\"Started new load\", startTime, key); } return new LoadStatus(cb, engineJob); } public void start(DecodeJob&lt;R&gt; decodeJob) { this.decodeJob = decodeJob; // willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor(); executor.execute(decodeJob); } 可以看到，最终Engine(引擎)类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。 DecodeJob#run runWrapped(); private void runWrapped() { switch (runReason) { case INITIALIZE: stage = getNextStage(Stage.INITIALIZE); // 关注点1 currentGenerator = getNextGenerator(); // 关注点2 内部会调用相应Generator的startNext() runGenerators(); break; case SWITCH_TO_SOURCE_SERVICE: runGenerators(); break; case DECODE_DATA: // 关注点3 将获取的数据解码成对应的资源 decodeFromRetrievedData(); break; default: throw new IllegalStateException(\"Unrecognized run reason: \" + runReason); } } // 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext() private DataFetcherGenerator getNextGenerator() { switch (stage) { case RESOURCE_CACHE: return new ResourceCacheGenerator(decodeHelper, this); case DATA_CACHE: return new DataCacheGenerator(decodeHelper, this); case SOURCE: return new SourceGenerator(decodeHelper, this); case FINISHED: return null; default: throw new IllegalStateException(\"Unrecognized stage: \" + stage); } } SourceGenerator#startNext // 关注点2 @Override public boolean startNext() { // dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的） if (dataToCache != null) { Object data = dataToCache; dataToCache = null; cacheData(data); } if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) { return true; } sourceCacheGenerator = null; loadData = null; boolean started = false; while (!started &amp;&amp; hasNextModelLoader()) { // 关注点4 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象 // （每个Generator对应一个ModelLoader）， // 并使用modelLoader.buildLoadData方法返回一个loadData列表 loadData = helper.getLoadData().get(loadDataListIndex++); if (loadData != null &amp;&amp; (helper.getDiskCacheStrategy().isDataCache able(loadData.fetcher.getDataSource()) || helper.hasLoadPath(loadData.fetcher.getDat aClass()))) { started = true; // 关注点6 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的 // loadData方法来获取图片数据 loadData.fetcher.loadData(helper.getPriority(), this); } } return started; } DecodeHelper#getLoadData List&lt;LoadData&lt;?&gt;&gt; getLoadData() { if (!isLoadDataSet) { isLoadDataSet = true; loadData.clear(); List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model) ; //noinspection ForLoopReplaceableByForEach to improve perf for (int i = 0, size = modelLoaders.size(); i &lt; size; i++) { ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i); // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象 LoadData&lt;?&gt; current = modelLoader.buildLoadData(model, width, height, options); if (current != null) { loadData.add(current); } } } return loadData; } HttpGlideUrlLoader#buildLoadData @Override public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height, @NonNull Options options) { // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time // spent parsing urls. GlideUrl url = model; if (modelCache != null) { url = modelCache.get(model, 0, 0); if (url == null) { // 关注点5 modelCache.put(model, 0, 0, model); url = model; } } int timeout = options.get(TIMEOUT); // 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout)); } // 关注点5 public void put(A model, int width, int height, B value) { ModelKey&lt;A&gt; key = ModelKey.get(model, width, height); // 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成） cache.put(key, value); } 从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。 HttpUrlFetcher#loadData @Override public void loadData(@NonNull Priority priority, @NonNull DataCallback&lt;? super InputStream&gt; callback) { long startTime = LogTime.getLogTime(); try { // 关注点6 // loadDataWithRedirects内部是通过HttpURLConnection网络请求数据 InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders()); // 请求成功回调onDataReady() callback.onDataReady(result); } catch (IOException e) { if (Log.isLoggable(TAG, Log.DEBUG)) { Log.d(TAG, \"Failed to load data for url\", e); } callback.onLoadFailed(e); } finally { if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, \"Finished http url fetcher fetch in \" + LogTime.getElapsedMillis(startTime)); } } } private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers) throws IOException { ... urlConnection.connect(); // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352. stream = urlConnection.getInputStream(); if (isCancelled) { return null; } final int statusCode = urlConnection.getResponseCode(); // 只要是2xx形式的状态码则判断为成功 if (isHttpOk(statusCode)) { // 从urlConnection中获取资源流 return getStreamForSuccessfulRequest(urlConnection); } else if (isHttpRedirect(statusCode)) { ... // 重定向请求 return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers); } else if (statusCode == INVALID_STATUS_CODE) { throw new HttpException(statusCode); } else { throw new HttpException(urlConnection.getResponseMessage(), statusCode); } } private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException { if (TextUtils.isEmpty(urlConnection.getContentEncoding())) { int contentLength = urlConnection.getContentLength(); stream = ContentLengthInputStream.obtain(urlConnection.getInputStr eam(), contentLength); } else { if (Log.isLoggable(TAG, Log.DEBUG)) { Log.d(TAG, \"Got non empty content encoding: \" + urlConnection.getContentEncoding()); } stream = urlConnection.getInputStream(); } return stream; } 在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()方法获取到了最终的图片流。 DecodeJob#run 在我们通过HtttpUrlFetcher的loadData()方法请求得到对应的流之后，我们还必须对流进行处理得到最终我们想要的资源。这里我们回到第10步DecodeJob#run方法的关注点3处，这行代码将会对流进行解码。 decodeFromRetrievedData(); 接下来，继续看看他内部的处理。 private void decodeFromRetrievedData() { if (Log.isLoggable(TAG, Log.VERBOSE)) { logWithTimeAndKey(\"Retrieved data\", startFetchTime, \"data: \" + currentData + \", cache key: \" + currentSourceKey + \", fetcher: \" + currentFetcher); } Resource&lt;R&gt; resource = null; try { // 核心代码 // 从数据中解码得到资源 resource = decodeFromData(currentFetcher, currentData, currentDataSource); } catch (GlideException e) { e.setLoggingDetails(currentAttemptingKey, currentDataSource); throwables.add(e); } if (resource != null) { // 关注点8 // 编码和发布最终得到的Resource&lt;Bitmap&gt;对象 notifyEncodeAndRelease(resource, currentDataSource); } else { runGenerators(); } } private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource) throws GlideException { try { if (data == null) { return null; } long startTime = LogTime.getLogTime(); // 核心代码 // 进一步包装了解码方法 Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource); if (Log.isLoggable(TAG, Log.VERBOSE)) { logWithTimeAndKey(\"Decoded result \" + result, startTime); } return result; } finally { fetcher.cleanup(); } } @SuppressWarnings(\"unchecked\") private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource) throws GlideException { LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass()); // 核心代码 // 将解码任务分发给LoadPath return runLoadPath(data, dataSource, path); } private &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data data, DataSource dataSource, LoadPath&lt;Data, ResourceType, R&gt; path) throws GlideException { Options options = getOptionsWithHardwareConfig(dataSource); // 将数据进一步包装 DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data); try { // ResourceType in DecodeCallback below is required for compilation to work with gradle. // 核心代码 // 将解码任务分发给LoadPath return path.load( rewinder, options, width, height, new DecodeCallback&lt;ResourceType&gt;(dataSource)); } finally { rewinder.cleanup(); } } LoadPath#load public Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, int width, int height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) throws GlideException { List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire()); try { // 核心代码 return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables); } finally { listPool.release(throwables); } } private Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, int width, int height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback, List&lt;Throwable&gt; exceptions) throws GlideException { Resource&lt;Transcode&gt; result = null; //noinspection ForLoopReplaceableByForEach to improve perf for (int i = 0, size = decodePaths.size(); i &lt; size; i++) { DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i); try { // 核心代码 // 将解码任务又进一步分发给DecodePath的decode方法去解码 result = path.decode(rewinder, width, height, options, decodeCallback); } catch (GlideException e) { exceptions.add(e); } if (result != null) { break; } } if (result == null) { throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions)); } return result; } DecodePath#decode public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback) throws GlideException { // 核心代码 // 继续调用DecodePath的decodeResource方法去解析出数据 Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options); Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded); return transcoder.transcode(transformed, options); } @NonNull private Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options) throws GlideException { List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire()); try { // 核心代码 return decodeResourceWithList(rewinder, width, height, options, exceptions); } finally { listPool.release(exceptions); } } @NonNull private Resource&lt;ResourceType&gt; decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options, List&lt;Throwable&gt; exceptions) throws GlideException { Resource&lt;ResourceType&gt; result = null; //noinspection ForLoopReplaceableByForEach to improve perf for (int i = 0, size = decoders.size(); i &lt; size; i++) { ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i); try { DataType data = rewinder.rewindAndGet(); if (decoder.handles(data, options)) { // 获取包装的数据 data = rewinder.rewindAndGet(); // 核心代码 // 根据DataType和ResourceType的类型分发给不同的解码器Decoder result = decoder.decode(data, width, height, options); } } catch (IOException | RuntimeException | OutOfMemoryError e) { if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, \"Failed to decode data for \" + decoder, e); } exceptions.add(e); } if (result != null) { break; } } if (result == null) { throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions)); } return result; } 可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder&lt;DataType, ResourceType&gt;接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。 ByteBufferBitmapDecoder#decode /** * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}. */ public class ByteBufferBitmapDecoder implements ResourceDecoder&lt;ByteBuffer, Bitmap&gt; { ... @Override public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width, int height, @NonNull Options options) throws IOException { InputStream is = ByteBufferUtil.toStream(source); // 核心代码 return downsampler.decode(is, width, height, options); } } 可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。 DownSampler#decode public Resource&lt;Bitmap&gt; decode(InputStream is, int outWidth, int outHeight, Options options) throws IOException { return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS); } @SuppressWarnings({\"resource\", \"deprecation\"}) public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight, Options options, DecodeCallbacks callbacks) throws IOException { Preconditions.checkArgument(is.markSupported(), \"You must provide an InputStream that supports\" + \" mark()\"); ... try { // 核心代码 Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions, downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks); // 关注点7 // 解码得到Bitmap对象后，包装成BitmapResource对象返回， // 通过内部的get方法得到Resource&lt;Bitmap&gt;对象 return BitmapResource.obtain(result, bitmapPool); } finally { releaseOptions(bitmapFactoryOptions); byteArrayPool.put(bytesForOptions); } } private Bitmap decodeFromWrappedStreams(InputStream is, BitmapFactory.Options options, DownsampleStrategy downsampleStrategy, DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth, int requestedHeight, boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException { // 省去计算压缩比例等一系列非核心逻辑 ... // 核心代码 Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool); callbacks.onDecodeComplete(bitmapPool, downsampled); ... // Bimtap旋转处理 ... return rotated; } private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options, DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException { ... TransformationUtils.getBitmapDrawableLock().lock(); try { // 核心代码 result = BitmapFactory.decodeStream(is, null, options); } catch (IllegalArgumentException e) { ... } finally { TransformationUtils.getBitmapDrawableLock().unlock(); } if (options.inJustDecodeBounds) { is.reset(); } return result; } 从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到步骤19的DownSampler#decode方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Resource对象，再回到步骤15的DecodeJob#run方法，这是使用了notifyEncodeAndRelease()方法对Resource对象进行了发布。 DecodeJob#notifyEncodeAndRelease private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource dataSource) { ... notifyComplete(result, dataSource); ... } private void notifyComplete(Resource&lt;R&gt; resource, DataSource dataSource) { setNotifiedOrThrow(); callback.onResourceReady(resource, dataSource); } 从以上EngineJob的源码可知，它实现了DecodeJob.CallBack这个接口。 class EngineJob&lt;R&gt; implements DecodeJob.Callback&lt;R&gt;, Poolable { ... } EngineJob#onResourceReady @Override public void onResourceReady(Resource&lt;R&gt; resource, DataSource dataSource) { this.resource = resource; this.dataSource = dataSource; MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget(); } private static class MainThreadCallback implements Handler.Callback{ ... @Override public boolean handleMessage(Message message) { EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj; switch (message.what) { case MSG_COMPLETE: // 核心代码 job.handleResultOnMainThread(); break; ... } return true; } } 从以上源码可知，通过主线程Handler对象进行切换线程，然后在主线程调用了handleResultOnMainThread这个方法。 @Synthetic void handleResultOnMainThread() { ... //noinspection ForLoopReplaceableByForEach to improve perf for (int i = 0, size = cbs.size(); i &lt; size; i++) { ResourceCallback cb = cbs.get(i); if (!isInIgnoredCallbacks(cb)) { engineResource.acquire(); cb.onResourceReady(engineResource, dataSource); } } ... } 这里又通过一个循环调用了所有ResourceCallback的方法，让我们回到步骤9处Engine#load方法的关注点8这行代码，这里对ResourceCallback进行了注册，在步骤8出SingleRequest#onSizeReady方法里的engine.load中，我们看到最后一个参数，传入的是this，可以明白，engineJob.addCallback(cb)这里的cb的实现类就是SingleRequest。接下来，让我们看看SingleRequest的onResourceReady方法。 SingleRequest#onResourceReady /** * A callback method that should never be invoked directly. */ @SuppressWarnings(\"unchecked\") @Override public void onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) { ... // 从Resource&lt;Bitmap&gt;中得到Bitmap对象 Object received = resource.get(); ... onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource); } private void onResourceReady(Resource&lt;R&gt; resource, R resultDataSource dataSource) { ... try { ... if (!anyListenerHandledUpdatingTarget) { Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource); // 核心代码 target.onResourceReady(result, animation); } } finally { isCallingCallbacks = false; } notifyLoadSuccess(); } 在SingleRequest#onResourceReady方法中又调用了target.onResourceReady(result, animation)方法，这里的target其实就是我们在into方法中建立的那个BitmapImageViewTarget，看到BitmapImageViewTarget类，我们并没有发现onResourceReady方法，但是我们从它的子类ImageViewTarget中发现了onResourceReady方法，从这里继续往下看。 ImageViewTarget#onResourceReady public abstract class ImageViewTarget&lt;Z&gt; extends ViewTarget&lt;ImageView, Z&gt; implements Transition.ViewAdapter { ... @Override public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) { if (transition == null || !transition.transition(resource, this)) { // 核心代码 setResourceInternal(resource); } else { maybeUpdateAnimatable(resource); } } ... private void setResourceInternal(@Nullable Z resource) { // Order matters here. Set the resource first to make sure that the Drawable has a valid and // non-null Callback before starting it. // 核心代码 setResource(resource); maybeUpdateAnimatable(resource); } // 核心代码 protected abstract void setResource(@Nullable Z resource); } 这里我们在回到BitmapImageViewTarget的setResource方法中，终于看到Bitmap被设置到了当前的imageView上了。 public class BitmapImageViewTarget extends ImageViewTarget&lt;Bitmap&gt; { ... @Override protected void setResource(Bitmap resource) { view.setImageBitmap(resource); } } 到这里，我们的分析就结束了，从以上的分析可知，Glide将大部分的逻辑处理都放在了最后一个into方法中，里面经过了20多个分析步骤才将请求图片流、解码出图片，到最终设置到对应的imageView上。 完整Glide加载流程图 可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。 GreenDao 基本使用流程 导入GreenDao的代码生成插件和库 // 项目下的build.gradle buildscript { ... dependencies { classpath 'com.android.tools.build:gradle:2.3.0' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' } } // app模块下的build.gradle apply plugin: 'com.android.application' apply plugin: 'org.greenrobot.greendao' ... dependencies { ... compile 'org.greenrobot:greendao:3.2.0' } 创建一个实体类，这里为HistoryData @Entity public class HistoryData { @Id(autoincrement = true) private Long id; private long date; private String data; } 选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。 @Entity public class HistoryData { @Id(autoincrement = true) private Long id; private long date; private String data; @Generated(hash = 1371145256) public HistoryData(Long id, long date, String data) { this.id = id; this.date = date; this.data = data; } @Generated(hash = 422767273) public HistoryData() { } public Long getId() { return this.id; } public void setId(Long id) { this.id = id; } public long getDate() { return this.date; } public void setDate(long date) { this.date = date; } public String getData() { return this.data; } public void setData(String data) { this.data = data; } } 这里点明一下这几个类的作用： DaoMaster：所有Dao类的主人，负责整个库的运行，内部的静态抽象子类DevOpenHelper继承并重写了Android的SqliteOpenHelper。 DaoSession：作为一个会话层的角色，用于生成相应的Dao对象、Dao对象的注册，操作Dao的具体对象。 xxDao（HistoryDataDao）：生成的Dao对象，用于进行具体的数据库操作。 获取并使用相应的Dao对象进行增删改查操作 DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME); SQLiteDatabase database = devOpenHelper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(database); mDaoSession = daoMaster.newSession(); HistoryDataDao historyDataDao = daoSession.getHistoryDataDao(); // 省略创建historyData的代码 ... // 增 historyDataDao.insert(historyData); // 删 historyDataDao.delete(historyData); // 改 historyDataDao.update(historyData); // 查 List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll(); 本节将会以上述使用流程来对GreenDao的源码进行逐步分析，最后会分析下GreenDao中一些优秀的特性，让大家对GreenDao的理解有更一步的加深。 GreenDao使用流程分析 创建数据库帮助类对象DaoMaster.DevOpenHelper DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME); 创建GreenDao内部实现的数据库帮助类对象devOpenHelper，核心源码如下： public class DaoMaster extends AbstractDaoMaster { ... public static abstract class OpenHelper extends DatabaseOpenHelper { ... @Override public void onCreate(Database db) { Log.i(\"greenDAO\", \"Creating tables for schema version \" + SCHEMA_VERSION); createAllTables(db, false); } } public static class DevOpenHelper extends OpenHelper { ... @Override public void onUpgrade(Database db, int oldVersion, int newVersion) { Log.i(\"greenDAO\", \"Upgrading schema from version \" + oldVersion + \" to \" + newVersion + \" by dropping all tables\"); dropAllTables(db, true); onCreate(db); } } } DevOpenHelper自身实现了更新的逻辑，这里是弃置了所有的表，并且调用了OpenHelper实现的onCreate方法用于创建所有的表，其中DevOpenHelper继承于OpenHelper，而OpenHelper自身又继承于DatabaseOpenHelper，那么，这个DatabaseOpenHelper这个类的作用是什么呢？ public abstract class DatabaseOpenHelper extends SQLiteOpenHelper { ... // 关注点1 public Database getWritableDb() { return wrap(getWritableDatabase()); } public Database getReadableDb() { return wrap(getReadableDatabase()); } protected Database wrap(SQLiteDatabase sqLiteDatabase) { return new StandardDatabase(sqLiteDatabase); } ... // 关注点2 public Database getEncryptedWritableDb(String password) { EncryptedHelper encryptedHelper = checkEncryptedHelper(); return encryptedHelper.wrap(encryptedHelper.getWritableDatabase(password)); } public Database getEncryptedReadableDb(String password) { EncryptedHelper encryptedHelper = checkEncryptedHelper(); return encryptedHelper.wrap(encryptedHelper.getReadableDatabase(password)); } ... private class EncryptedHelper extends net.sqlcipher.database.SQLiteOpenHelper { ... protected Database wrap(net.sqlcipher.database.SQLiteDatabase sqLiteDatabase) { return new EncryptedDatabase(sqLiteDatabase); } } 其实，DatabaseOpenHelper也是实现了SQLiteOpenHelper的一个帮助类，它内部可以获取到两种不同的数据库类型，一种是标准型的数据库StandardDatabase，另一种是加密型的数据库EncryptedDatabase，从以上源码可知，它们内部都通过wrap这样一个包装的方法，返回了对应的数据库类型，我们大致看一下StandardDatabase和EncryptedDatabase的内部实现。 public class StandardDatabase implements Database { // 这里的SQLiteDatabase是android.database.sqlite.SQLiteDatabase包下的 private final SQLiteDatabase delegate; public StandardDatabase(SQLiteDatabase delegate) { this.delegate = delegate; } @Override public Cursor rawQuery(String sql, String[] selectionArgs) { return delegate.rawQuery(sql, selectionArgs); } @Override public void execSQL(String sql) throws SQLException { delegate.execSQL(sql); } ... } public class EncryptedDatabaseStatement implements DatabaseStatement { // 这里的SQLiteStatement是net.sqlcipher.database.SQLiteStatement包下的 private final SQLiteStatement delegate; public EncryptedDatabaseStatement(SQLiteStatement delegate) { this.delegate = delegate; } @Override public void execute() { delegate.execute(); } ... } StandardDatabase和EncryptedDatabase这两个类内部都使用了代理模式给相同的接口添加了不同的具体实现，StandardDatabase自然是使用的Android包下的SQLiteDatabase，而EncryptedDatabaseStatement为了实现加密数据库的功能，则使用了一个叫做sqlcipher的数据库加密三方库，如果你项目下的数据库需要保存比较重要的数据，则可以使用getEncryptedWritableDb方法来代替getdWritableDb方法对数据库进行加密，这样，我们之后的数据库操作则会以代理模式的形式间接地使用sqlcipher提供的API去操作数据库。 创建DaoMaster对象 SQLiteDatabase database = devOpenHelper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(database); 首先，DaoMaster作为所有Dao对象的主人，它内部肯定是需要一个SQLiteDatabase对象的，因此，先由DaoMaster的帮助类对象devOpenHelper的getWritableDatabase方法得到一个标准的数据库类对象database，再由此创建一个DaoMaster对象。 public class DaoMaster extends AbstractDaoMaster { ... public DaoMaster(SQLiteDatabase db) { this(new StandardDatabase(db)); } public DaoMaster(Database db) { super(db, SCHEMA_VERSION); registerDaoClass(HistoryDataDao.class); } ... } 在DaoMaster的构造方法中，它首先执行了super(db, SCHEMA_VERSION)方法，即它的父类AbstractDaoMaster的构造方法。 public abstract class AbstractDaoMaster { ... public AbstractDaoMaster(Database db, int schemaVersion) { this.db = db; this.schemaVersion = schemaVersion; daoConfigMap = new HashMap&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;(); } protected void registerDaoClass(Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt; daoClass) { DaoConfig daoConfig = new DaoConfig(db, daoClass); daoConfigMap.put(daoClass, daoConfig); } ... } 在AbstractDaoMaster对象的构造方法中，除了记录当前的数据库对象db和版本schemaVersion之外，还创建了一个类型为HashMap&lt;Class&gt;, DaoConfig&gt;()的daoConfigMap对象用于保存每一个DAO对应的数据配置对象DaoConfig，并且Daoconfig对象存储了对应的Dao对象所必需的数据。最后，在DaoMaster的构造方法中使用了registerDaoClass(HistoryDataDao.class)方法将HistoryDataDao类对象进行了注册，实际上，就是为HistoryDataDao这个Dao对象创建了相应的DaoConfig对象并将它放入daoConfigMap对象中保存起来。 创建DaoSession对象 mDaoSession = daoMaster.newSession(); 在DaoMaster对象中使用了newSession方法新建了一个DaoSession对象。 public DaoSession newSession() { return new DaoSession(db, IdentityScopeType.Session, daoConfigMap); } 在DaoSeesion的构造方法中，又做了哪些事情呢？ public class DaoSession extends AbstractDaoSession { ... public DaoSession(Database db, IdentityScopeType type, Map&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt; daoConfigMap) { super(db); historyDataDaoConfig = daoConfigMap.get(HistoryDataDao.class).clone(); historyDataDaoConfig.initIdentityScope(type); historyDataDao = new HistoryDataDao(historyDataDaoConfig, this); registerDao(HistoryData.class, historyDataDao); } ... } 首先，调用了父类AbstractDaoSession的构造方法。 public class AbstractDaoSession { ... public AbstractDaoSession(Database db) { this.db = db; this.entityToDao = new HashMap&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt;(); } protected &lt;T&gt; void registerDao(Class&lt;T&gt; entityClass, AbstractDao&lt;T, ?&gt; dao) { entityToDao.put(entityClass, dao); } ... } 在AbstractDaoSession构造方法里面创建了一个实体与Dao对象的映射集合。接下来，在DaoSession的构造方法中还做了2件事： 创建每一个Dao对应的DaoConfig对象，这里是historyDataDaoConfig，并且根据IdentityScopeType的类型初始化创建一个相应的IdentityScope，根据type的不同，它有两种类型，分别是IdentityScopeObject和IdentityScopeLong，它的作用是根据主键缓存对应的实体数据。当主键是数字类型的时候，如long/Long、int/Integer、short/Short、byte/Byte，则使用IdentityScopeLong缓存实体数据，当主键不是数字类型的时候，则使用IdentityScopeObject缓存实体数据。 根据DaoSession对象和每一个Dao对应的DaoConfig对象，创建与之对应的historyDataDao对象，由于这个项目只创建了一个实体类HistoryData，因此这里只有一个Dao对象historyDataDao，然后就是注册Dao对象，其实就是将实体和对应的Dao对象放入entityToDao这个映射集合中保存起来了。 插入源码分析 HistoryDataDao historyDataDao = daoSession.getHistoryDataDao(); // 增 historyDataDao.insert(historyData); 这里首先在会话层DaoSession中获取了我们要操作的Dao对象HistoryDataDao，然后插入了一个我们预先创建好的historyData实体对象。其中HistoryDataDao继承了AbstractDao&lt;HistoryData, Long&gt; 。 public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; { ... } 那么，这个AbstractDao是干什么的呢？ public abstract class AbstractDao&lt;T, K&gt; { ... public List&lt;T&gt; loadAll() { Cursor cursor = db.rawQuery(statements.getSelectAll(), null); return loadAllAndCloseCursor(cursor); } ... public long insert(T entity) { return executeInsert(entity, statements.getInsertStatement(), true); } ... public void delete(T entity) { assertSinglePk(); K key = getKeyVerified(entity); deleteByKey(key); } ... } 看到这里，根据程序员优秀的直觉，大家应该能猜到，AbstractDao是所有Dao对象的基类，它实现了实体数据的操作如增删改查。我们接着分析insert是如何实现的，在AbstractDao的insert方法中又调用了executeInsert这个方法。在这个方法中，第二个参里的statements是一个TableStatements对象，它是在AbstractDao初始化构造器时从DaoConfig对象中取出来的，是一个根据指定的表格创建SQL语句的一个帮助类。使用statements.getInsertStatement()则是获取了一个插入的语句。而第三个参数则是判断是否是主键的标志。 public class TableStatements { ... public DatabaseStatement getInsertStatement() { if (insertStatement == null) { String sql = SqlUtils.createSqlInsert(\"INSERT INTO \", tablename, allColumns); DatabaseStatement newInsertStatement = db.compileStatement(sql); ... } return insertStatement; } ... } 在TableStatements的getInsertStatement方法中，主要做了两件事： 使用SqlUtils创建了插入的sql语句。 根据不同的数据库类型（标准数据库或加密数据库）将sql语句编译成当前数据库对应的语句。 我们继续往下分析executeInsert的执行流程。 private long executeInsert(T entity, DatabaseStatement stmt, boolean setKeyAndAttach) { long rowId; if (db.isDbLockedByCurrentThread()) { rowId = insertInsideTx(entity, stmt); } else { db.beginTransaction(); try { rowId = insertInsideTx(entity, stmt); db.setTransactionSuccessful(); } finally { db.endTransaction(); } } if (setKeyAndAttach) { updateKeyAfterInsertAndAttach(entity, rowId, true); } return rowId; } 这里首先是判断数据库是否被当前线程锁定，如果是，则直接插入数据，否则为了避免死锁，则开启一个数据库事务，再进行插入数据的操作。最后如果设置了主键，则在插入数据之后更新主键的值并将对应的实体缓存到相应的identityScope中，这一块的代码流程如下所示： protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) { if (rowId != -1) { K key = updateKeyAfterInsert(entity, rowId); attachEntity(key, entity, lock); } else { ... } } protected final void attachEntity(K key, T entity, boolean lock) { attachEntity(entity); if (identityScope != null &amp;&amp; key != null) { if (lock) { identityScope.put(key, entity); } else { identityScope.putNoLock(key, entity); } } } 接着，我们还是继续追踪主线流程，在executeInsert这个方法中调用了insertInsideTx进行数据的插入。 private long insertInsideTx(T entity, DatabaseStatement stmt) { synchronized (stmt) { if (isStandardSQLite) { SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement(); bindValues(rawStmt, entity); return rawStmt.executeInsert(); } else { bindValues(stmt, entity); return stmt.executeInsert(); } } } 为了防止并发，这里使用了悲观锁保证了数据的一致性，在AbstractDao这个类中，大量使用了这种锁保证了它的线程安全性。接着，如果当前是标准数据库，则直接获取stmt这个DatabaseStatement类对应的原始语句进行实体字段属性的绑定和最后的执行插入操作。如果是加密数据库，则直接使用当前的加密数据库所属的插入语句进行实体字段属性的绑定和执行最后的插入操作。其中bindValues这个方法对应的实现类就是我们的HistoryDataDao类。 public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; { ... @Override protected final void bindValues(DatabaseStatement stmt, HistoryData entity) { stmt.clearBindings(); Long id = entity.getId(); if (id != null) { stmt.bindLong(1, id); } stmt.bindLong(2, entity.getDate()); String data = entity.getData(); if (data != null) { stmt.bindString(3, data); } } @Override protected final void bindValues(SQLiteStatement stmt, HistoryData entity) { stmt.clearBindings(); Long id = entity.getId(); if (id != null) { stmt.bindLong(1, id); } stmt.bindLong(2, entity.getDate()); String data = entity.getData(); if (data != null) { stmt.bindString(3, data); } } ... } 可以看到，这里对HistoryData的所有字段使用对应的数据库语句进行了绑定操作。这里最后再提及一下，如果当前数据库是加密型时，则会使用最开始提及的DatabaseStatement的加密实现类EncryptedDatabaseStatement应用代理模式去使用sqlcipher这个加密型数据库的insert方法。 查询源码分析 经过对插入源码的分析，相信大家对GreenDao内部的机制已经有了一些自己的理解，由于删除和更新内部的流程比较简单，且与插入源码有异曲同工之妙，这里就不再赘述了。最后再分析下查询的源码，查询的流程调用链较长，所以将它的核心流程源码直接给出。 List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll(); public List&lt;T&gt; loadAll() { Cursor cursor = db.rawQuery(statements.getSelectAll(), null); return loadAllAndCloseCursor(cursor); } protected List&lt;T&gt; loadAllAndCloseCursor(Cursor cursor) { try { return loadAllFromCursor(cursor); } finally { cursor.close(); } } protected List&lt;T&gt; loadAllFromCursor(Cursor cursor) { int count = cursor.getCount(); ... boolean useFastCursor = false; if (cursor instanceof CrossProcessCursor) { window = ((CrossProcessCursor) cursor).getWindow(); if (window != null) { if (window.getNumRows() == count) { cursor = new FastCursor(window); useFastCursor = true; } else { ... } } } if (cursor.moveToFirst()) { ... try { if (!useFastCursor &amp;&amp; window != null &amp;&amp; identityScope != null) { loadAllUnlockOnWindowBounds(cursor, window, list); } else { do { list.add(loadCurrent(cursor, 0, false)); } while (cursor.moveToNext()); } } finally { ... } } return list; } 最终，loadAll方法将会调用到loadAllFromCursor这个方法，首先，如果当前的游标cursor是跨进程的cursor，并且cursor的行数没有偏差的话，则使用一个加快版的FastCursor对象进行游标遍历。接着，不管是执行loadAllUnlockOnWindowBounds这个方法还是直接加载当前的数据列表list.add(loadCurrent(cursor, 0, false))，最后都会调用到这行list.add(loadCurrent(cursor, 0, false))代码，很明显，loadCurrent方法就是加载数据的方法。 final protected T loadCurrent(Cursor cursor, int offset, boolean lock) { if (identityScopeLong != null) { ... T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key); if (entity != null) { return entity; } else { entity = readEntity(cursor, offset); attachEntity(entity); if (lock) { identityScopeLong.put2(key, entity); } else { identityScopeLong.put2NoLock(key, entity); } return entity; } } else if (identityScope != null) { ... T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key); if (entity != null) { return entity; } else { entity = readEntity(cursor, offset); attachEntity(key, entity, lock); return entity; } } else { ... T entity = readEntity(cursor, offset); attachEntity(entity); return entity; } } loadCurrent方法内部的执行策略 首先，如果有实体数据缓存identityScopeLong/identityScope，则先从缓存中取，如果缓存中没有，会使用该实体对应的Dao对象，这里的是HistoryDataDao，它在内部根据游标取出的数据新建了一个新的HistoryData实体对象返回。 @Override public HistoryData readEntity(Cursor cursor, int offset) { HistoryData entity = new HistoryData( // cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id cursor.getLong(offset + 1), // date cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2) // data ); return entity; } 最后，如果是非identityScopeLong缓存类型，即是属于identityScope的情况下，则还会在identityScope中将上面获得的数据进行缓存。如果没有实体数据缓存的话，则直接调用readEntity组装数据返回即可。 注意：对于GreenDao缓存的特性，可能会出现没有拿到最新数据的bug，因此，如果遇到这种情况，可以使用DaoSession的clear方法删除缓存。 GreenDao是如何与ReactiveX结合？ 首先，看下与rx结合的使用流程： RxDao&lt;HistoryData, Long&gt; xxDao = daoSession.getHistoryDataDao().rx(); xxDao.insert(historyData) .observerOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;HistoryData&gt;() { @Override public void call(HistoryData entity) { // insert success } }); 在AbstractDao对象的.rx()方法中，创建了一个默认执行在io线程的rxDao对象。 @Experimental public RxDao&lt;T, K&gt; rx() { if (rxDao == null) { rxDao = new RxDao&lt;&gt;(this, Schedulers.io()); } return rxDao; } 接着分析rxDao的insert方法。 @Experimental public Observable&lt;T&gt; insert(final T entity) { return wrap(new Callable&lt;T&gt;() { @Override public T call() throws Exception { dao.insert(entity); return entity; } }); } 起实质作用的就是这个wrap方法了，在这个方法里面主要是调用了RxUtils.fromCallable(callable)这个方法。 @Internal class RxBase { ... protected &lt;R&gt; Observable&lt;R&gt; wrap(Callable&lt;R&gt; callable) { return wrap(RxUtils.fromCallable(callable)); } protected &lt;R&gt; Observable&lt;R&gt; wrap(Observable&lt;R&gt; observable) { if (scheduler != null) { return observable.subscribeOn(scheduler); } else { return observable; } } ... } 在RxUtils的fromCallable这个方法内部，其实就是使用defer这个延迟操作符来进行被观察者事件的发送，主要目的就是为了确保Observable被订阅后才执行。最后，如果调度器scheduler存在的话，将通过外部的wrap方法将执行环境调度到io线程。 @Internal class RxUtils { @Internal static &lt;T&gt; Observable&lt;T&gt; fromCallable(final Callable&lt;T&gt; callable) { return Observable.defer(new Func0&lt;Observable&lt;T&gt;&gt;() { @Override public Observable&lt;T&gt; call() { T result; try { result = callable.call(); } catch (Exception e) { return Observable.error(e); } return Observable.just(result); } }); } } 在分析完GreenDao的核心源码之后发现，GreenDao作为最好的数据库框架之一，是有一定道理的。 首先，它通过使用自身的插件配套相应的freemarker模板生成所需的静态代码，避免了反射等消耗性能的操作。 其次，它内部提供了实体数据的映射缓存机制，能够进一步加快查询速度。对于不同数据库对应的SQL语句，也使用了不同的DataBaseStatement实现类结合代理模式进行了封装，屏蔽了数据库操作等繁琐的细节。 最后，它使用了sqlcipher提供了加密数据库的功能，在一定程度确保了安全性，同时，结合RxJava，我们便能更简洁地实现异步的数据库操作。 RxJava RxJava到底是什么？ RxJava是基于Java虚拟机上的响应式扩展库，它通过使用可观察的序列将异步和基于事件的程序组合起来。 与此同时，它扩展了观察者模式来支持数据/事件序列，并且添加了操作符，这些操作符允许你声明性地组合序列，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。 从RxJava的官方定义来看，我们如果要想真正地理解RxJava，就必须对它以下两个部分进行深入的分析： 订阅流程 线程切换 当然，RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂。 RxJava的订阅流程 首先给出RxJava消息订阅的例子： Observable.create(newObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception { emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onComplete(); } }).subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, \"onSubscribe\"); } @Override public void onNext(String s) { Log.d(TAG, \"onNext : \" + s); } @Override public void onError(Throwable e) { Log.d(TAG, \"onError : \" + e.toString()); } @Override public void onComplete() { Log.d(TAG, \"onComplete\"); } }); 可以看到，这里首先创建了一个被观察者，然后创建一个观察者订阅了这个被观察者，因此下面分两个部分对RxJava的订阅流程进行分析： 创建被观察者过程 订阅过程 创建被观察者过程 首先，上面使用了Observable类的create()方法创建了一个被观察者，看看里面做了什么。 Observable#create() // 省略一些检测性的注解 public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) { ObjectHelper.requireNonNull(source, \"source is null\"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source)); } 在Observable的create()里面实际上是创建了一个新的ObservableCreate对象，同时，把我们定义好的ObservableOnSubscribe对象传入了ObservableCreate对象中，最后调用了RxJavaPlugins.onAssembly()方法。接下来看看这个ObservableCreate是干什么的。 ObservableCreate public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; { final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) { this.source = source; } ... } 这里仅仅是把ObservableOnSubscribe这个对象保存在ObservableCreate中了。然后看看RxJavaPlugins.onAssembly()这个方法的处理。 RxJavaPlugins#onAssembly() public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) { // 应用hook函数的一些处理，一般用到不到 ... return source; } 最终仅仅是把我们的ObservableCreate给返回了。 创建被观察者过程小结 从以上分析可知，Observable.create()方法仅仅是先将我们自定义的ObservableOnSubscribe对象重新包装成了一个ObservableCreate对象。 订阅过程 接着，看看Observable.subscribe()的订阅过程是如何实现的。 Observable#subscribe() public final void subscribe(Observer&lt;? super T&gt; observer) { ... // 1 observer = RxJavaPlugins.onSubscribe(this,observer); ... // 2 subscribeActual(observer); ... } 在注释1处，在Observable的subscribe()方法内部首先调用了RxJavaPlugins的onSubscribe()方法。 RxJavaPlugins#onSubscribe() public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) { // 应用hook函数的一些处理，一般用到不到 ... return observer; } 除去hook应用的逻辑，这里仅仅是将observer返回了。接着来分析下注释2处的subscribeActual()方法， Observable#subscribeActual() protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 这是一个抽象的方法，很明显，它对应的具体实现类就是我们在第一步创建的ObservableCreate类，接下来看到ObservableCreate的subscribeActual()方法。 ObservableCreate#subscribeActual() @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { // 1 CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 2 observer.onSubscribe(parent); try { // 3 source.subscribe(parent); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); parent.onError(ex); } } 在注释1处，首先新创建了一个CreateEmitter对象，同时传入了我们自定义的observer对象进去。 CreateEmitter static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable { ... final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) { this.observer = observer; } ... } 从上面可以看出，CreateEmitter通过继承了Java并发包中的原子引用类AtomicReference保证了事件流切断状态Dispose的一致性（这里不理解的话，看到后面讲解Dispose的时候就明白了），并实现了ObservableEmitter接口和Disposable接口，接着我们分析下注释2处的observer.onSubscribe(parent)，这个onSubscribe回调的含义其实就是告诉观察者已经成功订阅了被观察者。再看到注释3处的source.subscribe(parent)这行代码，这里的source其实是ObservableOnSubscribe对象，我们看到ObservableOnSubscribe的subscribe()方法。 ObservableOnSubscribe#subscribe() Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public voidsubscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception { emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onComplete(); } }); 这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()方法完成了订阅过程。ObservableEmitter是一个抽象类，实现类就是我们传入的CreateEmitter对象，接下来我们看看CreateEmitter的onNext()方法和onComplete()方法的处理。 CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete() static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable { ... @Override public void onNext(T t) { ... if (!isDisposed()) { //调用观察者的onNext() observer.onNext(t); } } @Override public void onComplete() { if (!isDisposed()) { try { observer.onComplete(); } finally { dispose(); } } } ... } 在CreateEmitter的onNext和onComplete方法中首先都要经过一个isDisposed的判断，作用就是看当前的事件流是否被切断（废弃）掉了，默认是不切断的，如果想要切断，可以调用Disposable的dispose()方法将此状态设置为切断（废弃）状态。继续看看这个isDisposed内部的处理。 ObservableEmitter#isDisposed() @Override public boolean isDisposed() { return DisposableHelper.isDisposed(get()); } 注意到这里通过get()方法首先从ObservableEmitter的AtomicReference中拿到了保存的Disposable状态。然后交给了DisposableHelper进行判断处理。接下来看看DisposableHelper的处理。 DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set() public enum DisposableHelper implements Disposable { DISPOSED; public static boolean isDisposed(Disposable d) { // 1 return d == DISPOSED; } public static boolean set(AtomicReference&lt;Disposable&gt; field, Disposable d) { for (;;) { Disposable current = field.get(); if (current == DISPOSED) { if (d != null) { d.dispose(); } return false; } // 2 if (field.compareAndSet(current, d)) { if (current != null) { current.dispose(); } return true; } } } ... public static boolean dispose(AtomicReference&lt;Disposable&gt; field) { Disposable current = field.get(); Disposable d = DISPOSED; if (current != d) { // ... current = field.getAndSet(d); if (current != d) { if (current != null) { current.dispose(); } return true; } } return false; } ... } DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来标记事件流被切断（废弃）状态的。先看到注释2和注释3处的代码field.compareAndSet(current, d)和field.getAndSet(d)，这里使用了原子引用AtomicReference内部包装的CAS方法处理了标志Disposable的并发读写问题。最后看到注释3处，将我们传入的CreateEmitter这个原子引用类保存的Dispable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。为了更进一步理解Disposed的作用，再来看看CreateEmitter中剩余的关键方法。 CreateEmitter @Override public void onNext(T t) { ... // 1 if (!isDisposed()) { observer.onNext(t); } } @Override public void onError(Throwable t) { if (!tryOnError(t)) { // 2 RxJavaPlugins.onError(t); } } @Override public boolean tryOnError(Throwable t) { ... // 3 if (!isDisposed()) { try { observer.onError(t); } finally { // 4 dispose(); } return true; } return false; } @Override public void onComplete() { // 5 if (!isDisposed()) { try { observer.onComplete(); } finally { // 6 dispose(); } } } 在注释1、3、5处，onNext()和onError()、onComplete()方法首先都会判断事件流是否被切断，如果事件流此时被切断了，那么onNext()和onComplete()则会退出方法体，不做处理，onError()则会执行到RxJavaPlugins.onError(t)这句代码，内部会直接抛出异常，导致崩溃。如果事件流没有被切断，那么在onError()和onComplete()内部最终会调用到注释4、6处的这句dispose()代码，将事件流进行切断，由此可知，onError()和onComplete()只能调用一个，如果先执行的是onComplete()，再调用onError()的话就会导致异常崩溃。 RxJava的线程切换 首先给出RxJava线程切换的例子： Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public voidsubscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception { emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onComplete(); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, \"onSubscribe\"); } @Override public void onNext(String s) { Log.d(TAG, \"onNext : \" + s); } @Override public void onError(Throwable e) { Log.d(TAG, \"onError : \" +e.toString()); } @Override public void onComplete() { Log.d(TAG, \"onComplete\"); } }); 可以看到，RxJava的线程切换主要分为subscribeOn()和observeOn()方法，首先，来分析下subscribeOn()方法。 subscribeOn(Schedulers.io()) 在Schedulers.io()方法中，我们需要先传入一个Scheduler调度类，这里是传入了一个调度到io子线程的调度类，我们看看这个Schedulers.io()方法内部是怎么构造这个调度器的。 Schedulers#io() static final Scheduler IO; ... public static Scheduler io() { // 1 return RxJavaPlugins.onIoScheduler(IO); } static { ... // 2 IO = RxJavaPlugins.initIoScheduler(new IOTask()); } static final class IOTask implements Callable&lt;Scheduler&gt; { @Override public Scheduler call() throws Exception { // 3 return IoHolder.DEFAULT; } } static final class IoHolder { // 4 static final Scheduler DEFAULT = new IoScheduler(); } Schedulers这个类的代码很多，这里我只拿出有关Schedulers.io这个方法涉及的逻辑代码进行讲解。首先，在注释1处，同前面分析的订阅流程的处理一样，只是一个处理hook的逻辑，最终返回的还是传入的这个IO对象。再看到注释2处，在Schedulers的静态代码块中将IO对象进行了初始化，其实质就是新建了一个IOTask的静态内部类，在IOTask的call方法中，也就是注释3处，可以了解到使用了静态内部类的方式把创建的IOScheduler对象给返回出去了。绕了这么大圈子，Schedulers.io方法其实质就是返回了一个IOScheduler对象。 Observable#subscribeOn() public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) { ... return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler)); } 在subscribeOn()方法里面，又将ObservableCreate包装成了一个ObservableSubscribeOn对象。我们关注到ObservableSubscribeOn类。 ObservableSubscribeOn public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; { final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) { // 1 super(source); this.scheduler = scheduler; } @Override public void subscribeActual(final Observer&lt;? super T&gt; observer) { // 2 final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer); // 3 observer.onSubscribe(parent); // 4 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); } ... } 首先，在注释1处，将传进来的source和scheduler保存起来。接着，等到实际订阅的时候，就会执行到这个subscribeActual方法，在注释2处，将我们自定义的Observer包装成了一个SubscribeOnObserver对象。在注释3处，通知观察者订阅了被观察者。在注释4处，内部先创建了一个SubscribeTask对象，来看看它的实现。 ObservableSubscribeOn#SubscribeTask final class SubscribeTask implements Runnable { private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) { this.parent = parent; } @Override public void run() { source.subscribe(parent); } } SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)的订阅方法，这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象。接下来看看scheduler.scheduleDirect()内部的处理。 Scheduler#scheduleDirect() public Disposable scheduleDirect(@NonNull Runnable run) { return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS); } public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { // 1 final Worker w = createWorker(); // 2 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 3 DisposeTask task = new DisposeTask(decoratedRun, w); // 4 w.schedule(task, delay, unit); return task; } 这里最后会执行到上面这个scheduleDirect()重载方法。首先，在注释1处，会调用createWorker()方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面看看IoScheduler类的createWorker()方法。 IOScheduler#createWorker() final AtomicReference&lt;CachedWorkerPool&gt; pool; ... public IoScheduler(ThreadFactory threadFactory) { this.threadFactory = threadFactory; this.pool = new AtomicReference&lt;CachedWorkerPool&gt;(NONE); start(); } ... @Override public Worker createWorker() { // 1 return new EventLoopWorker(pool.get()); } static final class EventLoopWorker extends Scheduler.Worker { ... EventLoopWorker(CachedWorkerPool pool) { this.pool = pool; this.tasks = new CompositeDisposable(); // 2 this.threadWorker = pool.get(); } } 首先，在注释1处调用了pool.get()这个方法，pool是一个CachedWorkerPool类型的原子引用对象，它的作用就是用于缓存工作者对象Worker的。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里将CachedWorkerPool缓存的threadWorker对象保存起来了。 下面继续分析3.6处代码段的注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个切断任务DisposeTask将decoratedRun和w对象包装了起来。最后在注释4处调用了工作者的schedule()方法。下面来分析下它内部的处理。 IoScheduler#schedule() @Override public Disposable schedule(@NonNull Runnableaction, long delayTime, @NonNull TimeUnit unit){ ... return threadWorker.scheduleActual(action,delayTime, unit, tasks); } 内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()方法，继续看看NewThreadWorker的scheduleActual()方法中做的事情。 NewThreadWorker#scheduleActual() public NewThreadWorker(ThreadFactory threadFactory) { executor = SchedulerPoolFactory.create(threadFactory); } @NonNull public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) { Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 1 ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) { if (!parent.add(sr)) { return sr; } } Future&lt;?&gt; f; try { // 2 if (delayTime &lt;= 0) { // 3 f = executor.submit((Callable&lt;Object&gt;)sr); } else { // 4 f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); } sr.setFuture(f); } catch (RejectedExecutionException ex) { if (parent != null) { parent.remove(sr); } RxJavaPlugins.onError(ex); } return sr; } 在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，它是一个保存所有事件流是否被切断状态的容器，其内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类进行存储。最后注释2处，判断是否设置了延迟时间，如果设置了，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()方法进行延时执行线程切换。 为什么多次执行subscribeOn()，只有第一次有效？ 从上面的分析，可以很容易了解到被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe），当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()方法，这样肯定会覆盖前面的线程切换。 observeOn(AndroidSchedulers.mainThread()) public final Observable&lt;T&gt; observeOn(Scheduler scheduler) { return observeOn(scheduler, false, bufferSize()); } public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) { .... return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize)); } 可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，直接来看看ObservableObserveOn的subscribeActual()方法。 ObservableObserveOn#subscribeActual() @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { // 1 if (scheduler instanceof TrampolineScheduler) { // 2 source.subscribe(observer); } else { // 3 Scheduler.Worker w = scheduler.createWorker(); // 4 source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); } } 首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，立即执行当前代码的调度器。如果是，则会直接调用ObservableSubscribeOn的subscribe()方法，如果不是，则会在注释3处创建一个工作者对象。然后，在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()方法进行订阅。接下来看看ObserveOnObserver类的重点方法。 ObserveOnObserver @Override public void onNext(T t) { ... if (sourceMode != QueueDisposable.ASYNC) { // 1 queue.offer(t); } schedule(); } @Override public void onError(Throwable t) { ... schedule(); } @Override public void onComplete() { ... schedule(); } 去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()方法。接着看schedule()方法，其中onNext()还会把消息存放到队列中。 ObserveOnObserver#schedule() void schedule() { if (getAndIncrement() == 0) { worker.schedule(this); } } 这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是使用Handler进行线程切换的，此处不再赘述了。接着看ObserveOnObserver的run()方法。 ObserveOnObserver#run() @Override public void run() { // 1 if (outputFused) { drainFused(); } else { // 2 drainNormal(); } } 在注释1处会先判断outputFused这个标志位，它表示事件流是否被融化掉，默认是false，所以，最后会执行到drainNormal()方法。接着看看drainNormal()方法内部的处理。 ObserveOnObserver#drainNormal() void drainNormal() { int missed = 1; final SimpleQueue&lt;T&gt; q = queue; // 1 final Observer&lt;? super T&gt; a = downstream; ... // 2 v = q.poll(); ... // 3 a.onNext(v); ... } 在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()方法下面的链式代码都会执行到它所指定的线程中，噢，原来如此。 很多人使用RxJava也已经挺长时间了，但是一直没有去深入去了解过它的内部实现原理，如今细细品尝，的确是酣畅淋漓。 LeakCanary 原理概述 查看Leakcanary官方的github仓库，最重要的便是对Leakcanary是如何起作用的（即原理）这一问题进行了阐述，把它翻译成了易于理解的文字，主要分为如下7个步骤： RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。 然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。 如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。 HeapAnalyzerService被开启在一个独立的进程中，并且HeapAnalyzer使用了HAHA开源库解析了指定时刻的堆栈快照文件heap dump。 从heap dump中，HeapAnalyzer根据一个独特的引用key找到了KeyedWeakReference，并且定位了泄露的引用。 HeapAnalyzer为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。 这个结果被传回到app进程中的DisplayLeakService，然后一个泄露通知便展现出来了。 官方的原理简单来解释就是这样的：在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有没有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。 简单示例 下面这段是Leakcanary官方仓库的示例代码： 首先在你项目app下的build.gradle中配置: dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.2' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.2' // 可选，如果你使用支持库的fragments的话 debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.2' } 然后在你的Application中配置: public class WanAndroidApp extends Application { private RefWatcher refWatcher; public static RefWatcher getRefWatcher(Context context) { WanAndroidApp application = (WanAndroidApp) context.getApplicationContext(); return application.refWatcher; } @Override public void onCreate() { super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) { // 1 return; } // 2 refWatcher = LeakCanary.install(this); } } 在注释1处，会首先判断当前进程是否是Leakcanary专门用于分析heap内存的而创建的那个进程，即HeapAnalyzerService所在的进程，如果是的话，则不进行Application中的初始化功能。如果是当前应用所处的主进程的话，则会执行注释2处的LeakCanary.install(this)进行LeakCanary的安装。只需这样简单的几行代码，我们就可以在应用中检测是否产生了内存泄露了。当然，这样使用只会检测Activity和标准Fragment是否发生内存泄漏，如果要检测V4包的Fragment在执行完onDestroy()之后是否发生内存泄露的话，则需要在Fragment的onDestroy()方法中加上如下两行代码去监视当前的Fragment： RefWatcher refWatcher = WanAndroidApp.getRefWatcher(_mActivity); refWatcher.watch(this); 上面的RefWatcher其实就是一个引用观察者对象，是用于监测当前实例对象的引用状态的。从以上的分析可以了解到，核心代码就是LeakCanary.install(this)这行代码，接下来，就从这里出发将LeakCanary一步一步进行拆解。 源码分析 LeakCanary#install() public static @NonNull RefWatcher install(@NonNull Application application) { return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall(); } 在install()方法中的处理，可以分解为如下四步： refWatcher(application) 链式调用listenerServiceClass(DisplayLeakService.class) 链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) 链式调用buildAndInstall() 首先，我们来看下第一步，这里调用了LeakCanary类的refWatcher方法，如下所示： public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) { return new AndroidRefWatcherBuilder(context); } 然后新建了一个AndroidRefWatcherBuilder对象，再看看AndroidRefWatcherBuilder这个类。 AndroidRefWatcherBuilder /** A {@link RefWatcherBuilder} with appropriate Android defaults. */ public final class AndroidRefWatcherBuilder extends RefWatcherBuilder&lt;AndroidRefWatcherBuilder&gt; { ... AndroidRefWatcherBuilder(@NonNull Context context) { this.context = context.getApplicationContext(); } ... } 在AndroidRefWatcherBuilder的构造方法中仅仅是将外部传入的applicationContext对象保存起来了。AndroidRefWatcherBuilder是一个适配Android平台的引用观察者构造器对象，它继承了RefWatcherBuilder，RefWatcherBuilder是一个负责建立引用观察者RefWatcher实例的基类构造器。继续看看RefWatcherBuilder这个类。 RefWatcherBuilder public class RefWatcherBuilder&lt;T extends RefWatcherBuilder&lt;T&gt;&gt; { ... public RefWatcherBuilder() { heapDumpBuilder = new HeapDump.Builder(); } ... } 在RefWatcher的基类构造器RefWatcherBuilder的构造方法中新建了一个HeapDump的构造器对象。其中HeapDump就是一个保存heap dump信息的数据结构。 接着来分析下install()方法中的链式调用的listenerServiceClass(DisplayLeakService.class)这部分逻辑。 AndroidRefWatcherBuilder#listenerServiceClass() public @NonNull AndroidRefWatcherBuilder listenerServiceClass( @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) { return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass)); } 在这里，传入了一个DisplayLeakService的Class对象，它的作用是展示泄露分析的结果日志，然后会展示一个用于跳转到显示泄露界面DisplayLeakActivity的通知。在listenerServiceClass()这个方法中新建了一个ServiceHeapDumpListener对象，下面看看它内部的操作。 ServiceHeapDumpListener public final class ServiceHeapDumpListener implements HeapDump.Listener { ... public ServiceHeapDumpListener(@NonNull final Context context, @NonNull final Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) { this.listenerServiceClass = checkNotNull(listenerServiceClass, \"listenerServiceClass\"); this.context = checkNotNull(context, \"context\").getApplicationContext(); } ... } 可以看到这里仅仅是在ServiceHeapDumpListener中保存了DisplayLeakService的Class对象和application对象。它的作用就是接收一个heap dump去分析。 然后我们继续看install()方法链式调用.excludedRefs(AndroidExcludedRefs.createAppDefaults().build())的这部分代码。先看AndroidExcludedRefs.createAppDefaults()。 AndroidExcludedRefs#createAppDefaults() public enum AndroidExcludedRefs { ... public static @NonNull ExcludedRefs.Builder createAppDefaults() { return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class)); } public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet&lt;AndroidExcludedRefs&gt; refs) { ExcludedRefs.Builder excluded = ExcludedRefs.builder(); for (AndroidExcludedRefs ref : refs) { if (ref.applies) { ref.add(excluded); ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name()); } } return excluded; } ... } 先来说下AndroidExcludedRefs这个类，它是一个enum类，它声明了Android SDK和厂商定制的SDK中存在的内存泄露的case，根据AndroidExcludedRefs这个类的类名就可看出这些case都会被Leakcanary的监测过滤掉。目前这个版本是有46种这样的case被包含在内，后续可能会一直增加。然后EnumSet.allOf(AndroidExcludedRefs.class)这个方法将会返回一个包含AndroidExcludedRefs元素类型的EnumSet。Enum是一个抽象类，在这里具体的实现类是通用正规型的RegularEnumSet，如果Enum里面的元素个数大于64，则会使用存储大数据量的JumboEnumSet。最后，在createBuilder这个方法里面构建了一个排除引用的建造器excluded，将各式各样的case分门别类地保存起来再返回出去。 最后看到链式调用的最后一步buildAndInstall()。 AndroidRefWatcherBuilder#buildAndInstall() private boolean watchActivities = true; private boolean watchFragments = true; public @NonNull RefWatcher buildAndInstall() { // 1 if (LeakCanaryInternals.installedRefWatcher != null) { throw new UnsupportedOperationException(\"buildAndInstall() should only be called once.\"); } // 2 RefWatcher refWatcher = build(); if (refWatcher != DISABLED) { // 3 LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); if (watchActivities) { // 4 ActivityRefWatcher.install(context, refWatcher); } if (watchFragments) { // 5 FragmentRefWatcher.Helper.install(context, refWatcher); } } // 6 LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher; } 首先，在注释1处，会判断LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告 buildAndInstall()这个方法应该仅仅只调用一次，在此方法结束时，即在注释6处，该LeakCanaryInternals.installedRefWatcher才会被赋值。再来看注释2处，调用了AndroidRefWatcherBuilder其基类RefWatcherBuilder的build()方法，看看它是如何建造的。 RefWatcherBuilder#build() public final RefWatcher build() { if (isDisabled()) { return RefWatcher.DISABLED; } if (heapDumpBuilder.excludedRefs == null) { heapDumpBuilder.excludedRefs(defaultExcludedRefs()); } HeapDump.Listener heapDumpListener = this.heapDumpListener; if (heapDumpListener == null) { heapDumpListener = defaultHeapDumpListener(); } DebuggerControl debuggerControl = this.debuggerControl; if (debuggerControl == null) { debuggerControl = defaultDebuggerControl(); } HeapDumper heapDumper = this.heapDumper; if (heapDumper == null) { heapDumper = defaultHeapDumper(); } WatchExecutor watchExecutor = this.watchExecutor; if (watchExecutor == null) { watchExecutor = defaultWatchExecutor(); } GcTrigger gcTrigger = this.gcTrigger; if (gcTrigger == null) { gcTrigger = defaultGcTrigger(); } if (heapDumpBuilder.reachabilityInspectorClasses == null) { heapDumpBuilder.reachabilityInspectorClasses(defa ultReachabilityInspectorClasses()); } return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener, heapDumpBuilder); } 可以看到，RefWatcherBuilder包含了以下7个组成部分： excludedRefs : 记录可以被忽略的泄漏路径。 heapDumpListener : 转储堆信息到hprof文件，并在解析完 hprof 文件后进行回调，最后通知 DisplayLeakService 弹出泄漏提醒。 debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。为什么呢？因为在调试过程中可能会保留上一个引用从而导致错误信息上报。 heapDumper : 堆信息转储者，负责dump 内存泄漏处的 heap 信息到 hprof 文件。 watchExecutor : 线程控制器，在 onDestroy() 之后并且在主线程空闲时执行内存泄漏检测。 gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据heapDump信息生成相应的泄漏引用链。 reachabilityInspectorClasses : 用于要进行可达性检测的类列表。 最后，会使用建造者模式将这些组成部分构建成一个新的RefWatcher并将其返回。 继续看回到AndroidRefWatcherBuilder的注释3处的 LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true)这行代码。 LeakCanaryInternals#setEnabledAsync() public static void setEnabledAsync(Context context, final Class&lt;?&gt; componentClass, final boolean enabled) { final Context appContext = context.getApplicationContext(); AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() { @Override public void run() { setEnabledBlocking(appContext, componentClass, enabled); } }); } 在这里直接使用了AsyncTask内部自带的THREAD_POOL_EXECUTOR线程池进行阻塞式地显示DisplayLeakActivity。 然后再继续看AndroidRefWatcherBuilder的注释4处的代码。 ActivityRefWatcher#install() public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) { Application application = (Application) context.getApplicationContext(); // 1 ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); // 2 application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks); } 可以看到，在注释1处创建一个自己的activityRefWatcher实例，并在注释2处调用了application的registerActivityLifecycleCallbacks()方法，这样就能够监听activity对应的生命周期事件了。继续看看activityRefWatcher.lifecycleCallbacks里面的操作。 private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() { @Override public void onActivityDestroyed(Activity activity) { refWatcher.watch(activity); } }; public abstract class ActivityLifecycleCallbacksAdapter implements Application.ActivityLifecycleCallbacks { } 很明显，这里实现并重写了Application的ActivityLifecycleCallbacks的onActivityDestroyed()方法，这样便能在所有Activity执行完onDestroyed()方法之后调用 refWatcher.watch(activity)这行代码进行内存泄漏的检测了。 再看到注释5处的FragmentRefWatcher.Helper.install(context, refWatcher)这行代码， FragmentRefWatcher.Helper#install() public interface FragmentRefWatcher { void watchFragments(Activity activity); final class Helper { private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME = \"com.squareup.leakcanary.internal.SupportFragmentRefWatcher\"; public static void install(Context context, RefWatcher refWatcher) { List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;(); // 1 if (SDK_INT &gt;= O) { fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher)); } // 2 try { Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME); Constructor&lt;?&gt; constructor = fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class); FragmentRefWatcher supportFragmentRefWatcher = (FragmentRefWatcher) constructor.newInstance(refWatcher); fragmentRefWatchers.add(supportFragmentRefWatcher); } catch (Exception ignored) { } if (fragmentRefWatchers.size() == 0) { return; } Helper helper = new Helper(fragmentRefWatchers); // 3 Application application = (Application) context.getApplicationContext(); application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks); } ... } 这里面的逻辑很简单，首先在注释1处将Android标准的Fragment的RefWatcher类，即AndroidOfFragmentRefWatcher添加到新创建的fragmentRefWatchers中。在注释2处使用反射将leakcanary-support-fragment包下面的SupportFragmentRefWatcher添加进来，如果你在app的build.gradle下没有添加下面这行引用的话，则会拿不到此类，即LeakCanary只会检测Activity和标准Fragment这两种情况。 debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.2' 继续看到注释3处helper.activityLifecycleCallbacks里面的代码。 private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { for (FragmentRefWatcher watcher : fragmentRefWatchers) { watcher.watchFragments(activity); } } }; 可以看到，在Activity执行完onActivityCreated()方法之后，会调用指定watcher的watchFragments()方法，注意，这里的watcher可能有两种，但不管是哪一种，都会使用当前传入的activity获取到对应的FragmentManager/SupportFragmentManager对象，调用它的registerFragmentLifecycleCallbacks()方法，在对应的onDestroyView()和onDestoryed()方法执行完后，分别使用refWatcher.watch(view)和refWatcher.watch(fragment)进行内存泄漏的检测，代码如下所示。 @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) { View view = fragment.getView(); if (view != null) { refWatcher.watch(view); } } @Override public void onFragmentDestroyed(FragmentManagerfm, Fragment fragment) { refWatcher.watch(fragment); } 注意，下面到真正关键的地方了，接下来分析refWatcher.watch()这行代码。 RefWatcher#watch() public void watch(Object watchedReference, String referenceName) { if (this == DISABLED) { return; } checkNotNull(watchedReference, \"watchedReference\"); checkNotNull(referenceName, \"referenceName\"); final long watchStartNanoTime = System.nanoTime(); // 1 String key = UUID.randomUUID().toString(); // 2 retainedKeys.add(key); // 3 final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); // 4 ensureGoneAsync(watchStartNanoTime, reference); } 注意到在注释1处使用随机的UUID保证了每个检测对象对应 key 的唯一性。在注释2处将生成的key添加到类型为CopyOnWriteArraySet的Set集合中。在注释3处新建了一个自定义的弱引用KeyedWeakReference，看看它内部的实现。 KeyedWeakReference final class KeyedWeakReference extends WeakReference&lt;Object&gt; { public final String key; public final String name; KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) { // 1 super(checkNotNull(referent, \"referent\"), checkNotNull(referenceQueue, \"referenceQueue\")); this.key = checkNotNull(key, \"key\"); this.name = checkNotNull(name, \"name\"); } } 可以看到，在KeyedWeakReference内部，使用了key和name标识了一个被检测的WeakReference对象。在注释1处，将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用reference持有的对象被GC回收，JVM就会把这个弱引用加入到与之关联的引用队列referenceQueue中。即 KeyedWeakReference 持有的 Activity 对象如果被GC回收，该对象就会加入到引用队列 referenceQueue 中。 接着回到RefWatcher.watch()里注释4处的ensureGoneAsync()方法。 RefWatcher#ensureGoneAsync() private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) { // 1 watchExecutor.execute(new Retryable() { @Override public Retryable.Result run() { // 2 return ensureGone(reference watchStartNanoTime); } }); } 在ensureGoneAsync()方法中，在注释1处使用 watchExecutor 执行了注释2处的 ensureGone 方法，watchExecutor 是 AndroidWatchExecutor 的实例。 下面看看watchExecutor内部的逻辑。 AndroidWatchExecutor public final class AndroidWatchExecutor implements WatchExecutor { ... public AndroidWatchExecutor(long initialDelayMillis) { mainHandler = new Handler(Looper.getMainLooper()); HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME); handlerThread.start(); // 1 backgroundHandler = new Handler(handlerThread.getLooper()); this.initialDelayMillis = initialDelayMillis; maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis; } @Override public void execute(@NonNull Retryable retryable) { // 2 if (Looper.getMainLooper().getThread() == Thread.currentThread()) { waitForIdle(retryable, 0); } else { postWaitForIdle(retryable, 0); } } ... } 在注释1处AndroidWatchExecutor的构造方法中，注意到这里使用HandlerThread的looper新建了一个backgroundHandler，后面会用到。在注释2处，会判断当前线程是否是主线程，如果是，则直接调用waitForIdle()方法，如果不是，则调用postWaitForIdle()，来看看这个方法。 private void postWaitForIdle(final Retryable retryable, final int failedAttempts) { mainHandler.post(new Runnable() { @Override public void run() { waitForIdle(retryable, failedAttempts); } }); } 很清晰，这里使用了在构造方法中用主线程looper构造的mainHandler进行post，那么waitForIdle()最终也会在主线程执行。接着看看waitForIdle()的实现。 private void waitForIdle(final Retryable retryable, final int failedAttempts) { Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { postToBackgroundWithDelay(retryable, failedAttempts); return false; } }); } 这里MessageQueue.IdleHandler()回调方法的作用是当 looper 空闲的时候，会回调 queueIdle 方法，利用这个机制我们可以实现第三方库的延迟初始化，然后执行内部的postToBackgroundWithDelay()方法。接下来看看它的实现。 private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) { long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor); // 1 long delayMillis = initialDelayMillis * exponentialBackoffFactor; // 2 backgroundHandler.postDelayed(new Runnable() { @Override public void run() { // 3 Retryable.Result result = retryable.run(); // 4 if (result == RETRY) { postWaitForIdle(retryable, failedAttempts + 1); } } }, delayMillis); } 先看到注释4处，可以明白，postToBackgroundWithDelay()是一个递归方法，如果result 一直等于RETRY的话，则会一直执行postWaitForIdle()方法。在回到注释1处，这里initialDelayMillis 的默认值是 5s，因此delayMillis就是5s。在注释2处，使用了在构造方法中用HandlerThread的looper新建的backgroundHandler进行异步延时执行retryable的run()方法。这个run()方法里执行的就是RefWatcher的ensureGoneAsync()方法中注释2处的ensureGone()这行代码，继续看它内部的逻辑。 RefWatcher#ensureGone() Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) { long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); // 1 removeWeaklyReachableReferences(); // 2 if (debuggerControl.isDebuggerAttached()) { // The debugger can create false leaks. return RETRY; } // 3 if (gone(reference)) { return DONE; } // 4 gcTrigger.runGc(); removeWeaklyReachableReferences(); // 5 if (!gone(reference)) { long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) { // Could not dump the heap. return RETRY; } long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); heapdumpListener.analyze(heapDump); } return DONE; } 在注释1处，执行了removeWeaklyReachableReferences()这个方法，接下来分析下它的含义。 private void removeWeaklyReachableReferences() { KeyedWeakReference ref; while ((ref = (KeyedWeakReference) queue.poll()) != null) { retainedKeys.remove(ref.key); } } 这里使用了while循环遍历 ReferenceQueue ，并从 retainedKeys中移除对应的Reference。 再看到注释2处，当Android设备处于debug状态时，会直接返回RETRY进行延时重试检测的操作。在注释3处，看看gone(reference)这个方法的逻辑。 private boolean gone(KeyedWeakReference reference) { return !retainedKeys.contains(reference.key); } 这里会判断 retainedKeys 集合中是否还含有 reference，若没有，证明已经被回收了，若含有，可能已经发生内存泄露（或Gc还没有执行回收）。前面的分析中我们知道了 reference 被回收的时候，会被加进 referenceQueue 里面，然后我们会调用removeWeaklyReachableReferences()遍历 referenceQueue 移除掉 retainedKeys 里面的 refrence。 接着看到注释4处，执行了gcTrigger的runGc()方法进行垃圾回收，然后使用了removeWeaklyReachableReferences()方法移除已经被回收的引用。这里再深入地分析下runGc()的实现。 GcTrigger DEFAULT = new GcTrigger() { @Override public void runGc() { // Code taken from AOSP FinalizationTest: // https://android.googlesource.com/platform/libc ore/+/master/support/src/test/java/libcore/ // java/lang/ref/FinalizationTester.java // System.gc() does not garbage collect every time. Runtime.gc() is // more likely to perform a gc. Runtime.getRuntime().gc(); enqueueReferences(); System.runFinalization(); } private void enqueueReferences() { // Hack. We don't have a programmatic way to wait for the reference queue daemon to move // references to the appropriate queues. try { Thread.sleep(100); } catch (InterruptedException e) { throw new AssertionError(); } } }; 这里并没有使用System.gc()方法进行回收，因为system.gc()并不会每次都执行。而是从AOSP中拷贝一段GC回收的代码，从而相比System.gc()更能够保证垃圾回收的工作。 最后分析下注释5处的代码处理。首先会判断activity是否被回收，如果还没有被回收，则证明发生内存泄露，进行if判断里面的操作。在里面先调用堆信息转储者heapDumper的dumpHeap()生成相应的 hprof 文件。这里的heapDumper是一个HeapDumper接口，具体的实现是AndroidHeapDumper。我们分析下AndroidHeapDumper的dumpHeap()方法是如何生成hprof文件的。 public File dumpHeap() { File heapDumpFile = leakDirectoryProvider.newHeapDumpFile(); if (heapDumpFile == RETRY_LATER) { return RETRY_LATER; } ... try { Debug.dumpHprofData(heapDumpFile.getAbsolutePath()); ... return heapDumpFile; } catch (Exception e) { ... // Abort heap dump return RETRY_LATER; } } 这里的核心操作就是调用了Android SDK的API Debug.dumpHprofData() 来生成 hprof 文件。 如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作。如果不等于的话，则表示生成成功，最后会执行heapdumpListener的analyze()对新创建的HeapDump对象进行泄漏分析。由前面对AndroidRefWatcherBuilder的listenerServiceClass()的分析可知，heapdumpListener的实现 就是ServiceHeapDumpListener，接着看到ServiceHeapDumpListener的analyze方法。 ServiceHeapDumpListener#analyze() @Override public void analyze(@NonNull HeapDump heapDump) { checkNotNull(heapDump, \"heapDump\"); HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass); } 可以看到，这里执行了HeapAnalyzerService的runAnalysis()方法，为了避免降低app进程的性能或占用内存，这里将HeapAnalyzerService设置在了一个独立的进程中。接着继续分析runAnalysis()方法里面的处理。 public final class HeapAnalyzerService extends ForegroundService implements AnalyzerProgressListener { ... public static void runAnalysis(Context context, HeapDump heapDump, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) { ... ContextCompat.startForegroundService(context, intent); } ... @Override protected void onHandleIntentInForeground(@Nullable Intent intent) { ... // 1 HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses); // 2 AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey, heapDump.computeRetainedHeapSize); // 3 AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result); } ... } 这里的HeapAnalyzerService实质是一个类型为IntentService的ForegroundService，执行startForegroundService()之后，会回调onHandleIntentInForeground()方法。注释1处，首先会新建一个HeapAnalyzer对象，顾名思义，它就是根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的。在注释2处，然后会调用它的checkForLeak()方法去使用haha库解析 hprof文件，如下所示： public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile, @NonNull String referenceKey, boolean computeRetainedSize) { ... try { listener.onProgressUpdate(READING_HEAP_DUMP_FILE); // 1 HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile); // 2 HprofParser parser = new HprofParser(buffer); listener.onProgressUpdate(PARSING_HEAP_DUMP); Snapshot snapshot = parser.parse(); listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS); // 3 deduplicateGcRoots(snapshot); listener.onProgressUpdate(FINDING_LEAKING_REF); // 4 Instance leakingRef = findLeakingReference(referenceKey, snapshot); // 5 if (leakingRef == null) { return noLeak(since(analysisStartNanoTime)); } // 6 return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize); } catch (Throwable e) { return failure(e, since(analysisStartNanoTime)); } } 在注释1处，会新建一个内存映射缓存文件buffer。在注释2处，会使用buffer新建一个HprofParser解析器去解析出对应的引用内存快照文件snapshot。在注释3处，为了减少在Android 6.0版本中重复GCRoots带来的内存压力的影响，使用deduplicateGcRoots()删除了gcRoots中重复的根对象RootObj。在注释4处，调用了findLeakingReference()方法将传入的referenceKey和snapshot对象里面所有类实例的字段值对应的keyCandidate进行比较，如果没有相等的，则表示没有发生内存泄漏，直接调用注释5处的代码返回一个没有泄漏的分析结果AnalysisResult对象。如果找到了相等的，则表示发生了内存泄漏，执行注释6处的代码findLeakTrace()方法返回一个有泄漏分析结果的AnalysisResult对象。 最后，来分析下HeapAnalyzerService中注释3处的AbstractAnalysisResultService.sendResultToListener()方法，很明显，这里AbstractAnalysisResultService的实现类就是我们刚开始分析的用于展示泄漏路径信息的DisplayLeakService对象。在里面直接创建一个由PendingIntent构建的泄漏通知用于供用户点击去展示详细的泄漏界面DisplayLeakActivity。核心代码如下所示： public class DisplayLeakService extends AbstractAnalysisResultService { @Override protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) { ... boolean resultSaved = false; boolean shouldSaveResult = result.leakFound || result.failure != null; if (shouldSaveResult) { heapDump = renameHeapdump(heapDump); // 1 resultSaved = saveResult(heapDump, result); } if (!shouldSaveResult) { ... showNotification(null, contentTitle, contentText); } else if (resultSaved) { ... // 2 PendingIntent pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey); ... showNotification(pendingIntent, contentTitle, contentText); } else { onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text)); } ... } @Override protected final void onAnalysisResultFailure(String failureMessage) { super.onAnalysisResultFailure(failureMessage); String failureTitle = getString(R.string.leak_canary_result_failure_title); showNotification(null, failureTitle, failureMessage); } 可以看到，只要当分析的堆信息文件保存成功之后，即在注释1处返回的resultSaved为true时，才会执行注释2处的逻辑，即创建一个供用户点击跳转到DisplayLeakActivity的延时通知。 LeakCanary运作流程 性能优化一直是Android中进阶和深入的方向之一，而内存泄漏一直是性能优化中比较重要的一部分，Android Studio自身提供了MAT等工具去分析内存泄漏，但是分析起来比较耗时耗力，因而才诞生了LeakCanary，它的使用非常简单，但是经过对它的深入分析之后，才发现，简单的API后面往往藏着许多复杂的逻辑处理，尝试去领悟它们，你可能会发现不一样的世界。 ButterKnife 简单示例 首先看一下ButterKnife的基本使用，如下所示： public class CollectFragment extends BaseRootFragment&lt;CollectPresenter&gt; implements CollectContract.View { @BindView(R.id.normal_view) SmartRefreshLayout mRefreshLayout; @BindView(R.id.collect_recycler_view) RecyclerView mRecyclerView; @BindView(R.id.collect_floating_action_btn) FloatingActionButton mFloatingActionButton; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(getLayoutId(), container, false); unBinder = ButterKnife.bind(this, view); initView(); return view; } @OnClick({R.id.collect_floating_action_btn}) void onClick(View view) { switch (view.getId()) { case R.id.collect_floating_action_btn: mRecyclerView.smoothScrollToPosition(0); break; default: break; } } @Override public void onDestroyView() { super.onDestroyView(); if (unBinder != null &amp;&amp; unBinder != Unbinder.EMPTY) { unBinder.unbind(); unBinder = null; } } 可以看到，我们使用了@BindView()替代了findViewById()方法，然后使用了@OnClick替代了setOnClickListener()方法。ButterKnife的初期版本是通过使用注解+反射这样的运行时解析的方式实现上述功能的，后面，为了改善性能，便使用了注解+APT编译时解析技术并从中生成配套模板代码的方式来实现。 在开始分析之前，可能有同学对APT不是很了解，这里普及一下，APT是Annotation Processing Tool的缩写，即注解处理工具。它的使用步骤通常为如下三个步骤： **首先，声明注解的生命周期为CLASS，即@Retention(CLASS)**。 然后，通过继承AbstractProcessor自定义一个注解处理器。 最后，在编译的时候，编译器会扫描所有带有你要处理的注解的类，最后再调用AbstractProcessor的process方法，对注解进行处理。 下面，正式来解剖一下ButterKnife的心脏。 源码分析 模板代码解析 首先，在编写好上述的示例代码之后，调用 gradle build 命令，在app/build/generated/source/apt下将可以找到APT为我们生产的配套模板代码CollectFragment_ViewBinding，如下所示： public class CollectFragment_ViewBinding implements Unbinder { private CollectFragment target; private View view2131230812; @UiThread public CollectFragment_ViewBinding(final CollectFragment target, View source) { this.target = target; View view; // 1 target.mRefreshLayout = Utils.findRequiredViewAsType(source, R.id.normal_view, \"field 'mRefreshLayout'\", SmartRefreshLayout.class); target.mRecyclerView = Utils.findRequiredViewAsType(source, R.id.collect_recycler_view, \"field 'mRecyclerView'\", RecyclerView.class); view = Utils.findRequiredView(source, R.id.collect_floating_action_btn, \"field 'mFloatingActionButton' and method 'onClick'\"); target.mFloatingActionButton = Utils.castView(view, R.id.collect_floating_action_btn, \"field 'mFloatingActionButton'\", FloatingActionButton.class); view2131230812 = view; // 2 view.setOnClickListener(new DebouncingOnClickListener() { @Override public void doClick(View p0) { target.onClick(p0); } }); } @Override @CallSuper public void unbind() { CollectFragment target = this.target; if (target == null) throw newIllegalStateException(\"Bindings already cleared.\"); this.target = null; target.mRefreshLayout = null; target.mRecyclerView = null; target.mFloatingActionButton = null; view2131230812.setOnClickListener(null); view2131230812 = null; } } 生成的配套模板CollectFragment_ViewBinding中，在注释1处，使用了ButterKnife内部的工具类Utils的findRequiredViewAsType()方法来寻找控件。在注释2处，使用了view的setOnClickListener()方法来添加了一个去抖动的DebouncingOnClickListener，这样便可以防止重复点击，在重写的doClick()方法内部，直接调用了CollectFragment的onClick方法。最后，再深入看下Utils的findRequiredViewAsType()方法内部的实现。 public static &lt;T&gt; T findRequiredViewAsType(View source, @IdRes int id, String who, Class&lt;T&gt; cls) { // 1 View view = findRequiredView(source, id, who); // 2 return castView(view, id, who, cls); } public static View findRequiredView(View source, @IdRes int id, String who) { View view = source.findViewById(id); if (view != null) { return view; } ... } public static &lt;T&gt; T castView(View view, @IdRes int id, String who, Class&lt;T&gt; cls) { try { return cls.cast(view); } catch (ClassCastException e) { ... } } 在注释1处，最终也是通过View的findViewById()方法找到相应的控件，在注释2处，通过相应Class对象的cast方法强转成对应的控件类型。 ButterKnife 是怎样实现代码注入的 接下来，为了使用这套模板代码，我们必须调用ButterKnife的bind()方法实现代码注入，即自动帮我们执行重复繁琐的findViewById和setOnClicklistener操作。下面我们来分析下bind()方法是如何实现注入的。 @NonNull @UiThread public static Unbinder bind(@NonNull Object target, @NonNull View source) { return createBinding(target, source); } 在bind()方法中调用了createBinding()， @NonNull @UiThread public static Unbinder bind(@NonNull Object target, @NonNull View source) { Class&lt;?&gt; targetClass = target.getClass(); // 1 Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); if (constructor == null) { return Unbinder.EMPTY; } try { // 2 return constructor.newInstance(target, source); // 3 } catch (IllegalAccessException e) { ... } 首先，在注释1处，通过 findBindingConstructorForClass() 方法从 Class 中查找 constructor，这里constructor即上文生成的CollectFragment_ViewBinding类。然后，在注释2处，利用反射来新建 constructor 对象。最后，如果新建 constructor 对象失败，则会在注释3后面捕获一系列对应的异常进行自定义异常抛出处理。 下面，来详细分析下 findBindingConstructorForClass() 方法的实现逻辑。 @VisibleForTesting static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;(); @Nullable @CheckResult @UiThread private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) { // 1 Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); if (bindingCtor != null || BINDINGS.containsKey(cls)) { return bindingCtor; } // 2 String clsName = cls.getName(); if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\") || clsName.startsWith(\"androidx.\")) { return null; } try { // 3 Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\"); bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); } catch (ClassNotFoundException e) { // 4 bindingCtor = findBindingConstructorForClass(cls.getSuperclass()); } catch (NoSuchMethodException e) { throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e); } // 5 BINDINGS.put(cls, bindingCtor); return bindingCtor; } 这里，我把多余的log代码删除并把代码格式优化了一下，可以看到，findBindingConstructorForClass() 这个方法中的逻辑瞬间清晰不少，这里建议以后大家自己在分析源码的时候可以进行这样的优化重整，会带来不少好处。 重新看到 findBindingConstructorForClass() 方法，在注释1处，我们首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，这里的BINDINGS是一个LinkedHashMap对象，它保存了上述两者的映射关系。在注释2处，如果是 android，androidx，java 原生的文件，不进行处理。在注释3处，先通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象。如果在步骤3中加载不出对应的模板类对象，则会在注释4处使用类似递归的方法重新执行findBindingConstructorForClass()方法。最后，如果找到了bindingCtor模板构造对象，则将它保存在BINDINGS这个LinkedHashMap对象中。 这里总结一下findBindingConstructorForClass()方法的处理： 首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，获取不到，则继续执行下面的操作。 如果不是android，androidx，java 原生的文件，再进行后面的处理。 通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象，如果获取不到，会抛出异常，在异常的处理中，我们会从当前 class 文件的父类中再去查找。如果找到了，最后会将bindingCtor对象缓存进在BINDINGS对象中。 ButterKnife是如何在编译时生成代码的？ 在编译的时候，ButterKnife会通过自定义的注解处理器ButterKnifeProcessor的process方法，对编译器扫描到的要处理的类中的注解进行处理，然后，通过javapoet这个库来动态生成绑定事件或者控件的模板代码，最后在运行的时候，直接调用bind方法完成绑定即可。 首先，先来分析下ButterKnifeProcessor的重写的入口方法init()。 @Override public synchronized void init(ProcessingEnvironment env) { super.init(env); String sdk = env.getOptions().get(OPTION_SDK_INT); if (sdk != null) { try { this.sdk = Integer.parseInt(sdk); } catch (NumberFormatException e) { ... } } typeUtils = env.getTypeUtils(); filer = env.getFiler(); ... } 可以看到，ProcessingEnviroment对象提供了两大工具类 typeUtils和filer。typeUtils的作用是用来处理TypeMirror，而Filer则是用来创建生成辅助文件。 接着，再来看看被重写的getSupportedAnnotationTypes()方法，这个方法的作用主要是用于指定ButterknifeProcessor注册了哪些注解的。 @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) { types.add(annotation.getCanonicalName()); } return types; } 这里面首先创建了一个LinkedHashSet对象，然后将getSupportedAnnotations()方法返回的支持注解集合进行遍历一一并添加到types中返回。 接着看下getSupportedAnnotations()方法， private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() { Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindAnim.class); annotations.add(BindArray.class); annotations.add(BindBitmap.class); annotations.add(BindBool.class); annotations.add(BindColor.class); annotations.add(BindDimen.class); annotations.add(BindDrawable.class); annotations.add(BindFloat.class); annotations.add(BindFont.class); annotations.add(BindInt.class); annotations.add(BindString.class); annotations.add(BindView.class); annotations.add(BindViews.class); annotations.addAll(LISTENERS); return annotations; } 可以看到，这里注册了一系列的Bindxxx注解类和监听列表LISTENERS，接着看一下LISTENERS中包含的监听方法： private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList( OnCheckedChanged.class, OnClick.class, OnEditorAction.class, OnFocusChange.class, OnItemClick.class, OnItemLongClick.class, OnItemSelected.class, OnLongClick.class, OnPageChange.class, OnTextChanged.class, OnTouch.class ); 最后，来分析下整个ButterKnifeProcessor中最关键的方法process()。 @Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) { // 1 Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) { TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); // 2 JavaFile javaFile = binding.brewJava(sdk, debuggable); try { javaFile.writeTo(filer); } catch (IOException e) { ... } } return false; } 首先，在注释1处通过findAndParseTargets()方法，知名见义，它应该就是找到并解析注解目标的关键方法了，继续看看它内部的处理： private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) { Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); // 1、一系列处理每一个@Bindxxx元素的for循环代码块 ... // Process each @BindView element. for (Element element : env.getElementsAnnotatedWith(BindView.class)) { try { // 2 parseBindView(element, builderMap, erasedTargetNames); } catch (Exception e) { logParsingError(element, BindView.class, e); } } // Process each @BindViews element. ... // Process each annotation that corresponds to a listener. for (Class&lt;? extends Annotation&gt; listener : LISTENERS) { findAndParseListener(env, listener, builderMap, erasedTargetNames); } // 2 Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) { Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) { bindingMap.put(type, builder.build()); } else { BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) { builder.setParent(parentBinding); bindingMap.put(type, builder.build()); } else { entries.addLast(entry); } } } return bindingMap; } findAndParseTargets()方法的代码非常多，这里尽可能做了精简。首先，在注释1处，扫描并处理所有具有@Bindxxx注解和符合LISTENERS监听方法集合的代码，然后在每一个@Bindxxx对应的for循环代码中的parseBindxxx()或findAndParseListener()方法中将解析出的信息放入builderMap这个LinkedHashMap对象中，其中builderMap是一个key为TypeElement，value为BindingSet.Builder的映射集合，这个 BindSet 是指的一个类型请求的所有绑定的集合。在注释3处，首先使用上面的builderMap对象去构建了一个entries对象，它是一个双向队列，能实现两端存取的操作。接着，又新建了一个key为TypeElement，value为BindingSet的LinkedHashMap对象，最后使用了一个while循环从entries的第一个元素开始，这里会判断当前元素类型是否有父类，如果没有，直接构建builder放入bindingMap中，如果有，则将parentBinding添加到BindingSet.Builder这个建造者对象中，然后再创建BindingSet再添加到bindingMap中。 接着，分析下注释2处parseBindView是如何对每一个@BindView注解的元素进行处理。 private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) { TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // 1、首先验证生成的常见代码限制 ... // 2、验证目标类型是否继承自View。 ... // 3 int id = element.getAnnotation(BindView.class).value(); BindingSet.Builder builder = builderMap.get(enclosingElement); Id resourceId = elementToId(element, BindView.class, id); if (builder != null) { String existingBindingName = builder.findExistingBindingName(resourceId); if (existingBindingName != null) { ... return; } } else { // 4 builder = getOrCreateBindingBuilder(builderMap, enclosingElement); } String name = simpleName.toString(); TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); // 5 builder.addField(resourceId, new FieldViewBinding(name, type, required)); // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement); } 首先，在注释1、2处均是一些验证处理操作，如果不符合则会return。然后，看到注释3处，这里获取了BindView要绑定的View的id，然后先从builderMap中获取BindingSet.Builder对象，如果存在，直接return。如果不存在，则会在注释4处的 getOrCreateBindingBuilder()方法生成一个。看一下getOrCreateBindingBuilder()方法: private BindingSet.Builder getOrCreateBindingBuilder( Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) { BindingSet.Builder builder = builderMap.get(enclosingElement); if (builder == null) { builder = BindingSet.newBuilder(enclosingElement); builderMap.put(enclosingElement, builder); } return builder; } 可以看到，这里会再次从buildMap中获取BindingSet.Builder对象，如果没有则直接调用BindingSet的newBuilder()方法新建一个BindingSet.Builder对象并保存在builderMap中，然后，再将新建的builder对象返回。 回到parseBindView()方法的注释5处，这里根据view的信息生成一个FieldViewBinding，最后添加到上边生成的builder对象中。 最后，再回到我们的process()方法中，现在所有的绑定的集合数据都放在了bindingMap对象中，这里使用for循环取出每一个BindingSet对象，调用它的brewJava()方法，看看它内部的处理： JavaFile brewJava(int sdk, boolean debuggable) { TypeSpec bindingConfiguration = createType(sdk, debuggable); return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration) .addFileComment(\"Generated code from Butter Knife. Do not modify!\") .build(); } private TypeSpec createType(int sdk, boolean debuggable) { TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName()) .addModifiers(PUBLIC); if (isFinal) { result.addModifiers(FINAL); } if (parentBinding != null) { result.superclass(parentBinding.bindingClassName); } else { result.addSuperinterface(UNBINDER); } if (hasTargetField()) { result.addField(targetTypeName, \"target\", PRIVATE); } if (isView) { result.addMethod(createBindingConstructorForView()); } else if (isActivity) { result.addMethod(createBindingConstructorForActivity()); } else if (isDialog) { result.addMethod(createBindingConstructorForDialog()); } if (!constructorNeedsView()) { // Add a delegating constructor with a target type + view signature for reflective use. result.addMethod(createBindingViewDelegateConstructor()); } result.addMethod(createBindingConstructor(sdk, debuggable)); if (hasViewBindings() || parentBinding == null) { result.addMethod(createBindingUnbindMethod(result)); } return result.build(); } 在createType()方法里面使用了java中的javapoet技术生成了一个bindingConfiguration对象，很显然，它里面保存了所有的绑定配置信息。然后，通过javapoet的builder构造器将上面得到的bindingConfiguration对象构建生成一个JavaFile对象，最终，通过javaFile.writeTo(filer)生成了java源文件。 从上面的源码分析来看，ButterKnife的执行流程总体可以分为如下两步： 在编译的时候扫描注解，并通过自定义的ButterKnifeProcessor做相应的处理解析得到bindingMap对象，最后，调用 javapoet 库生成java模板代码。 当我们调用 ButterKnife的bind()方法的时候，它会根据类的全限定类型，找到相应的模板代码，并在其中完成 findViewById 和 setOnClick ，setOnLongClick 等操作。 Dagger 2 预备知识 @Inject 告诉dagger这个字段或类需要依赖注入，然后在需要依赖的地方使用这个注解，dagger会自动生成这个构造器的实例。 获取所需依赖： 全局变量注入 方法注入 提供所需实例： 构造器注入（如果有多个构造函数，只能注解一个，否则编译报错） @Module 类注解，表示此类的方法是提供依赖的，它告诉dagger在哪可以找到依赖。用于不能用@Inject提供依赖的地方，如第三方库提供的类，基本数据类型等不能修改源码的情况。 注意：Dagger2会优先在@Module注解的类上查找依赖，没有的情况才会去查询类的@Inject构造方法 @Singleton 声明这是一个单例，在确保只有一个Component并且不再重新build()之后，对象只会被初始化一次，之后的每次都会被注入相同的对象，它就是一个内置的作用域。 对于@Singleton，大家可能会产生一些误解，这里详细阐述下： Singleton容易给人造成一种误解就是用Singleton注解后在整个Java代码中都是单例，但实际上他和Scope一样，只是在同一个Component是单例。也就是说，如果重新调用了component的build（）方法，即使使用了Singleton注解了，但仍然获取的是不同的对象。 它表明了**@Singleton注解只是声明了这是一个单例，为的只是提高代码可读性，其实真正控制对象生命周期的还是Component。同理，自定义的@ActivityScope 、@ApplicationScope也仅仅是一个声明的作用，真正控制对象生命周期的还是Component**。 @Providers 只在@Module中使用，用于提供构造好的实例。一般与@Singleton搭配，用单例方法的形式对外提供依赖,是一种替代@Inject注解构造方法的方式。 注意： 使用了@Providers的方法应使用provide作为前缀，使用了@Module的类应使用Module作为后缀。 如果@Providers方法或@Inject构造方法有参数，要保证它能够被dagger获取到，比如通过其它@Providers方法或者@Inject注解构造器的形式得到。 @Component @Component作为Dagger2的容器总管，它拥有着@Inject与@Module的所有依赖。同时，它也是一枚注射器，用于获取所需依赖和提供所需依赖的桥梁。这里的桥梁即指@Inject和@Module（或@Inject构造方法）之间的桥梁。定义时需要列出响应的Module组成，此外，还可以使用dependencies继承父Component。 Component与Module的区别： Component既是注射器也是一个容器总管，而module则是作为容器总管Component的子容器，实质是一个用于提供依赖的模块。 @Scope 注解作用域，通过自定义注解限定对象作用范围，增强可读性。 @Scope有两种常用的使用场景： 模拟Singleton代表全局单例，与Component生命周期关联。 模拟局部单例，如登录到退出登录期间。 @Qualifier 限定符，利用它定义注解类以用于区分类的不同实例。例如：2个方法返回不同的Person对象，比如说小明和小华，为了区分，使用@Qualifier定义的注解类。 dependencies 使用它表示ChildComponent依赖于FatherComponent，如下所示： @Component(modules = ChildModule.class, dependencies = FatherComponent.class) public interface ChildComponent { ... } @SubComponent 表示是一个子@Component，它能将应用的不同部分封装起来，用来替代@Dependencies。 简单示例 首先，创建一个BaseActivityComponent的Subcomponent： @Subcomponent(modules = {AndroidInjectionModule.class}) public interface BaseActivityComponent extends AndroidInjector&lt;BaseActivity&gt; { @Subcomponent.Builder abstract class BaseBuilder extends AndroidInjector.Builder&lt;BaseActivity&gt;{ } } 这里必须要注解成@Subcomponent.Builder表示是顶级@Subcomponent的内部类。AndroidInjector.Builder的泛型指定了BaseActivity，即表示每一个继承于BaseActivity的Activity都继承于同一个子组件（BaseActivityComponent）。 然后，创建一个将会导入Subcomponent的公有Module。 // 1 @Module(subcomponents = {BaseActivityComponent.class}) public abstract class AbstractAllActivityModule { @ContributesAndroidInjector(modules = MainActivityModule.class) abstract MainActivity contributesMainActivityInjector(); @ContributesAndroidInjector(modules = SplashActivityModule.class) abstract SplashActivity contributesSplashActivityInjector(); // 一系列的对应Activity的contributesxxxActivityInjector ... } 在注释1处用subcomponents来表示开放全部依赖给AbstractAllActivityModule，使用Subcomponent的重要原因是它将应用的不同部分封装起来了。**@AppComponent负责维护共享的数据和对象，而不同处则由各自的@Subcomponent维护**。 接着，配置项目的Application。 public class WanAndroidApp extends Application implements HasActivityInjector { // 3 @Inject DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector; private static volatile AppComponent appComponent; @Override public void onCreate() { super.onCreate(); ... // 1 appComponent = DaggerAppComponent.builder() .build(); // 2 appComponent.inject(this); ... } ... // 4 @Override public AndroidInjector&lt;Activity&gt; activityInjector() { return mAndroidInjector; } } 首先，在注释1处，使用AppModule模块和httpModule模块构建出AppComponent的实现类DaggerAppComponent。这里看一下AppComponent的配置代码： @Singleton @Component(modules = {AndroidInjectionModule.class, AndroidSupportInjectionModule.class, AbstractAllActivityModule.class, AbstractAllFragmentModule.class, AbstractAllDialogFragmentModule.class} ) public interface AppComponent { /** * 注入WanAndroidApp实例 * * @param wanAndroidApp WanAndroidApp */ void inject(WanAndroidApp wanAndroidApp); ... } 可以看到，AppComponent依赖了AndroidInjectionModule模块，它包含了一些基础配置的绑定设置，如activityInjectorFactories、fragmentInjectorFactories等等，而AndroidSupportInjectionModule模块显然就是多了一个supportFragmentInjectorFactories的绑定设置，activityInjectorFactories的内容如所示： @Beta @Module public abstract class AndroidInjectionModule { @Multibinds abstract Map&lt;Class&lt;? extends Activity&gt;, AndroidInjector.Factory&lt;? extends Activity&gt;&gt; activityInjectorFactories(); @Multibinds abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt; fragmentInjectorFactories(); ... } 接着，下面依赖的AbstractAllActivityModule、 AbstractAllFragmentModule、AbstractAllDialogFragmentModule则是为项目的所有Activity、Fragment、DialogFragment提供的统一基类抽象Module，这里看下AbstractAllActivityModule的配置： @Module(subcomponents = {BaseActivityComponent.class}) public abstract class AbstractAllActivityModule { @ContributesAndroidInjector(modules = MainActivityModule.class) abstract MainActivity contributesMainActivityInjector(); @ContributesAndroidInjector(modules = SplashActivityModule.class) abstract SplashActivity contributesSplashActivityInjector(); ... } 可以看到，项目下的所有xxxActiviity都有对应的contributesxxxActivityInjector()方法提供实例注入。并且，注意到AbstractAllActivityModule这个模块依赖的 subcomponents为BaseActivityComponent，前面说过了，每一个继承于BaseActivity的Activity都继承于BaseActivityComponent这一个subcomponents。同理，AbstractAllFragmentModule与AbstractAllDialogFragmentModule也是类似的实现模式，如下所示： // 1 @Module(c = BaseFragmentComponent.class) public abstract class AbstractAllFragmentModule { @ContributesAndroidInjector(modules = CollectFragmentModule.class) abstract CollectFragment contributesCollectFragmentInject(); @ContributesAndroidInjector(modules = KnowledgeFragmentModule.class) abstract KnowledgeHierarchyFragment contributesKnowledgeHierarchyFragmentInject(); ... } // 2 @Module(subcomponents = BaseDialogFragmentComponent.class) public abstract class AbstractAllDialogFragmentModule { @ContributesAndroidInjector(modules = SearchDialogFragmentModule.class) abstract SearchDialogFragment contributesSearchDialogFragmentInject(); @ContributesAndroidInjector(modules = UsageDialogFragmentModule.class) abstract UsageDialogFragment contributesUsageDialogFragmentInject(); } 注意到注释1和注释2处的代码，AbstractAllFragmentModule和AbstractAllDialogFragmentModule的subcomponents为BaseFragmentComponent、BaseDialogFragmentComponent，很显然，同AbstractAllActivityModule的子组件BaseActivityComponent一样，它们都是作为一个通用的子组件。 然后，回到我们配置项目下的Application下面的注释2处的代码，在这里使用了第一步Dagger为我们构建的DaggerAppComponent对象将当期的Application实例注入了进去，交给了Dagger这个依赖大管家去管理。最终，Dagger2内部创建的mAndroidInjector对象会在注释3处的地方进行实例赋值。在注释4处，实现HasActivityInjector接口，重写activityInjector()方法，将我们上面得到的mAndroidInjector对象返回。这里的mAndroidInjector是一个类型为DispatchingAndroidInjector的对象，可以这样理解它：它能够执行Android框架下的核心成员如Activity、Fragment的成员注入，在我们项目下的Application中将DispatchingAndroidInjector的泛型指定为Activity就说明它承担起了所有Activity成员依赖的注入。那么，如何指定某一个Activity能被纳入DispatchingAndroidInjector这个所有Activity的依赖总管的口袋中呢？接着看使用步骤4。 最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。 很简单，只需在目标Activity的onCreate()方法前的super.onCreate(savedInstanceState)前配置一行代码 AndroidInjection.inject(this)，如下所示： public abstract class BaseActivity&lt;T extends AbstractPresenter&gt; extends AbstractSimpleActivity implements AbstractView { ... @Inject protected T mPresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { AndroidInjection.inject(this); super.onCreate(savedInstanceState); } ... } 这里使用了@Inject表明了需要注入mPresenter实例，然后，我们需要在具体的Presenter类的构造方法上使用@Inject提供基于当前构造方法的mPresenter实例，如下所示： public class MainPresenter extends BasePresenter&lt;MainContract.View&gt; implements MainContract.Presenter { ... @Inject MainPresenter(DataManager dataManager) { super(dataManager); this.mDataManager = dataManager; } ... } 从上面的使用流程中，有三个关键的核心实现是我们需要了解的，如下所示： 1、appComponent = DaggerAppComponent.builder().build()这句代码如何构建出DaggerAPPComponent的？ 2、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？ 3、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？ 下面我们逐个地来探索其中的奥妙~ 源码分析 DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？ 首先，看到DaggerAppComponent的builder()方法： public static Builder builder() { return new Builder(); } 里面直接返回了一个新建的Builder静态内部类对象，看看它的构造方法中做了什么： public static final class Builder { private Builder() {} ... } 看来，Builder的默认构造方法什么也没有做，那么，真正的实现肯定在Builder对象的build()方法中，接着看到build()方法。 public static final class Builder { ... public AppComponent build() { return new DaggerAppComponent(this); } ... } 在Builder的build()方法中直接返回了新建的DaggerAppComponent对象。下面，看看DaggerAppComponent的构造方法: private DaggerAppComponent(Builder builder) { initialize(builder); } 在DaggerAppComponent的构造方法中调用了initialize方法，顾名思义，它就是真正初始化项目全局依赖配置的地方了，下面，来看看它内部的实现： private void initialize(final Builder builder) { // 1 this.mainActivitySubcomponentBuilderProvider = new Provider&lt; AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent .Builder&gt;() { @Override public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent .Builder get() { // 2 return new MainActivitySubcomponentBuilder(); } }; // 一系列xxxActivitySubcomponentBuilderProvider的创建赋值代码块 ... } 在注释1处，新建了一个mainActivit的子组件构造器实例提供者Provider。在注释2处，使用匿名内部类的方式重写了该Provider的get()方法，返回一个新创建好的MainActivitySubcomponentBuilder对象。很显然，它就是负责创建管理MAinActivity中所需依赖的Subcomponent建造者。接下来重点来分析下MainActivitySubcomponentBuilder这个类的作用。 // 1 private final class MainActivitySubcomponentBuilder extends AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent .Builder { private MainActivity seedInstance; @Override public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent build() { if (seedInstance == null) { throw new IllegalStateException(MainActivity.class.getCanonicalName() + \" must be set\"); } // 2 return new MainActivitySubcomponentImpl(this); } @Override public void seedInstance(MainActivity arg0) { // 3 this.seedInstance = Preconditions.checkNotNull(arg0); } } 首先，在注释1处，MainActivitySubcomponentBuilder继承了AbstractAllActivityModule_ContributesMainActivityInjector内部的子组件MainActivitySubcomponent的内部的子组件建造者类Builder，如下所示： @Subcomponent(modules = MainActivityModule.class) public interface MainActivitySubcomponent extends AndroidInjector&lt;MainActivity&gt; { @Subcomponent.Builder abstract class Builder extends AndroidInjector.Builder&lt;MainActivity&gt; {} } 可以看到，这个子组件建造者Builder又继承了AndroidInjector的抽象内部类Builder，那么，这个AndroidInjector到底是什么呢？ 顾名思义，AndroidInjector是一个Android注射器，它为每一个具体的子类型，即核心Android类型Activity和Fragment执行成员注入。 接下来分析下AndroidInjector的内部实现，源码如下所示： public interface AndroidInjector&lt;T&gt; { void inject(T instance); // 1 interface Factory&lt;T&gt; { AndroidInjector&lt;T&gt; create(T instance); } // 2 abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; { @Override public final AndroidInjector&lt;T&gt; create(T instance) { seedInstance(instance); return build(); } @BindsInstance public abstract void seedInstance(T instance); public abstract AndroidInjector&lt;T&gt; build(); } } 在注释1处，使用了抽象工厂模式，用来创建一个具体的Activity或Fragment类型的AndroidInjector实例。注释2处，Builder实现了AndroidInjector.Factory，它是一种Subcomponent.Builder的通用实现模式，在重写的create()方法中，进行了实例保存seedInstance()和具体Android核心类型的构建。 接着，我们回到MainActivitySubcomponentBuilder类，可以看到，它实现了AndroidInjector.Builder的seedInstance()和build()方法。在注释3处首先播种了MainActivity的实例，然后 在注释2处新建了一个MainActivitySubcomponentImpl对象返回。我们看看MainActivitySubcomponentImpl这个类是如何将mPresenter依赖注入的，相关源码如下： private final class MainActivitySubcomponentImpl implements AbstractAllActivityModule_ContributesMainActivityInjector .MainActivitySubcomponent { private MainPresenter getMainPresenter() { // 2 return MainPresenter_Factory.newMainPresenter( DaggerAppComponent.this.provideDataManagerProvider.get()); } @Override public void inject(MainActivity arg0) { // 1 injectMainActivity(arg0); } private MainActivity injectMainActivity(MainActivity instance) { // 3 BaseActivity_MembersInjector .injectMPresenter(instance, getMainPresenter()); return instance; } 在注释1处，MainActivitySubcomponentImpl实现了AndroidInjector接口的inject()方法，在injectMainActivity()首先调用getMainPresenter()方法从MainPresenter_Factory工厂类中新建了一个MainPresenter对象。我们看看MainPresenter的newMainPresenter()方法： public static MainPresenter newMainPresenter(DataManager dataManager) { return new MainPresenter(dataManager); } 这里直接新建了一个MainPresenter。然后我们回到MainActivitySubcomponentImpl类的注释3处，继续调用了BaseActivity_MembersInjector的injectMPresenter()方法，顾名思义，可以猜到，它是BaseActivity的成员注射器，继续看看injectMPresenter()内部： public static &lt;T extends AbstractPresenter&gt; void injectMPresenter( BaseActivity&lt;T&gt; instance, T mPresenter) { instance.mPresenter = mPresenter; } 可以看到，这里直接将需要的mPresenter实例赋值给了BaseActivity的mPresenter，当然，这里其实是指的BaseActivity的子类MainActivity，其它的xxxActivity的依赖管理机制都是如此。 appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？ 我们继续查看appComponent的inject()方法： @Override public void inject(WanAndroidApp wanAndroidApp) { injectWanAndroidApp(wanAndroidApp); } 在inject()方法里调用了injectWanAndroidApp()，继续查看injectWanAndroidApp()方法： private WanAndroidApp injectWanAndroidApp(WanAndroidApp instance) { WanAndroidApp_MembersInjector.injectMAndroidInjector( instance, getDispatchingAndroidInjectorOfActivity()); return instance; } 首先，执行getDispatchingAndroidInjectorOfActivity()方法得到了一个Activity类型的DispatchingAndroidInjector对象，继续查看getDispatchingAndroidInjectorOfActivity()方法： private DispatchingAndroidInjector&lt;Activity&gt; getDispatchingAndroidInjectorOfActivity() { return DispatchingAndroidInjector_Factory.newDispatchingAndroidInjector( getMapOfClassOfAndProviderOfFactoryOf()); } 在getDispatchingAndroidInjectorOfActivity()方法里面，首先调用了getMapOfClassOfAndProviderOfFactoryOf()方法，我们看到这个方法： private Map&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt; getMapOfClassOfAndProviderOfFactoryOf() { return MapBuilder .&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt; newMapBuilder(8) .put(MainActivity.class, (Provider) mainActivitySubcomponentBuilderProvider) .put(SplashActivity.class, (Provider) splashActivitySubcomponentBuilderProvider) .put(ArticleDetailActivity.class, (Provider) articleDetailActivitySubcomponentBuilderProvider) .put(KnowledgeHierarchyDetailActivity.class, (Provider) knowledgeHierarchyDetailActivitySubcomponentBuilderProvider) .put(LoginActivity.class, (Provider) loginActivitySubcomponentBuilderProvider) .put(RegisterActivity.class, (Provider) registerActivitySubcomponentBuilderProvider) .put(AboutUsActivity.class, (Provider) aboutUsActivitySubcomponentBuilderProvider) .put(SearchListActivity.class, (Provider) searchListActivitySubcomponentBuilderProvider) .build(); } 可以看到，这里新建了一个建造者模式实现的MapBuilder，并且同时制定了固定容量为8，将项目下使用了AndroidInjection.inject(mActivity)方法的8个Activity对应的xxxActivitySubcomponentBuilderProvider保存起来。 我们再回到getDispatchingAndroidInjectorOfActivity()方法，这里将上面得到的Map容器传入了DispatchingAndroidInjector_Factory的newDispatchingAndroidInjector()方法中，这里应该就是新建DispatchingAndroidInjector的地方了。我们点进去看看： public static &lt;T&gt; DispatchingAndroidInjector&lt;T&gt; newDispatchingAndroidInjector( Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) { return new DispatchingAndroidInjector&lt;T&gt;(injectorFactories); } 在这里，果然新建了一个DispatchingAndroidInjector对象。继续看看DispatchingAndroidInjector的构造方法： @Inject DispatchingAndroidInjector( Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) { this.injectorFactories = injectorFactories; } 这里仅仅是将传进来的Map容器保存起来了。 我们再回到WanAndroidApp_MembersInjector的injectMAndroidInjector()方法，将上面得到的DispatchingAndroidInjector实例传入，继续查看injectMAndroidInjector()这个方法： public static void injectMAndroidInjector( WanAndroidApp instance, DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector) { instance.mAndroidInjector = mAndroidInjector; } 可以看到，最后在WanAndroidApp_MembersInjector的injectMAndroidInjector()方法中，直接将新建好的DispatchingAndroidInjector实例赋值给了WanAndroidApp的mAndroidInjector。 在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？ 首先，我们看到AndroidInjection.inject(this)这个方法： public static void inject(Activity activity) { checkNotNull(activity, \"activity\"); // 1 Application application = activity.getApplication(); if (!(application instanceof HasActivityInjector)) { throw new RuntimeException( String.format( \"%s does not implement %s\", application.getClass().getCanonicalName(), HasActivityInjector.class.getCanonicalName())); } // 2 AndroidInjector&lt;Activity&gt; activityInjector = ((HasActivityInjector) application).activityInjector(); checkNotNull(activityInjector, \"%s.activityInjector() returned null\", application.getClass()); // 3 activityInjector.inject(activity); } 在注释1处，会先判断当前的application是否实现了HasActivityInjector这个接口，如果没有，则抛出RuntimeException。如果有，会继续在注释2处调用application的activityInjector()方法得到DispatchingAndroidInjector实例。最后，在注释3处，会将当前的activity实例传入activityInjector的inject()方法中。我们继续查看inject()方法： @Override public void inject(T instance) { boolean wasInjected = maybeInject(instance); if (!wasInjected) { throw new IllegalArgumentException(errorMessageSuggestions(instance)); } } DispatchingAndroidInjector的inject()方法，它的作用就是给传入的instance实例执行成员注入。具体在这个案例中，其实就是负责将创建好的Presenter实例赋值给BaseActivity对象 的mPresenter全局变量。在inject()方法中，又调用了maybeInject()方法，我们继续查看它： @CanIgnoreReturnValue public boolean maybeInject(T instance) { // 1 Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt; factoryProvider = injectorFactories.get(instance.getClass()); if (factoryProvider == null) { return false; } @SuppressWarnings(\"unchecked\") // 2 AndroidInjector.Factory&lt;T&gt; factory = (AndroidInjector.Factory&lt;T&gt;) factoryProvider.get(); try { // 3 AndroidInjector&lt;T&gt; injector = checkNotNull( factory.create(instance), \"%s.create(I) should not return null.\", factory.getClass()); // 4 injector.inject(instance); return true; } catch (ClassCastException e) { ... } } 在注释1处，我们从injectorFactories（前面得到的Map容器）中根据当前Activity实例拿到了factoryProvider对象，这里我们具体一点，看到MainActivity对应的factoryProvider，也就是我们研究的第一个问题中的mainActivitySubcomponentBuilderProvider： private void initialize(final Builder builder) { this.mainActivitySubcomponentBuilderProvider = new Provider&lt; AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent .Builder&gt;() { @Override public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent .Builder get() { return new MainActivitySubcomponentBuilder(); } }; ... } 在maybeInject()方法的注释2处，调用了mainActivitySubcomponentBuilderProvider的get()方法得到了一个新建的MainActivitySubcomponentBuilder对象。在注释3处执行了它的create方法，create()方法的具体实现在AndroidInjector的内部类Builder中： abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; { @Override public final AndroidInjector&lt;T&gt; create(T instance) { seedInstance(instance); return build(); } 看到这里，我相信看过第一个问题的同学已经明白后面是怎么回事了。在create()方法中，我们首先MainActivitySubcomponentBuilder的seedInstance()将MainActivity实例注入，然后再调用它的build()方法新建了一个MainActivitySubcomponentImpl实例返回。 最后，在注释4处，执行了MainActivitySubcomponentImpl的inject()方法： private final class MainActivitySubcomponentImpl implements AbstractAllActivityModule_ContributesMainActivityInjector .MainActivitySubcomponent { private MainPresenter getMainPresenter() { // 2 return MainPresenter_Factory.newMainPresenter( DaggerAppComponent.this.provideDataManagerProvider.get()); } @Override public void inject(MainActivity arg0) { // 1 injectMainActivity(arg0); } private MainActivity injectMainActivity(MainActivity instance) { // 3 BaseActivity_MembersInjector .injectMPresenter(instance, getMainPresenter()); return instance; } 这里的逻辑已经在问题一的最后部分详细讲解了，最后，会在注释3处调用BaseActivity_MembersInjector的injectMPresenter()方法： public static &lt;T extends AbstractPresenter&gt; void injectMPresenter( BaseActivity&lt;T&gt; instance, T mPresenter) { instance.mPresenter = mPresenter; } 这样，就将mPresenter对象赋值给了当前Activity对象的mPresenter全局变量中了。至此，Dagger.Android的核心源码分析就结束了。 相比于ButterKnife，Dagger是一个锋利的全局依赖注入管理框架，它主要用来管理对象的依赖关系和生命周期，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity或Fragment，有些是单例，而且它们的生命周期不一致，所以创建所需对象时需要处理的各个对象的依赖关系和生命周期时的任务会很繁重。因此，使用Dagger会大大减轻这方面的工作量。虽然它的学习成本比较高，而且需要写一定的模板类，但是，对于越大的项目来说，Dagger越值得被需要。 EventBus 简单示例 首先，定义要传递的事件实体 public class CollectEvent { ... } 准备订阅者：声明并注解你的订阅方法 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(CollectEvent event) { LogHelper.d(\"OK\"); } 在2中，也就是订阅中所在的类中，注册和解注册你的订阅者 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } 发送事件 EventBus.getDefault().post(new CollectEvent()); 在正式讲解之前需要对一些基础性的概念进行详细的讲解。众所周知，EventBus没出现之前，那时候的开发者一般是使用Android四大组件中的广播进行组件间的消息传递，那么我们为什么要使用事件总线机制来替代广播呢？ 主要是因为： 广播：耗时、容易被捕获（不安全）。 事件总线：更节省资源、更高效，能将信息传递给原生以外的各种对象。 那么，话又说回来了，事件总线又是什么呢？ 如下图所示，事件总线机制通过记录对象、使用观察者模式来通知对象各种事件。（当然，你也可以发送基本数据类型如 int，String 等作为一个事件） 对于事件总线EventBus而言，它的优缺点又是如何？这里简单总结下： 优点：开销小，代码更优雅、简洁，解耦发送者和接收者，可动态设置事件处理线程和优先级。 缺点：每个事件必须自定义一个事件类，增加了维护成本。 EventBus是基于观察者模式扩展而来的，我们先了解一下观察者模式是什么？ 观察者模式又可称为发布 - 订阅模式，它定义了对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。 观察者模式有以下角色： 抽象被观察者：将所有已注册的观察者对象保存在一个集合中。 具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。 抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。 具体观察者：实现抽象观察者的更新接口。 这里给出一个简单的示例来让大家更深一步理解观察者模式的思想： 1、首先，创建抽象观察者 public interface observer { public void update(String message); } 2、接着，创建具体观察者 public class WeXinUser implements observer { private String name; public WeXinUser(String name) { this.name = name; } @Override public void update(String message) { ... } } 3、然后，创建抽象被观察者 public interface observable { public void addWeXinUser(WeXinUser weXinUser); public void removeWeXinUser(WeXinUser weXinUser); public void notify(String message); } 4、最后，创建具体被观察者 public class Subscription implements observable { private List&lt;WeXinUser&gt; mUserList = new ArrayList(); @Override public void addWeXinUser(WeXinUser weXinUser) { mUserList.add(weXinUser); } @Override public void removeWeXinUser(WeXinUser weXinUser) { mUserList.remove(weXinUser); } @Override public void notify(String message) { for(WeXinUser weXinUser : mUserList) { weXinUser.update(message); } } } 在具体使用时，我们便可以这样使用，如下所示： Subscription subscription = new Subscription(); WeXinUser hongYang = new WeXinUser(\"HongYang\"); WeXinUser rengYuGang = new WeXinUser(\"RengYuGang\"); WeXinUser liuWangShu = new WeXinUser(\"LiuWangShu\"); subscription.addWeiXinUser(hongYang); subscription.addWeiXinUser(rengYuGang); subscription.addWeiXinUser(liuWangShu); subscription.notify(\"New article coming\"); 在这里，hongYang、rengYuGang、liuWangShu等大神都订阅了我的微信公众号，每当我的公众号发表文章时（subscription.notify())，他们就会接收到最新的文章信息（weXinUser.update()）。（ps：当然，这一切都是YY~） 当然，EventBus的观察者模式和一般的观察者模式不同，它使用了扩展的观察者模式对事件进行订阅和分发，其实这里的扩展就是指的使用了EventBus来作为中介者，抽离了许多职责，如下是它的官方原理图： 在得知了EventBus的原理之后，我们注意到，每次我们在register之后，都必须进行一次unregister，这是为什么呢？ 因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。 有些同学可能之前使用的是EventBus2.x的版本，那么它又与EventBus3.x的版本有哪些区别呢？ EventBus2.x使用的是运行时注解，它采用了反射的方式对整个注册的类的所有方法进行扫描来完成注册，因而会对性能有一定影响。 EventBus3.x使用的是编译时注解，Java文件会编译成.class文件，再对class文件进行打包等一系列处理。在编译成.class文件时，EventBus会使用EventBusAnnotationProcessor注解处理器读取@Subscribe()注解并解析、处理其中的信息，然后生成Java类来保存所有订阅者的订阅信息。这样就创建出了对文件或类的索引关系，并将其编入到apk中。 从EventBus3.0开始使用了对象池缓存减少了创建对象的开销。 除了EventBus，其实现在比较流行的事件总线还有RxBus，那么，它与EventBus相比又如何呢？ RxJava的Observable有onError、onComplete等状态回调。 Rxjava使用组合而非嵌套的方式，避免了回调地狱。 Rxjava的线程调度设计的更加优秀，更简单易用。 Rxjava可使用多种操作符来进行链式调用来实现复杂的逻辑。 Rxjava的信息效率高于EventBus2.x，低于EventBus3.x。 在了解了EventBus和RxBus的区别之后，那么，对待新项目的事件总线选型时，我们该如何考量？ 很简单，如果项目中使用了RxJava，则使用RxBus，否则使用EventBus3.x。 源码分析 接下来将按以下顺序来进行EventBus的源码分析： 订阅者：EventBus.getDefault().register(this)； 发布者：EventBus.getDefault().post(new CollectEvent())； 订阅者：EventBus.getDefault().unregister(this)。 EventBus.getDefault().register(this) 首先，从获取EventBus实例的方法getDefault()开始分析： public static EventBus getDefault() { if (defaultInstance == null) { synchronized (EventBus.class) { if (defaultInstance == null) { defaultInstance = new EventBus(); } } } return defaultInstance; } 在getDefault()中使用了双重校验并加锁的单例模式来创建EventBus实例。 接着，看到EventBus的默认构造方法中做了什么: private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); public EventBus() { this(DEFAULT_BUILDER); } 在EventBus的默认构造方法中又调用了它的另一个有参构造方法，将一个类型为EventBusBuilder的DEFAULT_BUILDER对象传递进去了。这里的EventBusBuilder很明显是一个EventBus的建造器，以便于EventBus能够添加自定义的参数和安装一个自定义的默认EventBus实例。 再看一下EventBusBuilder的构造方法： public class EventBusBuilder { ... EventBusBuilder() { } ... } EventBusBuilder的构造方法中什么也没有做，那继续查看EventBus的这个有参构造方法： private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; EventBus(EventBusBuilder builder) { ... // 1 subscriptionsByEventType = new HashMap&lt;&gt;(); // 2 typesBySubscriber = new HashMap&lt;&gt;(); // 3 stickyEvents = new ConcurrentHashMap&lt;&gt;(); // 4 mainThreadSupport = builder.getMainThreadSupport(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); ... // 5 subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); // 从builder取中一些列订阅相关信息进行赋值 ... // 6 executorService = builder.executorService; } 在注释1处，创建了一个subscriptionsByEventType对象，可以看到它是一个类型为HashMap的subscriptionsByEventType对象，并且其key为 Event 类型，value为 Subscription链表。这里的Subscription是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object 的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity对象）；另一个是 类型为SubscriberMethod 的 subscriberMethod，它就是被@Subscribe注解的那个订阅方法，里面保存了一个重要的字段eventType，它是 Class&lt;?&gt; 类型的，代表了 Event 的类型。在注释2处，新建了一个类型为 Map 的typesBySubscriber对象，它的key为subscriber对象，value为subscriber对象中所有的 Event 类型链表，日常使用中仅用于判断某个对象是否注册过。在注释3处新建了一个类型为ConcurrentHashMap的stickyEvents对象，它是专用于粘性事件处理的一个字段，key为事件的Class对象，value为当前的事件。可能有的同学不了解sticky event，这里解释下： 我们都知道普通事件是先注册，然后发送事件才能收到；而粘性事件，在发送事件之后再订阅该事件也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非你手动解除注册。 在注释4处，新建了三个不同类型的事件发送器，这里总结下： mainThreadPoster：主线程事件发送器，通过它的mainThreadPoster.enqueue(subscription, event)方法可以将订阅信息和对应的事件进行入队，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。 backgroundPoster：后台事件发送器，通过它的enqueue() 将方法加入到后台的一个队列，最后通过线程池去执行，注意，它在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。 asyncPoster：实现逻辑类似于backgroundPoster，不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster则是异步运行的，可以同时接收多个任务。 我们再回到注释5这行代码，这里新建了一个subscriberMethodFinder对象，这是从EventBus中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到组合优于继承的这种实现思想。在注释6处，从builder中取出了一个默认的线程池对象，它由**Executors的newCachedThreadPool()**方法创建，它是一个**有则用、无则创建、无数量上限**的线程池。 分析完这些核心的字段之后，后面的讲解就比较轻松了，接着查看EventBus的regist()方法： public void register(Object subscriber) { Class&lt;?&gt; subscriberClass = subscriber.getClass(); // 1 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) { for (SubscriberMethod subscriberMethod : subscriberMethods) { // 2 subscribe(subscriber, subscriberMethod); } } } 在注释1处，根据当前注册类获取 subscriberMethods这个订阅方法列表 。在注释2处，使用了增强for循环令subsciber对象 对 subscriberMethods 中每个 SubscriberMethod 进行订阅。 接着查看SubscriberMethodFinder的findSubscriberMethods()方法： List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) { // 1 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) { return subscriberMethods; } // 2 if (ignoreGeneratedIndex) { subscriberMethods = findUsingReflection(subscriberClass); } else { subscriberMethods = findUsingInfo(subscriberClass); } if (subscriberMethods.isEmpty()) { throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); } else { METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; } } 在注释1处，如果缓存中有subscriberClass对象对应 的订阅方法列表，则直接返回。注释2处，先详细说说这个ignoreGeneratedIndex字段， 它用来判断是否使用生成的 APT 代码去优化寻找接收事件的过程，如果开启了的话，那么将会通过 subscriberInfoIndexes 来快速得到接收事件方法的相关信息。如果我们没有在项目中接入 EventBus 的 APT，那么可以将 ignoreGeneratedIndex 字段设为 false 以提高性能。这里ignoreGeneratedIndex 默认为false，所以会执行findUsingInfo()方法，后面生成 subscriberMethods 成功的话会加入到缓存中，失败的话会 抛出异常。 接着查看SubscriberMethodFinder的findUsingInfo()方法： private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) { // 1 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); // 2 while (findState.clazz != null) { findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) { SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod: array) { if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) { findState.subscriberMethods.add(subscriberMethod); } } } else { // 3 findUsingReflectionInSingleClass(findState); } findState.moveToSuperclass(); } // 4 return getMethodsAndRelease(findState); } 在注释1处，调用了SubscriberMethodFinder的prepareFindState()方法创建了一个新的 FindState 类，来看看这个方法： private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE]; private FindState prepareFindState() { // 1 synchronized(FIND_STATE_POOL) { for (int i = 0; i &lt; POOL_SIZE; i++) { FindState state = FIND_STATE_POOL[i]; if (state != null) { FIND_STATE_POOL[i] = null; return state; } } } // 2 return new FindState(); } 在注释1处，会先从 FIND_STATE_POOL 即 FindState 池中取出可用的 FindState（这里的POOL_SIZE为4），如果没有的话，则通过注释2处的代码直接新建 一个新的 FindState 对象。 接着来分析下FindState这个类： static class FindState { .... void initForSubscriber(Class&lt;?&gt; subscriberClass) { this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; } ... } 它是 SubscriberMethodFinder 的内部类，这个方法主要做一个初始化、回收对象等工作。 接着回到SubscriberMethodFinder的注释2处的SubscriberMethodFinder()方法： private SubscriberInfo getSubscriberInfo(FindState findState) { if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) { SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) { return superclassInfo; } } if (subscriberInfoIndexes != null) { for (SubscriberInfoIndex index: subscriberInfoIndexes) { SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) { return info; } } } return null; } 在前面初始化的时候，findState的subscriberInfo和subscriberInfoIndexes 这两个字段为空，所以这里直接返回 null。 接着查看注释3处的findUsingReflectionInSingleClass()方法： private void findUsingReflectionInSingleClass(FindState findState) { Method[] methods; try { // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); } catch (Throwable th) { methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; } for (Method method: methods) { int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) { Class&lt;?&gt; [] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) { Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) { // 重点 Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) { ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); } } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); } } } 这个方法很长，大概做的事情是： 通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 @Subscribe作为注解的方法进行处理。 在经过经过一轮检查，看看 findState.subscriberMethods是否存在，如果没有，将方法名，threadMode，优先级，是否为 sticky 方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中。 最后，继续查看注释4处的getMethodsAndRelease()方法： private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) { // 1 List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); // 2 findState.recycle(); // 3 synchronized(FIND_STATE_POOL) { for (int i = 0; i &lt; POOL_SIZE; i++) { if (FIND_STATE_POOL[i] == null) { FIND_STATE_POOL[i] = findState; break; } } } // 4 return subscriberMethods; } 在这里，首先在注释1处，从findState中取出了保存的subscriberMethods。在注释2处，将findState里的保存的所有对象进行回收。在注释3处，把findState存储在 FindState 池中方便下一次使用，以提高性能。最后，在注释4处，返回subscriberMethods。接着，在EventBus的 register() 方法的最后会调用 subscribe 方法： public void register(Object subscriber) { Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) { for (SubscriberMethod subscriberMethod : subscriberMethods) { subscribe(subscriber, subscriberMethod); } } } 继续看看这个subscribe()方法做的事情： private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) { Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); // 1 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) { subscriptions = new CopyOnWriteArrayList &lt;&gt; (); subscriptionsByEventType.put(eventType, subscriptions); } else { if (subscriptions.contains(newSubscription)) { throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); } } int size = subscriptions.size(); // 2 for (int i = 0; i &lt;= size; i++) { if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) { subscriptions.add(i, newSubscription); break; } } // 3 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) { subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); } subscribedEvents.add(eventType); // 4 if (subscriberMethod.sticky) { if (eventInheritance) { Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) { Class&lt;?&gt; candidateEventType = entry.getKey(); if(eventType.isAssignableFrom(candidateEventType)) { Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } else { Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } 首先，在注释1处，会根据 subscriberMethod的eventType，在 subscriptionsByEventType 去查找一个 CopyOnWriteArrayList ，如果没有则创建一个新的 CopyOnWriteArrayList，然后将这个 CopyOnWriteArrayList 放入 subscriptionsByEventType 中。在注释2处，添加 newSubscription对象，它是一个 Subscription 类，里面包含着 subscriber 和 subscriberMethod 等信息，并且这里有一个优先级的判断，说明它是按照优先级添加的。优先级越高，会插到在当前 List 靠前面的位置。在注释3处，对typesBySubscriber 进行添加，这主要是在EventBus的isRegister()方法中去使用的，目的是用来判断这个 Subscriber对象 是否已被注册过。最后，在注释4处，会判断是否是 sticky事件。如果是sticky事件的话，会调用 checkPostStickyEventToSubscription() 方法。 接着查看这个checkPostStickyEventToSubscription()方法： private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) { if (stickyEvent != null) { postToSubscription(newSubscription, stickyEvent, isMainThread()); } } 可以看到最终是调用了postToSubscription()这个方法来进行粘性事件的发送，对于粘性事件的处理，最后再分析，接下来看看事件是如何post的。 EventBus.getDefault().post(new CollectEvent()) public void post(Object event) { // 1 PostingThreadState postingState = currentPostingThreadState.get(); List &lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); // 2 if (!postingState.isPosting) { postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) { throw new EventBusException(\"Internal error. Abort state was not reset\"); } try { while (!eventQueue.isEmpty()) { postSingleEvent(eventQueue.remove(0), postingState); } } finally { postingState.isPosting = false; postingState.isMainThread = false; } } } 注释1处，这里的currentPostingThreadState 是一个 ThreadLocal 类型的对象，里面存储了 PostingThreadState，而 PostingThreadState 中包含了一个 eventQueue 和其他一些标志位，相关的源码如下： private final ThreadLocal &lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal &lt;PostingThreadState&gt; () { @Override protected PostingThreadState initialValue() { return new PostingThreadState(); } }; final static class PostingThreadState { final List &lt;Object&gt; eventQueue = new ArrayList&lt;&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; } 接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 中。在注释2处，最后调用了 postSingleEvent() 方法，我们继续查看这个方法： private void postSingleEvent(Object event, PostingThreadState postingState) throws Error { Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; // 1 if (eventInheritance) { // 2 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) { Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= // 3 postSingleEventForEventType(event, postingState, clazz); } } else { subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); } if (!subscriptionFound) { ... } } 首先，在注释1处，首先取出 Event 的 class 类型，接着会对 eventInheritance 标志位 判断，它默认为true，如果设为 true 的话，它会在发射事件的时候判断是否需要发射父类事件，设为 false，能够提高一些性能。接着，在注释2处，会调用lookupAllEventTypes() 方法，它的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个 eventTypesCache 的缓存，这样就不用重复调用 getSuperclass() 方法。最后，在注释3处会调用postSingleEventForEventType()方法，看下这个方法： private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class &lt;?&gt; eventClass) { CopyOnWriteArrayList &lt;Subscription&gt; subscriptions; synchronized(this) { subscriptions = subscriptionsByEventType.get(eventClass); } if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) { for (Subscription subscription: subscriptions) { postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try { postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; } finally { postingState.event = null; postingState.subscription = null; postingState.canceled = false; } if (aborted) { break; } } return true; } return false; } 可以看到，这里直接根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions对象，最后调用了 postToSubscription() 方法。 这个时候再看看这个postToSubscription()方法： private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { switch (subscription.subscriberMethod.threadMode) { case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; case MAIN_ORDERED: if (mainThreadPoster != null) { mainThreadPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknow thread mode: \" + subscription.subscriberMethod.threadMode); } } 从上面可以看出，这里通过threadMode 来判断在哪个线程中去执行方法： POSTING：执行 invokeSubscriber() 方法，内部直接采用反射调用。 MAIN：首先去判断当前是否在 UI 线程，如果是的话则直接反射调用，否则调用mainThreadPoster的enqueue()方法，即把当前的方法加入到队列之中，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。 MAIN_ORDERED：与MAIN类似，不过是确保是顺序执行的。 BACKGROUND：判断当前是否在 UI 线程，如果不是的话则直接反射调用，是的话通过backgroundPoster的enqueue()方法 将方法加入到后台的一个队列，最后通过线程池去执行。注意，backgroundPoster在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。 ASYNC：逻辑实现类似于BACKGROUND，将任务加入到后台的一个队列，最终由Eventbus 中的一个线程池去调用，这里的线程池与 BACKGROUND 逻辑中的线程池用的是同一个，即使用Executors的newCachedThreadPool()方法创建的线程池，它是一个有则用、无则创建、无数量上限的线程池。不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，这里asyncPoster则是异步运行的，可以同时接收多个任务。 分析完EventBus的post()方法值，接着看看它的unregister()。 EventBus.getDefault().unregister(this) 它的核心源码如下所示： public synchronized void unregister(Object subscriber) { List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) { for (Class&lt;?&gt; eventType : subscribedTypes) { //1 unsubscribeByEventType(subscriber, eventType); } // 2 typesBySubscriber.remove(subscriber); } } 首先，在注释1处，unsubscribeByEventType() 方法中对 subscriptionsByEventType 移除了该 subscriber 的所有订阅信息。最后，在注释2处，移除了注册对象和其对应的所有 Event 事件链表。 最后，再来分析下EventBus中对粘性事件的处理。 EventBus.getDefault.postSticky(new CollectEvent()) 如果想要发射 sticky 事件需要通过 EventBus的postSticky() 方法，内部源码如下所示： public void postSticky(Object event) { synchronized (stickyEvents) { // 1 stickyEvents.put(event.getClass(), event); } // 2 post(event); } 在注释1处，先将该事件放入 stickyEvents 中，接着在注释2处使用post()发送事件。前面我们在分析register()方法的最后部分时，其中有关粘性事件的源码如下： if (subscriberMethod.sticky) { Object stickyEvent = stickyEvents.get(eventType); if (stickyEvent != null) { postToSubscription(newSubscription, stickyEvent, isMainThread()); } } 可以看到，在这里会判断当前事件是否是 sticky 事件，如果是，则从 stickyEvents 中拿出该事件并执行 postToSubscription() 方法。 EventBus 的源码在Android主流三方库源码分析系列中可以说是除了ButterKnife之外，算是比较简单的了。但是，它其中的一些思想和设计是值得借鉴的。比如它使用 FindState 复用池来复用 FindState 对象，在各处使用了 synchronized 关键字进行代码块同步的一些优化操作。其中上面分析了这么多，EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"设计模式汇总","slug":"docs/Android/知识汇总/设计模式汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/she-ji-mo-shi-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/she-ji-mo-shi-hui-zong/","excerpt":"","text":"设计模式分类 面向对象六大原则 工厂模式 单例模式 建造者模式 原型模式 适配器模式 观察者模式 代理模式 责任链模式 策略模式 备忘录模式 设计模式分类 模式 &amp; 描述 包括 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 结构型模式关注类和对象的组合。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 行为型模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 面向对象六大原则 原则 描述 单一职责原则 一个类只负责一个功能领域中的相应职责。 开闭原则 对象应该对于扩展是开放的，对于修改是封闭的。 里氏替换原则 所有引用基类的地方必须能透明地使用其子类的对象。 依赖倒置原则 高层模块不依赖低层模块，两者应该依赖其对象；抽象不应该依赖细节；细节应该依赖抽象。 接口隔离原则 类间的依赖关系应该建立在最小的接口上。 迪米特原则 也称最少知识原则，一个对象对其他对象有最少的了解。 工厂模式 适用于复杂对象的创建。 示例： Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.demo); BitmapFactory.java // 生成 Bitmap 对象的工厂类 BitmapFactory public class BitmapFactory { ··· public static Bitmap decodeFile(String pathName) { ··· } ··· public static Bitmap decodeResource(Resources res, int id, Options opts) { validate(opts); Bitmap bm = null; InputStream is = null; try { final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); } ··· return bm; } ··· } 单例模式 确保某一个类只有一个实例，并自动实例化向整个系统提供这个实例，且可以避免产生多个对象消耗资源。 示例： InputMethodManager.java /** * Retrieve the global InputMethodManager instance, creating it if it * doesn't already exist. * @hide */ public static InputMethodManager getInstance() { synchronized (InputMethodManager.class) { if (sInstance == null) { try { sInstance = new InputMethodManager(Looper.getMainLooper()); } catch (ServiceNotFoundException e) { throw new IllegalStateException(e); } } return sInstance; } } 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，适用于初始化的对象比较复杂且参数较多的情况。 示例： AlertDialog.Builder builder = new AlertDialog.Builder(this) .setTitle(\"Title\") .setMessage(\"Message\"); AlertDialog dialog = builder.create(); dialog.show(); AlertDialog.java public class AlertDialog extends Dialog implements DialogInterface { ··· public static class Builder { private final AlertController.AlertParams P; ··· public Builder(Context context) { this(context, resolveDialogTheme(context, ResourceId.ID_NULL)); } ··· public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } ··· public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } ··· public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); ··· return dialog; } ··· } } 原型模式 用原型模式实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 示例： ArrayList&lt;T&gt; newArrayList = (ArrayList&lt;T&gt;) arrayList.clone(); ArrayList.java /** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } } 适配器模式 适配器模式把一个类的接口变成客户端所期待的另一种接口，从而使原因接口不匹配而无法一起工作的两个类能够在一起工作。 示例： RecyclerView recyclerView = findViewById(R.id.recycler_view); recyclerView.setAdapter(new MyAdapter()); private class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { ··· } ··· } RecyclerView.java ··· private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) { if (mAdapter != null) { mAdapter.unregisterAdapterDataObserver(mObserver); mAdapter.onDetachedFromRecyclerView(this); } ··· mAdapterHelper.reset(); final Adapter oldAdapter = mAdapter; mAdapter = adapter; if (adapter != null) { adapter.registerAdapterDataObserver(mObserver); adapter.onAttachedToRecyclerView(this); } if (mLayout != null) { mLayout.onAdapterChanged(oldAdapter, mAdapter); } mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious); mState.mStructureChanged = true; } ··· public final class Recycler { @Nullable ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { ··· ViewHolder holder = null; ··· if (holder == null) { ··· holder = mAdapter.createViewHolder(RecyclerView.this, type); ··· } ··· return holder; } } ··· public abstract static class Adapter&lt;VH extends ViewHolder&gt; { ··· @NonNull public abstract VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType); @NonNull public final VH createViewHolder(@NonNull ViewGroup parent, int viewType) { try { TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG); final VH holder = onCreateViewHolder(parent, viewType); ··· holder.mItemViewType = viewType; return holder; } finally { TraceCompat.endSection(); } } ··· } 观察者模式 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 示例： MyAdapter adapter = new MyAdapter(); recyclerView.setAdapter(adapter); adapter.notifyDataSetChanged(); RecyclerView.java ··· private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); ··· private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) { ··· mAdapter = adapter; if (adapter != null) { adapter.registerAdapterDataObserver(mObserver); adapter.onAttachedToRecyclerView(this); } ··· } ··· public abstract static class Adapter&lt;VH extends ViewHolder&gt; { private final AdapterDataObservable mObservable = new AdapterDataObservable(); ··· public void registerAdapterDataObserver(@NonNull AdapterDataObserver observer) { mObservable.registerObserver(observer); } ··· public final void notifyDataSetChanged() { mObservable.notifyChanged(); } } static class AdapterDataObservable extends Observable&lt;AdapterDataObserver&gt; { ··· public void notifyChanged() { for (int i = mObservers.size() - 1; i &gt;= 0; i--) { mObservers.get(i).onChanged(); } } ··· } private class RecyclerViewDataObserver extends AdapterDataObserver { ··· @Override public void onChanged() { assertNotInLayoutOrScroll(null); mState.mStructureChanged = true; processDataSetCompletelyChanged(true); if (!mAdapterHelper.hasPendingUpdates()) { requestLayout(); } } ··· } 代理模式 为其他的对象提供一种代理以控制对这个对象的访问。适用于当无法或不想直接访问某个对象时通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。 示例： Context.java public abstract class Context { ··· public abstract void startActivity(@RequiresPermission Intent intent); ··· } ContextWrapper.java public class ContextWrapper extends Context { Context mBase; // 代理类，实为 ContextImpl 对象 ··· protected void attachBaseContext(Context base) { if (mBase != null) { throw new IllegalStateException(\"Base context already set\"); } mBase = base; } ··· @Override public void startActivity(Intent intent) { mBase.startActivity(intent); // 核心工作交由给代理类对象 mBase 实现 } ··· } ContextImpl.java // Context 的真正实现类 class ContextImpl extends Context { ... @Override public void startActivity(Intent intent) { warnIfCallingFromSystemProcess(); startActivity(intent, null); } ... } 责任链模式 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 ViewGroup.java @UiThread public abstract class ViewGroup extends View implements ViewParent, ViewManager { ··· private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; ··· final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { ··· // 获取子 view 处理的结果 handled = child.dispatchTouchEvent(event); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { ··· // 获取子 view 处理的结果 handled = child.dispatchTouchEvent(transformedEvent); } ··· return handled; } ··· } 策略模式 策略模式定义了一系列的算法，并封装起来，提供针对同一类型问题的多种处理方式。 示例： // 匀速 animation.setInterpolator(new LinearInterpolator()); // 加速 animation.setInterpolator(new AccelerateInterpolator()); ··· BaseInterpolator.java /** * An abstract class which is extended by default interpolators. */ abstract public class BaseInterpolator implements Interpolator { private @Config int mChangingConfiguration; /** * @hide */ public @Config int getChangingConfiguration() { return mChangingConfiguration; } /** * @hide */ void setChangingConfiguration(@Config int changingConfiguration) { mChangingConfiguration = changingConfiguration; } } LinearInterpolator.java @HasNativeInterpolator public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory { ··· } AccelerateInterpolator.java @HasNativeInterpolator public class AccelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory { ··· } 备忘录模式 在不破坏封闭的前提下，在对象之外保存保存对象的当前状态，并且在之后可以恢复到此状态。 示例： Activity.java // 保存状态 protected void onSaveInstanceState(Bundle outState) { // 存储当前窗口的视图树的状态 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); // 存储 Fragment 的状态 Parcelable p = mFragments.saveAllState(); if (p != null) { outState.putParcelable(FRAGMENTS_TAG, p); } if (mAutoFillResetNeeded) { outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); } // 调用 ActivityLifecycleCallbacks 的 onSaveInstanceState 进行存储状态 getApplication().dispatchActivitySaveInstanceState(this, outState); } ··· // onCreate 方法中恢复状态 protected void onCreate(@Nullable Bundle savedInstanceState) { ··· if (savedInstanceState != null) { mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false); mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID); if (mAutoFillResetNeeded) { getAutofillManager().onCreate(savedInstanceState); } Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(this, savedInstanceState); ··· mRestoredFromBundle = savedInstanceState != null; mCalled = true; } ActivityThread.java @Override public void handleStartActivity(ActivityClientRecord r, PendingTransactionActions pendingActions) { final Activity activity = r.activity; ··· // Start activity.performStart(\"handleStartActivity\"); r.setState(ON_START); ··· // Restore instance state if (pendingActions.shouldRestoreInstanceState()) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ··· }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"LinuxMint删除自带的jdk","slug":"docs/操作系统/Linux/LinuxMint删除自带的jdk","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/linuxmint-shan-chu-zi-dai-de-jdk/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/linuxmint-shan-chu-zi-dai-de-jdk/","excerpt":"","text":"删除linux mint自带openjdk 先运行 sudo update-alternatives --display java 查看java的路径 然后运行 sudo update-alternatives --remove \"java\" \"/usr/lib/jvm/jdk/bin/java\" 查看javac的路径 sudo update-alternatives --display javac 然后运行 sudo update-alternatives --remove \"javac\" \"/usr/lib/jvm/jdk/bin/javac\" 查看javaws的路径 sudo update-alternatives --display javaws 然后运行 sudo update-alternatives --remove \"javaws\" \"/usr/lib/jvm/jdk/bin/javaws\" 然后运行 java -version javac -version which javaws 查看这些是不是都没有了 再查看安装的软件包 sudo dpkg --list | grep -i jdk 删除jdk sudo apt-get purge openjdk* 删除其他的包 sudo apt-get purge icedtea-* openjdk-* cd /usr/lib/jvm sudo rm -rf jdk 再次确认是否被删除 sudo dpkg --list | grep -i jdk 配置新的JDK gedit /etc/profile 最后面添加这些 export JAVA_HOME=/home/lb/.jdks/azul-1.8.0_345 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar source /etc/profile 使配置生效 java -version 查看JDK版本是否生效","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux汉化不完全","slug":"docs/操作系统/Linux/Linux汉化不完全","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/linux-han-hua-bu-wan-quan/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/linux-han-hua-bu-wan-quan/","excerpt":"","text":"成功安装了Linux Mint 19操作系统，但是部分界面还是英文的。由于在Linux Mint 19里去除了Ubuntu的语言支持小工具，使用Cinnamon自身的一个新开发语言配置工具来替换，但是这个工具尚未完善，明明在Linux Mint 19系统中的Firefox等软件还是英文的界面，可却显示中文已经完整安装。所以，我们需要手动来安装所需要的中文语言包，以下在Linux Mint 19系统终端中运行相关指令即可完成。 安装中文语言包$ sudo apt-get install language-pack-zh-hans language-pack-gnome-zh-hans 安装firefox语言包$ sudo apt-get install firefox-locale-zh-hans 安装libreoffice语言包$ sudo apt-get install libreoffice-l10n-zh-cn 安装thunderbird语言包$ sudo apt-get install thunderbird-locale-zh-hans","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Ubuntu设置root登录","slug":"docs/操作系统/Linux/Ubuntu设置root登录","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/ubuntu-she-zhi-root-deng-lu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/ubuntu-she-zhi-root-deng-lu/","excerpt":"","text":"sudo passwd root su root sudo gedit /etc/pam.d/gdm-autologin //注释 auth requied pam_succeed_if.so user != root quiet success sudo gedit /etc/pam.d/gdm-password //注释 auth requied pam_succeed_if.so user != root quiet success 此时重启计算机，使用root账户登陆，出现错误提示：Error found when loading/root/.profile:mesg: ttyname失败: 对设备不适当的ioctl操作，As a result the session will not be configured correctly.You shoud fix the problem as soon as feasible 运行： sudo gedit /root/.profile 在行”mesg n || true”前添加”tty -s &amp;&amp; “，变为”tty -s &amp;&amp; mesg n || true”，此时重启计算机，使用root账户登陆正常。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"性能优化知识点汇总","slug":"docs/Android/知识汇总/性能优化知识点汇总","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/zhi-shi-hui-zong/xing-neng-you-hua-zhi-shi-dian-hui-zong/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/zhi-shi-hui-zong/xing-neng-you-hua-zhi-shi-dian-hui-zong/","excerpt":"","text":"启动优化 视觉优化 启动主题优化 代码优化 冷启动耗时统计 Application 优化 闪屏页业务优化 广告页优化 优化效果 启动窗口 UI渲染优化 CPU、GPU的职责 查找Overdraw clipRect解决自定义View的OverDraw Hierarchy Viewer的使用 内存抖动现象 崩溃优化 崩溃 崩溃的收集 ANR 应用退出 崩溃处理 崩溃现场 崩溃分析 系统崩溃 内存优化 优化工具 Memory Profiler Memory Analyzer（MAT） LeakCannary 内存管理 内存区域 对象存活判断 垃圾回收算法 内存抖动 模拟内存抖动 分析并定位 内存泄露 模拟内存泄露 分析并定位 MAT分析工具 Overview Histogram Dominator_tree SQL Thread_overview Top Consumers Leak Suspects 通过ARTHook检测不合理图片 获取Bitmap占用内存 检测大图 线上内存监控 常规方案 LeakCannary定制改造 完整方案 卡顿优化 卡顿 帧率 卡顿原因 卡顿检测 使用dumpsys gfxinfo 使用systrace 使用BlockCanary 使用Choreographer 优化 存储优化 交换数据格式 SharePreferences 优化 Bitmap 解码 数据库优化 事务 SQLiteStatement 索引 其它通用优化 网络优化 网络连接对用户的影响 分析网络连接的工具 Network Monitor 网络代理工具 从哪些方面优化网络连接 接口设计 网络缓存 弱网测试&amp;优化 耗电优化 耗电监控 Android Vitals 耗电监控都监控什么 如何监控耗电 Java Hook 插桩 多线程并发优化 Thread 使用 Thread 中断 同步 Android Threading AsyncTask HandlerThread IntentService Loader ThreadPool 线程优先级 安装包优化 常用的优化方式 清理无用资源 图片资源优化 资源动态加载 lib库优化 7zip压缩资源 代码混淆 资源(res)混淆 使用微信AndResGuard Facebook的redex优化字节码 启动优化 一个应用App的启动速度能够影响用户的首次体验，启动速度较慢(感官上)的应用可能导致用户再次开启App的意图下降，或者卸载放弃该应用程序。 视觉优化 应用程序启动有三种状态，每种状态都会影响应用程序对用户可见所需的时间：冷启动，热启动和温启动。 在冷启动时，应用程序从头开始。在其他状态下，系统需要将正在运行的应用程序从后台运行到前台。我们建议您始终根据冷启动的假设进行优化。这样做也可以改善热启动和温启动的性能。 在冷启动开始时，系统有三个任务。这些任务是： 加载并启动应用程序。 启动后立即显示应用程序空白的启动窗口。 创建应用程序进程。 一旦系统创建应用程序进程，应用程序进程就会负责下一阶段。这些阶段是： 创建app对象. 启动主线程(main thread). 创建应用入口的Activity对象. 填充加载布局Views 在屏幕上执行View的绘制过程.measure -&gt; layout -&gt; draw 应用程序进程完成第一次绘制后，系统进程会交换当前显示的背景窗口，将其替换为主活动。此时，用户可以开始使用该应用程序。 因为App应用进程的创建过程是由手机的软硬件决定的，所以我们只能在这个创建过程中视觉优化。 启动主题优化 冷启动阶段 : 加载并启动应用程序。 启动后立即显示应用程序空白的启动窗口。 创建应用程序进程。所谓的主题优化，就是应用程序在冷启动的时候(1~2阶段)，设置启动窗口的主题。 因为现在 App 应用启动都会先进入一个闪屏页(LaunchActivity) 来展示应用信息。 默认情况 如果我们对App没有做处理(设置了默认主题)，并且在 Application 初始化了其它第三方的服务(假设需要加载2000ms)，那么冷启动过程就会如下图 ： 系统默认会在启动应用程序的时候启动空白窗口，直到 App 应用程序的入口 Activity 创建成功，视图绘制完毕。( 大概是onWindowFocusChanged方法回调的时候 ) 透明主题优化 为了解决启动窗口白屏问题，许多开发者使用透明主题来解决这个问题，但是治标不治本。虽然解决了上面这个问题，但是仍然有些不足。 &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;/style&gt; (无白屏,不过从点击到App仍然存在视觉延迟~) 设置闪屏图片主题 为了更顺滑无缝衔接我们的闪屏页，可以在启动 Activity 的 Theme中设置闪屏页图片，这样启动窗口的图片就会是闪屏页图片，而不是白屏。 &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/lunch&lt;/item&gt; //闪屏页图片 &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowDrawsSystemBarBackgrounds\"&gt;false&lt;/item&gt;&lt;!--显示虚拟按键，并腾出空间--&gt; &lt;/style&gt; 这样设置的话，就会在冷启动的时候，展示闪屏页的图片，等App进程初始化加载入口 Activity (也是闪屏页) 就可以无缝衔接。 其实这种方式并没有真正的加速应用进程的启动速度，而只是通过用户视觉效果带来的优化体验。 代码优化 当然上面使用设置主题的方式优化用户体验效果治标不治本，关键还在于对代码的优化。 首先统计一下应用冷启动的时间。 冷启动耗时统计 adb 命令统计 adb命令 :adb shell am start -S -W 包名/启动类的全限定名， -S 表示重启当前应用 C:\\Android\\Demo&gt;adb shell am start -S -W com.example.moneyqian.demo/com.example.moneyqian.demo.MainActivity Stopping: com.example.moneyqian.demo Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.example.moneyqian.demo/.MainActivity } Status: ok Activity: com.example.moneyqian.demo/.MainActivity ThisTime: 2247 TotalTime: 2247 WaitTime: 2278 Complete ThisTime : 最后一个 Activity 的启动耗时(例如从 LaunchActivity - &gt;MainActivity「adb命令输入的Activity」 , 只统计 MainActivity 的启动耗时) TotalTime : 启动一连串的 Activity 总耗时.(有几个Activity 就统计几个) WaitTime : 应用进程的创建过程 + TotalTime . 在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause. 在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity. 在第③个时间段内，调用有界面 Activity 的 onCreate、onResume. //ActivityRecord private void reportLaunchTimeLocked(final long curTime) { `````` final long thisTime = curTime - displayStartTime; final long totalTime = stack.mLaunchStartTime != 0 ? (curTime - stack.mLaunchStartTime) : thisTime; } 如果需要统计从点击桌面图标到 Activity 启动完毕，可以用WaitTime作为标准，但是系统的启动时间优化不了，所以优化冷启动只要在意ThisTime即可。 系统日志统计 也可以根据系统日志来统计启动耗时，在Android Studio中查找已用时间，必须在logcat视图中禁用过滤器(No Filters)。因为这个是系统的日志输出，而不是应用程序的。你也可以查看其它应用程序的启动耗时。 过滤displayed输出的启动日志. 根据上面启动时间的输出统计，就可以先记录优化前的冷启动耗时，然后再对比优化之后的启动时间。 Application 优化 Application 作为 应用程序的整个初始化配置入口，时常担负着它不应该有的负担 有很多第三方组件（包括App应用本身）都在 Application 中抢占先机，完成初始化操作。 但是在 Application 中完成繁重的初始化操作和复杂的逻辑就会影响到应用的启动性能 通常，有机会优化这些工作以实现性能改进，这些常见问题包括： 复杂繁琐的布局初始化 阻塞主线程 UI 绘制的操作，如 I/O 读写或者是网络访问. Bitmap 大图片或者 VectorDrawable加载 其它占用主线程的操作 我们可以根据这些组件的轻重缓急之分，对初始化做一下分类 ： 必要的组件一定要在主线程中立即初始化(入口 Activity 可能立即会用到) 组件一定要在主线程中初始化，但是可以延迟初始化。 组件可以在子线程中初始化。 放在子线程的组件初始化建议延迟初始化，这样就可以了解是否会对项目造成影响！ 所以对于上面的分析，可以在项目中 Application 的加载组件进行如下优化 ： 将Bugly，x5内核初始化，SP的读写，友盟等组件放到子线程中初始化。（子线程初始化不能影响到组件的使用） new Thread(new Runnable() { @Override public void run() { //设置线程的优先级，不与主线程抢资源 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //子线程初始化第三方组件 Thread.sleep(5000);//建议延迟初始化，可以发现是否影响其它功能，或者是崩溃！ } }).start(); 将需要在主线程中初始化但是可以不用立即完成的动作延迟加载（原本是想在入口 Activity 中进行此项操作，不过组件的初始化放在 Application 中统一管理为妙.） handler.postDelayed(new Runnable() { @Override public void run() { //延迟初始化组件 } }, 3000); 闪屏页业务优化 最后还剩下那些为数不多的组件在主线程初始化动作，例如埋点，点击流，数据库初始化等，不过这些消耗的时间可以在其它地方相抵。 需求背景： 应用App通常会设置一个固定的闪屏页展示时间，例如2000ms，所以我们可以根据用户手机的运行速度，对展示时间做出调整，但是总时间仍然为 2000ms。 闪屏页政展示总时间 = 组件初始化时间 + 剩余展示时间。 也就是2000ms的总时间，组件初始化了800ms，那么就再展示1200ms即可。 先了解一下 Application的启动过程虽然这个以下图片的源码并不是最新源码（5.0源码），不过不影响整体流程。（7.0,8.0方法名会有所改变）。 冷启动的过程中系统会初始化应用程序进程，创建Application等任务，这时候会展示一个启动窗口 Starting Window，如果没有优化主题的话，那么就是白屏。 分析源码后，我们可以知道 Application 初始化后会调用attachBaseContext()方法，再调用 Application 的onCreate()，再到入口 Activity的创建和执行onCreate()方法。所以我们就可以在 Application 中记录启动时间。 //Application @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); SPUtil.putLong(\"application_attach_time\", System.currentTimeMillis());//记录Application初始化时间 } 有了启动时间，我们得知道入口的 Acitivty 显示给用户的时间（View绘制完毕），在onWindowFocusChanged()的回调时机中表示可以获取用户的触摸时间和View的流程绘制完毕，所以可以在这个方法里记录显示时间。 //入口Activity @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); long appAttachTime = SPUtil.getLong(\"application_attach_time\"); long diffTime = System.currentTimeMillis() - appAttachTime;//从application到入口Acitity的时间 //所以闪屏页展示的时间为 2000ms - diffTime. } 所以就可以动态的设置应用闪屏的显示时间，尽量让每一部手机展示的时间一致，这样就不会让手机配置较低的用户感觉漫长难熬的闪屏页时间（例如初始化了2000ms，又要展示2000ms的闪屏页时间.），优化用户体验。 广告页优化 闪屏页过后就要展示金主爸爸们的广告页了。 因为项目中广告页图片有可能是大图，APng动态图片，所以需要将这些图片下载到本地文件，下载完成后再显示，这个过程往往会遇到以下两个问题 ： 广告页的下载，由于这个是一个异步过程，所以往往不知道加载到页面的合适时机。 广告页的保存，因为保存是 I/O 流操作，很有可能被用户中断，下次拿到破损的图片。 因为不清楚用户的网络环境，有些用户下载广告页可能需要一段时间，这时候又不可能无限的等候。所以针对这个问题可以开启IntentService用来下载广告页图片。 在入口 Acitivity 中开启IntentService来下载广告页。 或者是其它异步下载操作。 在广告页图片文件流完全写入后记录图片大小，或者记录一个标识。 在下次的广告页加载中可以判断是否已经下载好了广告页图片以及图片是否完整，否则删除并且再次下载图片。 另外因为在闪屏页中仍然有剩余展示时间，所以在这个时间段里如果用户已经下载好了图片并且图片完整，就可以显示广告页。否则进入主 Activity ， 因为IntentService仍然在后台继续默默的下载并保存图片~ 优化效果 优化前 ： （小米6） Displayed LaunchActivity MainActivity +2s526ms +1s583ms +2s603ms +1s533ms +2s372ms +1s556ms 优化后 ： （小米6） Displayed LaunchActivity MainActivity +995ms +1s191ms +911ms +1s101ms +903ms +1s187ms 通过手上 小米6，小米 mix2s，还有小米 2s的启动测试，发现优化后App冷启动的启动速度均提升了 60% !!! ，并且可以再看一下手机冷启动时候的内存情况 ： 优化前 ： 伴随着大量对象的创建回收，15s内系统GC 5次。内存使用波澜荡漾。 优化后 ： 趋于平稳上升状态创建对象，15s内系统GC 2次。（后期业务拓展加入新功能，所以代码量增加。）之后总内存使用平缓下降。 Other：应用使用的系统不确定如何分类的内存。 Code：应用用于处理代码和资源（如 dex 字节码、已优化或已编译的 dex 码、.so 库和字体）的内存。 Stack： 应用中的原生堆栈和 Java 堆栈使用的内存。 这通常与您的应用运行多少线程有关。 Graphics：图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。 （请注意，这是与 CPU 共享的内存，不是 GPU 专用内存。） Native：从 C 或 C++ 代码分配的对象内存。即使应用中不使用 C++，也可能会看到此处使用的一些原生内存，因为 Android 框架使用原生内存代表处理各种任务，如处理图像资源和其他图形时，即使编写的代码采用 Java 或 Kotlin 语言。 Java：从 Java 或 Kotlin 代码分配的对象内存。 Allocated：应用分配的 Java/Kotlin 对象数。 它没有计入 C 或 C++ 中分配的对象。 启动窗口 优化完代码后，分析一下启动窗口的源码。基于 android-25 (7.1.1) 启动窗口是由 WindowManagerService 统一管理的 Window 窗口，一般作为冷启动页入口 Activity 的预览窗口，启动窗口由 ActivityManagerService 来决定是否显示的，并不是每一个 Activity 的启动和跳转都会显示这个窗口。 WindowManagerService 通过窗口管理策略类 PhoneWindowManager 来创建启动窗口。 AMS启动Activity流程 在 ActivityStarter 的 startActivityUnchecked() 方法中，调用了 ActivityStack （Activity 状态管理）的 startActivityLocked() 方法。此时Activity 还在启动过程中，窗口并未显示。 启动窗口的显示过程 首先，由 Activity 状态管理者 ActivityStack 开始执行显示启动窗口的流程。 //ActivityStack final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) { `````` if (!isHomeStack() || numActivities() &gt; 0) {//HOME_STACK表示Launcher桌面所在的Stack // 1.首先当前启动栈不在Launcher的桌面栈里,并且当前系统已经有激活过Activity // We want to show the starting preview window if we are // switching to a new task, or the next activity's process is // not currently running. boolean doShow = true; if (newTask) { // 2.要将该Activity组件放在一个新的任务栈中启动 // Even though this activity is starting fresh, we still need // to reset it to make sure we apply affinities to move any // existing activities from other tasks in to it. if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) { resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; } } else if (options != null &amp;&amp; options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) { doShow = false; } if (r.mLaunchTaskBehind) { //3. 热启动，不需要启动窗口 // Don't do a starting window for mLaunchTaskBehind. More importantly make sure we // tell WindowManager that r is visible even though it is at the back of the stack. mWindowManager.setAppVisibility(r.appToken, true); ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); } else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) { `````` //4. 显示启动窗口 r.showStartingWindow(prev, showStartingIcon); } } else { // 当前启动的是桌面Launcher (开机启动) // If this is the first activity, don't do any fancy animations, // because there is nothing for it to animate on top of. `````` } } 首先判断当前要启动的 Activity 不在Launcher栈里 要启动的 Activity 是否处于新的 Task 里，并且没有转场动画 如果是热/温启动则不需要启动窗口，直接设置App的Visibility 接下来调用 ActivityRecord 的 showStartingWindow() 方法来设置启动窗口并且改变当前窗口的状态。 如果 App 的应用进程创建完成，并且入口 Activity 准备就绪，就可以根据 mStartingWindowState 来判断是否需要关闭启动窗口。 //ActivityRecord void showStartingWindow(ActivityRecord prev, boolean createIfNeeded) { final CompatibilityInfo compatInfo = service.compatibilityInfoForPackageLocked(info.applicationInfo); final boolean shown = service.mWindowManager.setAppStartingWindow( appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags, prev != null ? prev.appToken : null, createIfNeeded); if (shown) { mStartingWindowState = STARTING_WINDOW_SHOWN; } } WindowManagerService 会对当前 Activity 的token和主题进行判断。 //WindowManagerService @Override public boolean setAppStartingWindow(IBinder token, String pkg, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, IBinder transferFrom, boolean createIfNeeded) { synchronized(mWindowMap) { //1. 启动窗口也是需要token的 AppWindowToken wtoken = findAppWindowToken(token); //2. 如果已经设置过启动窗口了，不继续处理 if (wtoken.startingData != null) { return false; } // If this is a translucent window, then don't // show a starting window -- the current effect (a full-screen // opaque starting window that fades away to the real contents // when it is ready) does not work for this. if (theme != 0) { AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme, com.android.internal.R.styleable.Window, mCurrentUserId); //3. 一堆代码对主题判断，不符合要求则不显示启动窗口（如透明主题） if (windowIsTranslucent) { return false; } if (windowIsFloating || windowDisableStarting) { return false; } `````` } //4. 创建StartingData，并且通过Handler发送消息 wtoken.startingData = new StartingData(pkg, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags); Message m = mH.obtainMessage(H.ADD_STARTING, wtoken); // Note: we really want to do sendMessageAtFrontOfQueue() because we // want to process the message ASAP, before any other queued // messages. mH.sendMessageAtFrontOfQueue(m); } return true; } 启动窗口也需要和 Activity 拥有同样令牌 token ，虽然启动窗口可能是白屏，或者一张图片，但是仍然需要走绘制流程已经通过WMS显示窗口。 StartingData对象用来表示启动窗口的相关数据，描述了启动窗口的视图信息。 如果当前 Activity 是透明主题或者是浮动窗口等，那么就不需要启动窗口来过渡启动过程，所以在上面视觉优化中的设置透明主题就没有显示白色的启动窗口。 显示启动窗口也是一件心急火燎的事情，WMS的内部类H (handler) 处于主线程处理消息，所以需要将当前Message放置队列头部。 为什么需要通过 Handler 发送消息 ？ 你可以在各大服务Service中见到 Handler 的身影，并且它们可能都有一个很吊的命名 H ，因为可能调用这个服务的某个执行方法处于子线程中，所以 Handler 的职责就是将它们切换到主线程中，并且也可以统一管理调度。 //WindowManagerService --&gt; H public void handleMessage(Message msg) { switch (msg.what) { case ADD_STARTING: { final AppWindowToken wtoken = (AppWindowToken)msg.obj; final StartingData sd = wtoken.startingData; View view = null; try { final Configuration overrideConfig = wtoken != null &amp;&amp; wtoken.mTask != null ? wtoken.mTask.mOverrideConfig : null; view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme, sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo, sd.windowFlags, overrideConfig); } catch (Exception e) { Slog.w(TAG_WM, \"Exception when adding starting window\", e); } `````` } break; } 在当前的 handleMessage 方法中，会处于主线程处理消息，拿到token和StartingData启动数据后，便通过 mPolicy.addStartingWindow() 方法将启动窗口添加到WIndow上。 mPolicy 为 PhoneWindowManager ，控制着启动窗口的添加删除和修改。 在PhoneWindowManager对启动窗口进行配置，获取当前Activity设置的主题和资源信息，设置到启动窗口中。 //PhoneWindowManager @Override public View addStartingWindow(IBinder appToken, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, Configuration overrideConfig) { //可以通过SHOW_STARTING_ANIMATIONS设置不显示启动窗口 if (!SHOW_STARTING_ANIMATIONS) { return null; } WindowManager wm = null; View view = null; try { //1. 获取上下文Context和主题theme以及标题 Context context = mContext; if (theme != context.getThemeResId() || labelRes != 0) { try { context = context.createPackageContext(packageName, 0); context.setTheme(theme); } catch (PackageManager.NameNotFoundException e) { // Ignore } } //2. 创建PhoneWindow 用来显示 final PhoneWindow win = new PhoneWindow(context); win.setIsStartingWindow(true); //3. 设置当前窗口type和flag,源码注释中描述的很清晰... win.setType( WindowManager.LayoutParams.TYPE_APPLICATION_STARTING); // Force the window flags: this is a fake window, so it is not really // touchable or focusable by the user. We also add in the ALT_FOCUSABLE_IM // flag because we do know that the next window will take input // focus, so we want to get the IME window up on top of us right away. win.setFlags( windowFlags| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, windowFlags| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); `````` view = win.getDecorView(); //4. WindowManager的绘制流程 wm.addView(view, params); return view.getParent() != null ? view : null; } catch (WindowManager.BadTokenException e) { // ignore } catch (RuntimeException e) { // don't crash if something else bad happens, for example a // failure loading resources because we are loading from an app // on external storage that has been unmounted. Log.w(TAG, appToken + \" failed creating starting window\", e); } return null; } 如果theme和labelRes的值不为0，那么说明开发者指定了启动窗口的主题和标题，那么就需要从当前要启动的Activity中获取这些信息，并设置到启动窗口中。 和其它窗口一样，启动窗口也需要通过PhoneWindow来设置布局信息DecorView。所以在上面视觉优化中的设置闪屏图片主题的启动窗口显示的就是图片内容。 启动窗口和普通窗口的不同之处在于它是 fake window ，不需要触摸事件 最后通过WindowManger走View的绘制流程(measure-layout-draw)将启动窗口显示出来，最后会请求WindowManagerService为启动窗口添加一个WindowState对象，真正的将启动窗口显示给用户，并且可以对启动窗口进行管理。 UI渲染优化 理解工作中常用的UI渲染性能优化及调试方法对于我们编写高质量代码也是很有帮助的 CPU、GPU的职责 对于大多数手机的屏幕刷新频率是60hz，也就是如果在1000/60=16.67ms内没有把这一帧的任务执行完毕，就会发生丢帧的现象，丢帧是造成界面卡顿的直接原因，渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout等计算操作，GPU负责Rasterization(栅格化)操作(所谓栅格化就是将矢量图形转换为位图的过程，手机上显示是按照一个个像素来显示的，栅格化再普通一些的说法就是将一个Button,TextView等组件拆分到一个个像素上去显示)。 UI渲染优化的目的就是减轻CPU,GPU的压力，除去不必要的操作，保证每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作，使UI顺滑，流畅的展示出来。 查找Overdraw Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在重叠的UI布局中，如果不可见的UI也在做绘制的操作或者后一个控件将前一个控件遮挡，会导致某些像素区域被绘制了多次，从而增加了CPU,GPU的压力。 那么如何找出布局中Overdraw的地方呢？很简单，一般手机里面开发者选项都有调试GPU过度绘制的开关，打开即可。 以小米4手机为例，依次找到设置-&gt;更多设置-&gt;开发者选项-&gt;调试GPU过度绘制开关，打开就可以了。 打开调试GPU过度绘制开关之后，再次回到自己开发的应用发现界面怎么多了一些花花绿绿的玩意，没错，不同的颜色代表过度绘制的程度，具体如下： 蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，1x,2x,3x,4x分别表示同一像素上同一帧的时间内被绘制了多次，1x就表示一次(最理想情况)，4x表示4次(最差的情况)，我们要做的就是尽量减少3x,4x的情况出现。 下面以一个简单demo来进一步说明一下，比如我们开发好一个界面，如下： 很简单的功能，功能做完了，能不能做下优化呢？打开OverDraw功能，再次查看界面，如下： 咦？怎么大部分都是浅绿色呢？也就是说同一像素上同一帧的时间内被绘制了2次，这是怎么回事？这时我们需要看下UI布局了，看哪些地方可以优化一下。 主界面布局如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ListView android:id=\"@+id/list_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:divider=\"#F1F1F1\" android:dividerHeight=\"1dp\" android:background=\"@android:color/white\" android:scrollbars=\"vertical\"&gt; &lt;/ListView&gt; &lt;/RelativeLayout&gt; ListView每个条目布局如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"52dp\" android:background=\"@drawable/ts_account_list_selector\"&gt; &lt;TextView android:id=\"@+id/ts_item_has_login_account\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"10dp\" android:layout_marginTop=\"4dp\" android:gravity=\"center\" android:text=\"12345678999\" android:textColor=\"@android:color/black\" android:textSize=\"16sp\" /&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"20dp\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"3dp\" android:layout_marginLeft=\"10dp\" android:gravity=\"center_vertical\" &gt; &lt;ImageView android:id=\"@+id/ts_item_time_clock_image\" android:layout_width=\"12dp\" android:layout_height=\"12dp\" android:src=\"@mipmap/ts_login_clock\" /&gt; &lt;TextView android:id=\"@+id/ts_item_last_login_time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_toRightOf=\"@id/ts_item_time_clock_image\" android:text=\"上次登录\" android:textColor=\"@android:color/darker_gray\" android:textSize=\"11sp\" /&gt; &lt;TextView android:id=\"@+id/ts_item_login_time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_toRightOf=\"@id/ts_item_last_login_time\" android:text=\"59分钟前\" android:textColor=\"@android:color/darker_gray\" android:textSize=\"11sp\" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/ts_item_always_account_image_tips\" android:layout_width=\"wrap_content\" android:layout_height=\"13dp\" android:layout_alignParentRight=\"true\" android:layout_marginTop=\"2dp\" android:background=\"@mipmap/ts_always_account_bg\" android:gravity=\"center\" android:text=\"常用\" android:textColor=\"@android:color/white\" android:textSize=\"9sp\" /&gt; &lt;ImageView android:id=\"@+id/ts_item_delete_account_image\" android:layout_width=\"12dp\" android:layout_height=\"12dp\" android:layout_alignParentRight=\"true\" android:layout_marginTop=\"2dp\" android:layout_marginRight=\"13dp\" android:layout_centerVertical=\"true\" android:src=\"@mipmap/ts_close\" /&gt; &lt;/RelativeLayout&gt; 发现哪里有问题了吗？问题在于ListView多余设置了背景：android:background=\"@android:color/white\"，设置此背景对于我们这个需求根本就没有用，显示不出来并且增加GPU额外压力，去掉ListView背景之后再次观察如下： 渲染性能提升了一个档次，在实际工作中情况会复杂很多，为了实现一个效果会不得不牺牲性能，这就需要自己团队权衡了。 clipRect解决自定义View的OverDraw 平时写自定义View的时候有时会重写onDraw方法，但是Android系统是无法检测onDraw里面具体会执行什么操作，从而系统无法为我们做一些优化。这样对编程人员要求就高了，如果我们自己写的View有大量重叠的地方就造成了CPU,GPU资源的浪费，但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视，下面我们通过谷歌提供的一个小demo进一步说明。实现效果如下： 主要就是卡片重叠效果，优化前代码实现如下： DroidCard类封装要绘制的一个个卡片的信息： public class DroidCard { public int x;//左侧绘制起点 public int width; public int height; public Bitmap bitmap; public DroidCard(Resources res,int resId,int x){ this.bitmap = BitmapFactory.decodeResource(res,resId); this.x = x; this.width = this.bitmap.getWidth(); this.height = this.bitmap.getHeight(); } } DroidCardsView为真正的自定义View: public class DroidCardsView extends View { //图片与图片之间的间距 private int mCardSpacing = 150; //图片与左侧距离的记录 private int mCardLeft = 10; private List&lt;DroidCard&gt; mDroidCards = new ArrayList&lt;DroidCard&gt;(); private Paint paint = new Paint(); public DroidCardsView(Context context) { super(context); initCards(); } public DroidCardsView(Context context, AttributeSet attrs) { super(context, attrs); initCards(); } /** * 初始化卡片集合 */ protected void initCards(){ Resources res = getResources(); mDroidCards.add(new DroidCard(res,R.drawable.alex,mCardLeft)); mCardLeft+=mCardSpacing; mDroidCards.add(new DroidCard(res,R.drawable.claire,mCardLeft)); mCardLeft+=mCardSpacing; mDroidCards.add(new DroidCard(res,R.drawable.kathryn,mCardLeft)); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); for (DroidCard c : mDroidCards){ drawDroidCard(canvas, c); } invalidate(); } /** * 绘制DroidCard */ private void drawDroidCard(Canvas canvas, DroidCard c) { canvas.drawBitmap(c.bitmap,c.x,0f,paint); } } 代码不是重点，不过也不难，自行查看就可以了。我们打开overdraw开关，效果如下： 淡红色区域明显被绘制了三次（三张图片重合的地方），其实下面的图片完全没必要完全绘制，只需要绘制三分之一即可，接下来我们就需要对其优化，保证最下面两张图片只需要回执其三分之一最上面图片完全绘制出来就可。 DroidCardsView代码优化为： public class DroidCardsView extends View { //图片与图片之间的间距 private int mCardSpacing = 150; //图片与左侧距离的记录 private int mCardLeft = 10; private List&lt;DroidCard&gt; mDroidCards = new ArrayList&lt;DroidCard&gt;(); private Paint paint = new Paint(); public DroidCardsView(Context context) { super(context); initCards(); } public DroidCardsView(Context context, AttributeSet attrs) { super(context, attrs); initCards(); } /** * 初始化卡片集合 */ protected void initCards(){ Resources res = getResources(); mDroidCards.add(new DroidCard(res, R.drawable.alex,mCardLeft)); mCardLeft+=mCardSpacing; mDroidCards.add(new DroidCard(res, R.drawable.claire,mCardLeft)); mCardLeft+=mCardSpacing; mDroidCards.add(new DroidCard(res, R.drawable.kathryn,mCardLeft)); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); for (int i = 0; i &lt; mDroidCards.size() - 1; i++){ drawDroidCard(canvas, mDroidCards,i); } drawLastDroidCard(canvas,mDroidCards.get(mDroidCards.size()-1)); invalidate(); } /** * 绘制最后一个DroidCard * @param canvas * @param c */ private void drawLastDroidCard(Canvas canvas,DroidCard c) { canvas.drawBitmap(c.bitmap,c.x,0f,paint); } /** * 绘制DroidCard * @param canvas * @param mDroidCards * @param i */ private void drawDroidCard(Canvas canvas,List&lt;DroidCard&gt; mDroidCards,int i) { DroidCard c = mDroidCards.get(i); canvas.save(); canvas.clipRect((float)c.x,0f,(float)(mDroidCards.get(i+1).x),(float)c.height); canvas.drawBitmap(c.bitmap,c.x,0f,paint); canvas.restore(); } } 主要就是使用Canvas的clipRect方法，绘制之前裁剪出一个区域，这样绘制的时候只在这区域内绘制，超出部分不会绘制出来。 重新执行程序，效果如下： 处理后性能就提升了一丝丝，此外我们还可以使用canvas.quickReject方法来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。 Hierarchy Viewer的使用 Hierarchy Viewer可以很直观的呈现布局的层次关系。我们可以通过红，黄，绿三种不同的颜色来区分布局的Measure，Layout，Executive的相对性能表现如何 提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。如果我们写的布局层级比较深会严重增加CPU的负担，造成性能的严重卡顿，关于Hierarchy Viewer的使用举例这里就不列举了。 内存抖动现象 在我们优化过view的树形结构和overdraw之后，可能还是感觉自己的app有卡顿和丢帧，或者滑动慢：卡顿还是存在。这时我们就要查看一下是否存在内存抖动情况了 Android有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。在同一帧里面创建过多的对象是件需要特别引起注意的事情，在同一帧里创建大量对象可能引起GC的不停操作，执行GC操作的时候，所有线程的任何操作都会需要暂停，直到GC操作完成。大量不停的GC操作则会显著占用帧间隔时间。 如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了，严重时可能引起卡顿： 导致GC频繁操作有两个主要原因： 内存抖动，所谓内存抖动就是短时间产生大量对象又在短时间内马上释放。 短时间产生大量对象超出阈值，内存不够，同样会触发GC操作。 观察内存抖动我们可以借助android studio中的工具，3.0以前可以使用android monitor,3.0以后被替换为android Profiler。 如果工具里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动，如图： 为了避免发生内存抖动，我们需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。 崩溃优化 崩溃 崩溃率是衡量一个应用质量高低的基本指标，那么，该怎样客观地衡量崩溃这个指标，以及又该如何看待和崩溃相关的稳定性。 Android 的两种崩溃： Java 崩溃 Native 崩溃 简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。那 Native 崩溃一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 Abort，这些都会产生相应的 Signal 信号，导致程序异常退出。 崩溃的收集 “崩溃”就是程序出现异常，而一个产品的崩溃率，跟我们如何捕获、处理这些异常有比较大的关系。对于很多中小型公司来说，可以选择一些第三方的服务。目前各种平台也是百花齐放，包括阿里的友盟、腾讯的Bugly、网易云捕、Google 的 Firebase 等等。要懂得借力！ ANR 崩溃率是不是就能完全等价于应用的稳定性呢？答案是肯定不行。处理了崩溃，我们还会经常遇到 ANR（Application Not Responding，程序没有响应）这个问题。 出现 ANR 的时候，系统还会弹出对话框打断用户的操作，这是用户非常不能忍受的。 ANR处理方法：使用 FileObserver 监听 /data/anr/traces.txt 的变化。非常不幸的是，很多高版本的 ROM，已经没有读取这个文件的权限了。这个时候你可能只能思考其他路径，海外可以使用 Google Play 服务，而国内微信利用Hardcoder框架（HC 框架是一套独立于安卓系统实现的通信框架，它让 App 和厂商 ROM 能够实时“对话”了，目标就是充分调度系统资源来提升 App 的运行速度和画质，切实提高大家的手机使用体验）向厂商获取了更大的权限。也可以将手机 ROOT 掉，然后取得 traces.txt 文件。 应用退出 除了常见的崩溃，还有一些会导致应用异常退出的情况，例如： 主动自杀。Process.killProcess()、exit() 等 崩溃。出现了 Java 或 Native 崩溃 系统重启。系统出现异常、断电、用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记录的值更小 被系统杀死。被 low memory killer 杀掉、从系统的任务管理器中划掉等 ANR 我们可以在应用启动的时候设定一个标志，在主动自杀或崩溃后更新标志，这样下次启动时通过检测这个标志就能确认运行期间是否发生过异常退出。对应上面的五种退出场景，我们排除掉主动自杀和崩溃（崩溃会单独的统计）这两种场景，希望可以监控到剩下三种的异常退出，理论上这个异常捕获机制是可以达到 100% 覆盖的。 通过这个异常退出的检测，可以反映如 ANR、low memory killer、系统强杀、死机、断电等其他无法正常捕获到的问题。当然异常率会存在一些误报，比如用户从系统的任务管理器中划掉应用。对于线上的大数据来说，还是可以帮助我们发现代码中的一些隐藏问题。 根据应用的前后台状态，我们可以把异常退出分为前台异常退出和后台异常退出。“被系统杀死” 是后台异常退出的主要原因，当然我们会更关注前台的异常退出的情况，这会跟 ANR、OOM 等异常情况有更大的关联。 崩溃处理 我们每天工作也会遇到各种各样的疑难问题，“崩溃”就是其中比较常见的一种问题。解决问题跟破案一样需要经验，我们分析的问题越多越熟练，定位问题就会越快越准。 当然这里也有很多套路，比如： 对于 “案发现场” 我们应该留意哪些信息？ 怎样找到更多的 “证人” 和 “线索” ？ “侦查案件” 的一般流程是什么？ 对不同类型的 “案件” 分别应该使用什么样的调查方式？ 要相信 “真相永远只有一个”，崩溃也并不可怕。 崩溃现场 崩溃现场是我们的“第一案发现场”，它保留着很多有价值的线索。现在可以挖掘到的信息越多，下一步分析的方向就越清晰，而不是去靠盲目猜测。 崩溃信息 从崩溃的基本信息，我们可以对崩溃有初步的判断。进程名、线程名。崩溃的进程是前台进程还是后台进程，崩溃是不是发生在 UI 线程。 崩溃堆栈和类型。崩溃是属于 Java 崩溃、Native 崩溃，还是 ANR，对于不同类型的崩溃关注的点也不太一样。特别需要看崩溃堆栈的栈顶，看具体崩溃在系统的代码，还是 APP 代码里面。 关键字：FATAL FATAL EXCEPTION: main Process: com.cchip.csmart, PID: 27456 java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.TextView.setText(int)' on a null object reference at com.cchip.alicsmart.activity.SplashActivity$1.handleMessage(SplashActivity.java:67) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:179) at android.app.ActivityThread.main(ActivityThread.java:5672) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:674) 系统信息 系统的信息有时候会带有一些关键的线索，对我们解决问题有非常大的帮助。 Logcat。这里包括应用、系统的运行日志。由于系统权限问题，获取到的 Logcat 可能只包含与当前 APP 相关的。其中系统的 event logcat 会记录 APP 运行的一些基本情况，记录在文件 /system/etc/event-log-tags 中。 //system logcat: 10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ... //event logcat: 10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期 10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足 10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty 10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因 10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因 机型、系统、厂商、CPU、ABI、Linux 版本等。通过采集多达几十个维度，这对寻找共性问题会很有帮助。 内存信息 OOM、ANR、虚拟内存耗尽等，很多崩溃都跟内存有直接关系。如果把用户的手机内存分为“2GB 以下”和“2GB 以上”两个区，就会发现“2GB 以下”用户的崩溃率是“2GB 以上”用户的几倍。 系统剩余内存。关于系统内存状态，可以直接读取文件 /proc/meminfo。当系统可用内存很小（低于 MemTotal 的 10%）时，OOM、大量 GC、系统频繁自杀拉起等问题都非常容易出现。 应用使用内存。包括 Java 内存、RSS（Resident Set Size）、PSS（Proportional Set Size），我们可以得出应用本身内存的占用大小和分布。PSS 和 RSS 通过 /proc/self/smap 计算，可以进一步得到例如 apk、dex、so 等更加详细的分类统计。 虚拟内存。虚拟内存可以通过 /proc/self/status 得到，通过 /proc/self/maps 文件可以得到具体的分布情况。有时候我们一般不太重视虚拟内存，但是很多类似 OOM、tgkill 等问题都是虚拟内存不足导致的。 Name: com.xmamiga.name // 进程名 FDSize: 800 // 当前进程申请的文件句柄个数 VmPeak: 3004628 kB // 当前进程的虚拟内存峰值大小 VmSize: 2997032 kB // 当前进程的虚拟内存大小 Threads: 600 // 当前进程包含的线程个数 一般来说，对于 32 位进程，如果是 32 位的 CPU，虚拟内存达到 3GB 就可能会引起内存申请失败的问题。如果是 64 位的 CPU，虚拟内存一般在 3～4GB 之间。当然如果我们支持 64 位进程，虚拟内存就不会成为问题。Google Play 要求 2019 年 8 月一定要支持 64 位，在国内虽然支持 64 位的设备已经在 90% 以上了，但是商店都不支持区分 CPU 架构类型发布，普及起来需要更长的时间。 资源信息 有的时候会发现应用堆内存和设备内存都非常充足，还是会出现内存分配失败的情况，这跟资源泄漏可能有比较大的关系。 文件句柄 fd。文件句柄的限制可以通过 /proc/self/limits 获得，一般单个进程允许打开的最大文件句柄个数为 1024。但是如果文件句柄超过 800 个就比较危险，需要将所有的 fd 以及对应的文件名输出到日志中，进一步排查是否出现了有文件或者线程的泄漏。 opened files count 812: 0 -&gt; /dev/null 1 -&gt; /dev/log/main4 2 -&gt; /dev/binder 3 -&gt; /data/data/com.xmamiga.sample/files/test.conf ... 线程数。当前线程数大小可以通过上面的 status 文件得到，一个线程可能就占 2MB 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据我的经验来说，如果线程数超过 400 个就比较危险。需要将所有的线程 id 以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。 threads count 412: 1820 com.xmamiga.crashsdk 1844 ReferenceQueueD 1869 FinalizerDaemon ... JNI。使用 JNI 时，如果不注意很容易出现引用失效、引用爆表等一些崩溃。 应用信息 除了系统，其实我们的应用更懂自己，可以留下很多相关的信息。崩溃场景。崩溃发生在哪个 Activity 或 Fragment，发生在哪个业务中; 关键操作路径，不同于开发过程详细的打点日志，我们可以记录关键的用户操作路径，这对我们复现崩溃会有比较大的帮助。其他自定义信息。不同的应用关心的重点可能不太一样。 崩溃分析 有了这么多现场信息之后，就可以开始真正的“破案”之旅了。绝大部分的 “案件” 只要肯花功夫，最后都能真相大白。不要畏惧问题，经过耐心和细心地分析，总能敏锐地发现一些异常或关键点，并且还要敢于怀疑和验证。 第一步：确定重点 确认和分析重点，关键在于终过日志中找到重要的信息，对问题有一个大致判断。一般来说，我建议在确定重点这一步可以关注以下几点。 确认严重程度。解决崩溃也要看性价比，我们优先解决 Top 崩溃或者对业务有重大影响，例如主要功能的崩溃。不要花几天去解决了一个边角的崩溃，有可能下个版本就把功能删除了。 崩溃基本信息。确定崩溃的类型以及异常描述，对崩溃有大致的判断。 一般来说，大部分的简单崩溃经过这一步已经可以得到结论。 Java 崩溃。Java 崩溃类型比较明显，比如 NullPointerException 是空指针，OutOfMemoryError 是资源不足，这个时候需要去进一步查看日志中的 “内存信息”和“资源信息”。 Native 崩溃。需要观察 signal、code、fault addr 等内容，以及崩溃时 Java 的堆栈。关于各 signal 含义的介绍，你可以查看崩溃信号介绍。比较常见的是有 SIGSEGV 和 SIGABRT，前者一般是由于空指针、非法指针造成，后者主要因为 ANR 和调用 abort() 退出所导致。 ANR。先看看主线程的堆栈，是否是因为锁等待导致。接着看看 ANR 日志中 iowait、CPU、GC、system server 等信息，进一步确定是 I/O 问题，或是 CPU 竞争问题，还是由于大量 GC 导致卡死。 第二步：查找共性 如果使用了上面的方法还是不能有效定位问题，我们可以尝试查找这类崩溃有没有什么共性。找到了共性，也就可以进一步找到差异，离解决问题也就更进一步。 机型、系统、ROM、厂商、ABI，这些采集到的系统信息都可以作为维度聚合，共性问题例如是不是只出现在 x86 的手机，是不是只有三星这款机型，是不是只在 Android 8.0 的系统上。应用信息也可以作为维度来聚合，比如正在打开的链接、正在播放的视频、国家、地区等。 找到了共性，可以对你下一步复现问题有更明确的指引。 第三步：尝试复现 如果我们已经大概知道了崩溃的原因，为了进一步确认更多信息，就需要尝试复现崩溃。如果我们对崩溃完全没有头绪，也希望通过用户操作路径来尝试重现，然后再去分析崩溃原因。 “只要能本地复现，我就能解”，相信这是很多开发跟测试说过的话。有这样的底气主要是因为在稳定的复现路径上面，我们可以采用增加日志或使用 Debugger、GDB 等各种各样的手段或工具做进一步分析。 我们可能会遇到了各种各样的奇葩问题。比如某个厂商改了底层实现、新的 Android 系统实现有所更改，都需要去 Google、翻源码，有时候还需要去抠厂商的 ROM 或手动刷 ROM。很多疑难问题需要我们耐得住寂寞，反复猜测、反复发灰度、反复验证。–但这种问题还是要看问题的严重程序，不可捡了芝麻丢了西瓜。 系统崩溃 系统崩溃常常令我们感到非常无助，它可能是某个 Android 版本的 Bug，也可能是某个厂商修改 ROM 导致。这种情况下的崩溃堆栈可能完全没有我们自己的代码，很难直接定位问题。能做的有： 查找可能的原因。通过上面的共性归类，我们先看看是某个系统版本的问题，还是某个厂商特定 ROM 的问题。虽然崩溃日志可能没有我们自己的代码，但通过操作路径和日志，可以找到一些怀疑的点。 尝试规避。查看可疑的代码调用，是否使用了不恰当的 API，是否可以更换其他的实现方式规避。 Hook 解决。这里分为 Java Hook 和 Native Hook。它可能只出现在 Android 7.0 的系统中，参考 Android 8.0 的做法，直接 catch 住这个异常。 如果做到了上面说的这些，以上大部分的崩溃应该都能解决或者规避，大部分的系统崩溃也是如此。当然总有一些疑难问题需要依赖到用户的真实环境，这些需要具备类似动态跟踪和调试的能力。 崩溃攻防是一个长期的过程，我们尽可能地提前预防崩溃的发生，将它消灭在萌芽阶段。作为技术人员，我们不应该盲目追求崩溃率这一个数字，应该以用户体验为先，如果强行去掩盖一些问题往往更加适得其反。我们不应该随意使用 try catch 去隐藏真正的问题，要从源头入手，了解崩溃的本质原因，保证后面的运行流程。在解决崩溃的过程，也要做到由点到面，不能只针对这个崩溃去解决，而应该要考虑这一类崩溃怎么解决和预防。 内存优化 在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面自动分配和释放内存，因此不需要像使用C/C++一样在代码中分配和释放某一块内存。Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个Generational Heap Memory模型，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如内存泄漏、内存抖动、短时间内分配大量的内存对象等等。 优化工具 Memory Profiler Memory profiler是Android Studio自带的一个内存检测工具，通过实时图表的方式展示内存信息，具有可以识别内存泄露，内存抖动等现象，并可以将捕获到的内存信息进行堆转储、强制GC以及跟踪内存分配的能力。 Android Studio打开Profiler工具 观察Memory曲线，比较平缓即为内存分配正常，如果出现大的波动有可能发生了内存泄露。 GC：可手动触发GC Dump：Dump出当前Java Heap信息 Record：记录一段时间内的内存信息 点击Dump后 可查看当前内存分配对象 Allocations：分配对象个数 Native Size：Native内存大小 Shallow Size：对象本身占用内存的大小，不包含其引用的对象 Retained Size: 对象的Retained Size = 对象本身的Shallow Size + 对象能直接或间接访问到的对象的Shallow Size，也就是说 Retained Size 就是该对象被 Gc 之后所能回收内存的总和 点击Bitmap Preview可以进行预览图片，对查看图片占用内存情况比较有帮助 点击Record后 可以记录一段时间内内存分配情况，可查看各对象分配大小及调用栈、对象生成位置 Memory Analyzer（MAT） 比Memory Profiler更强大的Java Heap分析工具，可以准确查找内存泄露以及内存占用情况，还可以生成整体报告，用来分析问题等。 MAT一般用来线下结合Memory Profiler分析问题使用，Memory Profiler可以直观看出内存抖动，然后生成的hdprof文件，通过MAT深入分析及定位内存泄露问题。 LeakCannary Leak Cannary是一个能自动监测内存泄露的线下监测工具。 内存管理 内存区域 Java内存划分为方法区、堆、程序计数器、本地方法栈、虚拟机栈五个区域； 线程维度分为线程共享区和线程隔离区，方法区和堆是线程共享的，程序计数器、本地方法栈、虚拟机栈是线程隔离的，如下图 方法区 线程共享区域，用于存储类信息、静态变量、常量、即时编译器编译出来的代码数据 无法满足内存分配需求时会发生OOM 堆 线程共享区域，是JAVA虚拟机管理的内存中最大的一块，在虚拟机启动时创建 存放对象实例，几乎所有的对象实例都在堆上分配，GC管理的主要区域 虚拟机栈 线程私有区域，每个java方法在执行的时候会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从执行开始到结束过程就是栈帧在虚拟机栈中入栈出栈过程 局部变量表存放编译期可知的基本数据类型、对象引用、returnAddress类型。所需的内存空间会在编译期间完成分配，进入一个方法时在帧中局部变量表的空间是完全确定的，不需要运行时改变 若线程申请的栈深度大于虚拟机允许的最大深度，会抛出SatckOverFlowError错误 虚拟机动态扩展时，若无法申请到足够内存，会抛出OutOfMemoryError错误 本地方法栈 为虚拟机中Native方法服务，对本地方法栈中使用的语言、数据结构、使用方式没有强制规定，虚拟机可自有实现 占用的内存区大小是不固定的，可根据需要动态扩展 程序计数器 一块较小的内存空间，线程私有，存储当前线程执行的字节码行号指示器 字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、循环、跳转等 每个线程都有一个独立的程序计数器 唯一一个在java虚拟机中不会OOM的区域 对象存活判断 引用计数法 给对象添加引用计数器，每当一个地方引用时，计数器加1，引用失效时计数器减1；当引用计数器为0时即为对象不可用 实现简单，效率高，但是无法解决相互引用问题，主流虚拟机一般不使用此方法判断对象是否存活 可达性分析法 从一些称为”GC Roots”的对象作为起点，向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时即为对象不可用，可被回收的 可被称为GC Roots的对象：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象 GC Root有以下几种： Class-由系统ClassLoader加载的对象 Thread-活着的线程 Stack Local-Java方法的local变量或参数 JNI Local – JNI方法的local变量或参数 JNI Global – 全局JNI引用 Monitor Used – 用于同步的监控对象 垃圾回收算法 标记清除算法 标记清除算法有两个阶段，首先标记出需要回收的对象，在标记完成后统一回收所有标记的对象； 缺点： 效率问题：标记和清除两个过程效率都不高 空间问题：标记清除之后会导致很多不连续的内存碎片，会导致需要分配大对象时无法找到足够的连续空间而不得不触发GC的问题 复制算法 将可用内存按空间分为大小相同的两小块，每次只使用其中的一块，等这块内存使用完了将还存活的对象复制到另一块内存上，然后将这块内存区域对象整体清除掉。每次对整个半区进行内存回收，不会导致碎片问题，实现简单高效。 缺点： 需要将内存缩小为原来的一半，空间代价太高 标记整理算法 标记整理算法标记过程和标记清除算法一样，但清除过程并不是对可回收对象直接清理，而是将所有存活对象像一端移动，然后集中清理到端边界以外的内存。 分代收集算法 当代虚拟机垃圾回收算法都采用分代收集算法来收集，根据对象存活周期不同将内存划分为新生代和老年代，再根据每个年代的特点采用最合适的算法。 新生代存活对象较少，每次垃圾回收都有大量对象死去，一般采用复制算法，只需要付出复制少量存活对象的成本就可以实现垃圾回收； 老年代存活对象较多，没有额外空间进行分配担保，就必须采用标记清除算法和标记整理算法进行回收； 内存抖动 内存频繁分配和回收导致内存不稳定 频繁GC，内存曲线呈现锯齿状，会导致卡顿 频繁的创建对象会导致内存不足及碎片 不连续的内存碎片无法被释放，导致OOM 模拟内存抖动 执行此段代码 private static Handler mShakeHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); // 频繁创建对象，模拟内存抖动 for(int index = 0;index &lt;= 100;index ++) { String strArray[] = new String[100000]; } mShakeHandler.sendEmptyMessageDelayed(0,30); } }; 分析并定位 利用Memory Profiler工具查看内存信息 发现内存曲线由原来的平稳曲线变成锯齿状 点击record记录内存信息，查找发生内存抖动位置，发现String对象ShallowSize非常异常，可直接通过Jump to Source定位到代码位置 内存泄露 定义：内存中存在已经没有用确无法回收的对象 现象：会导致内存抖动，可用内存减少，进而导致GC频繁、卡顿、OOM 模拟内存泄露 模拟内存泄露代码，反复进入退出该Activity /** * 模拟内存泄露的Activity */ public class MemoryLeakActivity extends AppCompatActivity implements CallBack{ @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_memoryleak); ImageView imageView = findViewById(R.id.iv_memoryleak); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.splash); imageView.setImageBitmap(bitmap); // 添加静态类引用 CallBackManager.addCallBack(this); } @Override protected void onDestroy() { super.onDestroy(); // CallBackManager.removeCallBack(this); } @Override public void dpOperate() { // do sth } 分析并定位 通过Memory Profiler工具查看内存曲线，发现内存在不断的上升 如果想分析定位具体发生内存泄露位置需要借助MAT工具 首先生成hprof文件 点击dump将当前内存信息转成hprof文件，需要对生成的文件转换成MAT可读取文件 执行一下转换命令（Android/sdk/platorm-tools路径下） hprof-conv 刚刚生成的hprof文件 memory-mat.hprof 使用mat打开刚刚转换的hprof文件 点击Historygram，搜索MemoryLeakActivity 可以看到有8个MemoryLeakActivity未释放 查看所有引用对象 查看到GC Roots的引用链 可以看到GC Roots是CallBackManager 解决问题，当Activity销毁时将当前引用移除 @Override protected void onDestroy() { super.onDestroy(); CallBackManager.removeCallBack(this); } MAT分析工具 Overview 当前内存整体信息 Histogram 列举对象所有的实例及实例所占大小，可按package排序 可以查看应用包名下Activity存在实例个数，可以查看是否存在内存泄露，这里发现内存中有8个Activity实例未释放 查看未被释放的Activity的引用链 Dominator_tree 当前所有实例的支配树，和Histogram区别时Histogram是类维度，dominator_tree是实例维度，可以查看所有实例的所占百分比和引用链 SQL 通过sql语句查询相关类信息 Thread_overview 查看当前所有线程信息 Top Consumers 通过图形方式展示占用内存较高的对象，对降低内存栈优化可用内存比较有帮助 Leak Suspects 内存泄露分析页面 直接定位到内存泄露位置 通过ARTHook检测不合理图片 获取Bitmap占用内存 通过getByteCount方法，但是需要在运行时获取 width * height * 一个像素所占内存 * 图片所在资源目录压缩比 检测大图 当图片控件load图片大小超过控件自身大小时会造成内存浪费，所以检测出不合理图片对内存优化是很重要的。 ARTHook方式检测不合理图片 通过ARTHook方法可以优雅的获取不合理图片，侵入性低，但是因为兼容性问题一般在线下使用。 引入epic开源库 implementation 'me.weishu:epic:0.3.6' 实现Hook方法 public class CheckBitmapHook extends XC_MethodHook { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); ImageView imageView = (ImageView)param.thisObject; checkBitmap(imageView,imageView.getDrawable()); } private static void checkBitmap(Object o,Drawable drawable) { if(drawable instanceof BitmapDrawable &amp;&amp; o instanceof View) { final Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap(); if(bitmap != null) { final View view = (View)o; int width = view.getWidth(); int height = view.getHeight(); if(width &gt; 0 &amp;&amp; height &gt; 0) { if(bitmap.getWidth() &gt; (width &lt;&lt;1) &amp;&amp; bitmap.getHeight() &gt; (height &lt;&lt; 1)) { warn(bitmap.getWidth(),bitmap.getHeight(),width,height, new RuntimeException(\"Bitmap size is too large\")); } } else { final Throwable stacktrace = new RuntimeException(); view.getViewTreeObserver().addOnPreDrawListener( new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { int w = view.getWidth(); int h = view.getHeight(); if(w &gt; 0 &amp;&amp; h &gt; 0) { if (bitmap.getWidth() &gt;= (w &lt;&lt; 1) &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; 1)) { warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stacktrace); } view.getViewTreeObserver().removeOnPreDrawListener(this); } return true; } }); } } } } private static void warn(int bitmapWidth, int bitmapHeight, int viewWidth, int viewHeight, Throwable t) { String warnInfo = new StringBuilder(\"Bitmap size too large: \") .append(\"\\n real size: (\").append(bitmapWidth).append(',').append(bitmapHeight).append(')') .append(\"\\n desired size: (\").append(viewWidth).append(',').append(viewHeight).append(')') .append(\"\\n call stack trace: \\n\").append(Log.getStackTraceString(t)).append('\\n') .toString(); LogUtils.i(warnInfo); Application初始化时注入Hook DexposedBridge.hookAllConstructors(ImageView.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); DexposedBridge.findAndHookMethod(ImageView.class,\"setImageBitmap\", Bitmap.class, new CheckBitmapHook()); } }); 线上内存监控 常规方案 常规方案一 在特定场景中获取当前占用内存大小，如果当前内存大小超过系统最大内存80%，对当前内存进行一次Dump（Debug.dumpHprofData()），选择合适时间将hprof文件进行上传，然后通过MAT工具手动分析该文件。 缺点： Dump文件比较大，和用户使用时间、对象树正相关 文件较大导致上传失败率较高，分析困难 常规方案二 将LeakCannary带到线上，添加预设怀疑点，对怀疑点进行内存泄露监控，发现内存泄露回传到server。 缺点： 通用性较低，需要预设怀疑点，对没有预设怀疑点的地方监控不到 LeakCanary分析比较耗时、耗内存，有可能会发生OOM LeakCannary定制改造 将需要预设怀疑点改为自动寻找怀疑点，自动将前内存中所占内存较大的对象类中设置怀疑点。 LeakCanary分析泄露链路比较慢，改造为只分析Retain size大的对象。 分析过程会OOM，是因为LeakCannary分析时会将分析对象全部加载到内存当中，我们可以记录下分析对象的个数和占用大小，对分析对象进行裁剪，不全部加载到内存当中。 完整方案 监控常规指标：待机内存、重点模块占用内存、OOM率 监控APP一个生命周期内和重点模块界面的生命周期内的GC次数、GC时间等 将定制的LeakCanary带到线上，自动化分析线上的内存泄露 卡顿优化 卡顿 在应用开发中如果留意到log的话有时候可能会发下下面的log信息： I/Choreographer(1200): Skipped 60 frames! The application may be doing too much work on its main thread. 在大部分Android平台的设备上，Android系统是16ms刷新一次，也就是一秒钟60帧。要达到这种刷新速度就要求在ui线程中处理的任务时间必须要小于16ms，如果ui线程中处理时间长，就会导致跳过帧的渲染，也就是导致界面看起来不流畅，卡顿。如果用户点击事件5s中没反应就会导致ANR。 帧率 即 Frame Rate，单位 fps，是指 gpu 生成帧的速率，60fps，Android中更帧率相关的类是SurfaceFlinger。 SurfaceFlingersurfaceflinger作用是接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。比如打开应用，常见的有三层显示，顶部的statusbar底部或者侧面的导航栏以及应用的界面，每个层是单独更新和渲染，这些界面都是有surfaceflinger合成一个刷新到硬件显示。在显示过程中使用到了bufferqueue，surfaceflinger作为consumer方，比如windowmanager管理的surface作为生产方产生页面，交由surfaceflinger进行合成。 VSync Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，VSync是Vertical Synchronization(垂直同步)的缩写，是一种在PC上很早就广泛使用的技术，可以简单的把它认为是一种定时中断。而在Android 4.1(JB)中已经开始引入VSync机制，用来同步渲染，让UI和SurfaceFlinger可以按硬件产生的VSync节奏进行工作。 安卓系统中有 2 种 VSync 信号：1、屏幕产生的硬件 VSync： 硬件 VSync 是一个脉冲信号，起到开关或触发某种操作的作用。2、由 SurfaceFlinger 将其转成的软件 Vsync 信号：经由 Binder 传递给 Choreographer。 除了Vsync的机制，Android还使用了多级缓冲的手段以优化UI流程度，例如双缓冲(A+B)，在显示buffer A的数据时，CPU/GPU就开始在buffer B中准备下一帧数据：但是不能保证每一帧CPU、GPU都运行状态良好，可能由于资源抢占等性能问题导致某一帧GPU掉链子，vsync信号到来时buffer B的数据还没准备好，而此时Display又在显示buffer A的数据，导致后面CPU/GPU没有新的buffer着手准备数据，导致卡顿（jank）。 卡顿原因 从系统层面上看主要以下几个方面的原因会导致卡顿：1. SurfaceFlinger 主线程耗时 SurfaceFlinger 负责 Surface 的合成 , 一旦 SurfaceFlinger 主线程调用超时 , 就会产生掉帧 .SurfaceFlinger 主线程耗时会也会导致 hwc service 和 crtc 不能及时完成, 也会阻塞应用的 binder 调用, 如 dequeueBuffer \\ queueBuffer 等. 2. 后台活动进程太多导致系统繁忙 后台进程活动太多,会导致系统非常繁忙, cpu \\ io \\ memory 等资源都会被占用, 这时候很容易出现卡顿问题 , 这也是系统这边经常会碰到的问题。dumpsys cpuinfo 可以查看一段时间内 cpu 的使用情况：3.主线程调度不到 , 处于 Runnable 状态 当线程为 Runnable 状态的时候 , 调度器如果迟迟不能对齐进行调度 , 那么就会产生长时间的 Runnable 线程状态 , 导致错过 Vsync 而产生流畅性问题。 4、System 锁 system_server 的 AMS 锁和 WMS 锁 , 在系统异常的情况下 , 会变得非常严重 , 如下图所示 , 许多系统的关键任务都被阻塞 , 等待锁的释放 , 这时候如果有 App 发来的 Binder 请求带锁 , 那么也会进入等待状态 , 这时候 App 就会产生性能问题 ; 如果此时做 Window 动画 , 那么 system_server 的这些锁也会导致窗口动画卡顿5、Layer过多导致 SurfaceFlinger Layer Compute 耗时 Android P 修改了 Layer 的计算方法 , 把这部分放到了 SurfaceFlinger 主线程去执行, 如果后台 Layer 过多, 就会导致 SurfaceFlinger 在执行 rebuildLayerStacks 的时候耗时 , 导致 SurfaceFlinger 主线程执行时间过长。从应用层来看以下会导致卡顿： 1、主线程执行时间长主线程执行 Input \\ Animation \\ Measure \\ Layout \\ Draw \\ decodeBitmap 等操作超时都会导致卡顿 。 1、Measure \\ Layout 耗时\\超时 2、draw耗时 3、Animation回调耗时 4、View 初始化耗时 5、List Item 初始化耗时 6、主线程操作数据库 2、主线程 Binder 耗时 Activity resume 的时候, 与 AMS 通信要持有 AMS 锁, 这时候如果碰到后台比较繁忙的时候, 等锁操作就会比较耗时, 导致部分场景因为这个卡顿, 比如多任务手势操作。 3、WebView 性能不足 应用里面涉及到 WebView 的时候, 如果页面比较复杂, WebView 的性能就会比较差, 从而造成卡顿 4、帧率与刷新率不匹配 如果屏幕帧率和系统的 fps 不相符 , 那么有可能会导致画面不是那么顺畅. 比如使用 90 Hz 的屏幕搭配 60 fps 的动画。 卡顿检测 卡顿检测可以使用以下多种方法同时进行：1、使用dumpsys gfxinfo2、使用Systrace获取相关信息3、使用LayoutInspect 检测布局层次4、使用BlockCanary5、利用Choreographer。6、使用严格模式（StrictMode ）。 使用dumpsys gfxinfo 在开发过程中发现有卡顿发生时可以使用下面的命令来获取卡顿相关的信息： adb shell dumpsys gfxinfo [PACKAGE_NAME] 输入这个命令后可能会打印下面的信息： Applications Graphics Acceleration Info: Uptime: 102809662 Realtime: 196891968 ** Graphics info for pid 31148 [com.android.settings] ** Stats since: 524615985046231ns Total frames rendered: 8325 Janky frames: 729 (8.76%) 90th percentile: 13ms 95th percentile: 20ms 99th percentile: 73ms Number Missed Vsync: 294 Number High input latency: 47 Number Slow UI thread: 502 Number Slow bitmap uploads: 44 Number Slow issue draw commands: 135 上面参数说明： Graphics info for pid 31148 [com.android.settings]: 表明当前dump的为设置界面的帧信息，pid为31148Total frames rendered: 8325 本次dump搜集了8325帧的信息 Janky frames :729 (8.76%)出现卡顿的帧数有729帧，占8.76% Number Missed Vsync: 294 垂直同步失败的帧 Number Slow UI thread: 502 因UI线程上的工作导致超时的帧数 Number Slow bitmap uploads: 44 因bitmap的加载耗时的帧数 Number Slow issue draw commands: 135 因绘制导致耗时的帧数 使用systrace 上面使用的dumpsys是能发现问题或者判断问题的严重性，但无法定位真正的原因。如果要定位原因，应当配合systrace工具使用。 systrace使用 Systrace可以帮助分析应用是如何设备上运行起来的，它将系统和应用程序线程集中在一个共同的时间轴上，分析systrace的第一步需要在程序运行的时间段中抓取trace log，在抓取到的trace文件中，包含了这段时间中想要的关键信息，交互情况。图1显示的是当一个app在滑动时出现了卡顿的现象，默认的界面下，横轴是时间，纵向为trace event，trace event 先按进程分组，然后再按线程分组.从上到下的信息分别为Kernel，SurfaceFlinger，应用包名。通过配置trace的分类，可以根据配置情况记录每个应用程序的所有线程信息以及trace event的层次结构信息。 Android studio中使用systrace 1、在android设备的 设置 – 开发者选项 – 监控 – 开启traces。2、选择要追中的类别，并且点击确定。 完成以上配置后，开始抓trace文件 $ python systrace.py --cpu-freq --cpu-load --time=10 -o mytracefile.html 分析trace文件抓到trace.html文件后，通过web浏览器打开 检查Frames每个应用程序都有一排代表渲染帧的圆圈，通常为绿色，如果绘制的时间超过16.6毫秒则显示黄色或红色。通过“W”键查看帧。trace应用程序代码在framework中的trace marker并没有覆盖到所有代码，因此有些时候需要自己去定义trace marker。在Android4.3之后，可以通过Trace类在代码中添加标记，这样将能够看到在指定时间内应用的线程在做哪些工作，当然，trace 的begin和end操作也会增加一些额外的开销，但都只有几微秒左右。通过下面的例子来说明Trace类的 用法。 public class MyAdapter extends RecyclerView.Adapter&lt;MyViewHolder&gt; { ... @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { Trace.beginSection(\"MyAdapter.onCreateViewHolder\"); MyViewHolder myViewHolder; try { myViewHolder = MyViewHolder.newInstance(parent); } finally { Trace.endSection(); } return myViewHolder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { Trace.beginSection(\"MyAdapter.onBindViewHolder\"); try { try { Trace.beginSection(\"MyAdapter.queryDatabase\"); RowItem rowItem = queryDatabase(position); mDataset.add(rowItem); } finally { Trace.endSection(); } holder.bind(mDataset.get(position)); } finally { Trace.endSection(); } } … } 使用BlockCanary BlockCanary是国内开发者MarkZhai开发的一套性能监控组件，它对主线程操作进行了完全透明的监控，并能输出有效的信息，帮助开发分析、定位到问题所在，迅速优化应用。其特点有：1、非侵入式，简单的两行就打开监控，不需要到处打点，破坏代码优雅性。2、精准，输出的信息可以帮助定位到问题所在（精确到行），不需要像Logcat一样，慢慢去找。3、目前包括了核心监控输出文件，以及UI显示卡顿信息功能 BlockCanary基本原理 android应用程序只有一个主线程ActivityThread，这个主线程会创建一个Looper(Looper.prepare)，而Looper又会关联一个MessageQueue，主线程Looper会在应用的生命周期内不断轮询(Looper.loop)，从MessageQueue取出Message 更新UI。 public static void loop() { ... for (;;) { ... // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } ... } } BlockCanary主要是检测msg.target.dispatchMessage(msg);之前的&gt;&gt;&gt;&gt;&gt; Dispatching to 和之后的&lt;&lt;&lt;&lt;&lt; Finished to的间隔时间。应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。通过给主线程的Looper设置一个Printer，打点统计dispatchMessage方法执行的时间，如果超出阀值，表示发生卡顿，则dump出各种信息，提供开发者分析性能瓶颈。 使用Choreographer Android 主线程运行的本质，其实就是 Message 的处理过程，我们的各种操作，包括每一帧的渲染操作 ，都是通过 Message 的形式发给主线程的 MessageQueue ，MessageQueue 处理完消息继续等下一个消息。Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms ， Vsync 信号唤醒 Choreographer 来做 App 的绘制操作 ，这就是引入 Choreographer 的主要作用。 Choreographer 两个主要作用 1、承上：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等。 2、启下：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync) . 使用Choreographer 计算帧率 Choreographer 处理绘制的逻辑核心在 Choreographer.doFrame 函数中，从下图可以看到，FrameDisplayEventReceiver.onVsync post 了自己，其 run 方法直接调用了 doFrame 开始一帧的逻辑处理：Choreographer周期性的在UI重绘时候触发，在代码中记录上一次和下一次绘制的时间间隔，如果超过16ms，就意味着一次UI线程重绘的“丢帧”。丢帧的数量为间隔时间除以16，如果超过3，就开始有卡顿的感知。使用Choreographer检测帧的代码如下： public class MyFrameCallback implements Choreographer.FrameCallback { private String TAG = \"性能检测\"; private long lastTime = 0; @Override public void doFrame(long frameTimeNanos) { if (lastTime == 0) { //代码第一次初始化。不做检测统计。 lastTime = frameTimeNanos; } else { long times = (frameTimeNanos - lastTime) / 1000000; int frames = (int) (times / 16); if (times &gt; 16) { Log.w(TAG, \"UI线程超时(超过16ms):\" + times + \"ms\" + \" , 丢帧:\" + frames); } lastTime = frameTimeNanos; } Choreographer.getInstance().postFrameCallback(mFrameCallback); } } 优化 由上面的分析可知对象分配、垃圾回收(GC)、线程调度以及Binder调用 是Android系统中常见的卡顿原因，因此卡顿优化主要以下几种方法，更多的要结合具体的应用来进行： 1、布局优化 通过减少冗余或者嵌套布局来降低视图层次结构。比如使用约束布局代替线性布局和相对布局。 用 ViewStub 替代在启动过程中不需要显示的 UI 控件。 使用自定义 View 替代复杂的 View 叠加。 2、减少主线程耗时操作 主线程中不要直接操作数据库，数据库的操作应该放在数据库线程中完成。 sharepreference尽量使用apply，少使用commit，可以使用MMKV框架来代替sharepreference。 网络请求回来的数据解析尽量放在子线程中，不要在主线程中进行复制的数据解析操作。 不要在activity的onResume和onCreate中进行耗时操作，比如大量的计算等。 3、减少过度绘制过度绘制是同一个像素点上被多次绘制，减少过度绘制一般减少布局背景叠加等方式，如下图所示右边是过度绘制的图片。4、列表优化 RecyclerView使用优化，使用DiffUtil和notifyItemDataSetChanged进行局部更新等。 5、对象分配和回收优化 自从Android引入 ART 并且在Android 5.0上成为默认的运行时之后，对象分配和垃圾回收（GC）造成的卡顿已经显著降低了，但是由于对象分配和GC有额外的开销，它依然又可能使线程负载过重。 在一个调用不频繁的地方（比如按钮点击）分配对象是没有问题的，但如果在在一个被频繁调用的紧密的循环里，就需要避免对象分配来降低GC的压力。 减少小对象的频繁分配和回收操作。 存储优化 交换数据格式 Google 推出的 Protocal Buffers 是一种更轻便高效的存储结构，但消耗内存较大。 FlatBuffers 同样由 Google 推出，专注性能，适合移动端。占用存储比 Protocal 要大。 SharePreferences 优化 当 SharedPreferences 文件还没有被加载到内存时，调用 getSharedPreferences 方法会初始化文件并读入内存，这容易导致 耗时更长。 Editor 的 commit 或者 apply 方法的区别在于同步写入和异步 写入，以及是否需要返回值。在不需要返回值的情况下，使用 apply 方法可以极大提高性能。 SharedPreferences 类 中的 commitToMemory() 会锁定 SharedPreference 对象，put() 和 getEditor() 方法会锁定 Editor 对象，在写入磁盘时更会锁定一个写入锁。因此，最好的优化方法就是避免频繁地读写 SharedPreferences，减少无谓的调用。对于 SharedPreferences 的批量操作，最好先获取一个 editor 进行批量操作，然后调用 apply 方法。 Bitmap 解码 4.4 以上 decodeFile 内部没有使用缓存，效率不高。要使用 decodeStream，同时传入的文件流为 BufferedInputStream。 decodeResource 同样存在性能问题，用 decodeResourceStream。 数据库优化 使用 StringBuilder 代替 String 查询时返回更少的结果集及更少的字段 查询时只取需要的字段和结果集，更多的结果集会消耗更多的时间及内存，更多的字段会导致更多的内存消耗。 少用 cursor.getColumnIndex 根据性能调优过程中的观察 cursor.getColumnIndex 的时间消耗跟 cursor.getInt 相差无几。可以在建表的时候用 static 变量记住某列的 index，直接调用相应 index 而不是每次查询。 异步线程 Android 中数据不多时表查询可能耗时不多，不会导致 ANR，不过大于 100ms 时同样会让用户感觉到延时和卡顿，可以放在线程中运行，但 sqlite 在并发方面存在局限，多线程控制较麻烦，这时候可使用单线程池，在任务中执行 db 操作，通过 handler 返回结果和 UI 线程交互，既不会影响 UI 线程，同时也能防止并发带来的异常。 SQLiteOpenHelper 维持一个单例 因为 SQLite 对多线程的支持并不是很完善，如果两个线程同时操作数据库，因为数据库被另一个线程占用， 这种情况下会报“Database is locked” 的异常。所以在数据库管理类中使用单例模式，就可以保证无论在哪个线程中获取数据库对象，都是同一个。 最好的方法是所有的数据库操作统一到同一个线程队列管理，而业务层使用缓存同步，这样可以完全避免多线程操作数据库导致的不同步和死锁问题。 Application 中初始化 使用 Application 的 Context 创建数据库，在 Application 生命周期结束时再关闭。 在应用启动过程中最先初始化完数据库，避免进入应用后再初始化导致相关操作时间变长。 少用 AUTOINCREMENT 主键加上 AUTOINCREMENT 后，可以保证主键严格递增，但并不能保证每次都加 1，因为在插入失败后，失败的行号不会被复用，会造成主键有间隔，继而使 INSERT 耗时 1 倍以上。 这个 AUTOINCREMENT 关键词会增加 CPU，内存，磁盘空间和磁盘 I/O 的负担，所以 尽量不要用，除非必需。通常情况下都不是必需的。 事务 使用事务的两大好处是原子提交和更优性能： 原子提交：意味着同一事务内的所有修改要么都完成要么都不做，如果某个修改失败，会自动回滚使得所有修改不生效。 更优性能：Sqlite 默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。这样如果连续插入 100 次数据实际是创建事务、执行语句、提交这个过程被重复执行了 100 次。如果显式的创建事务，这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。尤其当数据库位于 sd 卡时，时间上能节省两个数量级左右。 主要三个方法：beginTransaction，setTransactionSuccessful，endTransaction。 SQLiteStatement 使用 Android 系统提供的 SQLiteStatement 来插入数据，在性能上有一定的提高，并且也解决了 SQL 注入的问题。 SQLiteStatement statement = dbOpenHelper.getWritableDatabase().compileStatement(\"INSERT INTO EMPERORS(name, dynasty, start_year) values(?,?,?)\"); statement.clearBindings(); statement.bindString(1, \"Max\"); statement.bindString(2, \"Luk\"); statement.bindString(3, \"1998\"); statement.executeInsert(); SQLiteStatement 只能插入一个表中的数据，在插入前要清除上一次的数据。 索引 索引就像书本的目录，目录可以快速找到所在页数，数据库中索引可以帮助快速找到数据，而不用全表扫描，合适的索引可以大大提高数据库查询的效率。 优点：大大加快了数据库检索的速度，包括对单表查询、连表查询、分组查询、排序查询。经常是一到两个数量级的性能提升，且随着数据数量级增长。 缺点： 索引的创建和维护存在消耗，索引会占用物理空间，且随着数据量的增加而增加。 在对数据库进行增删改时需要维护索引，所以会对增删改的性能存在影响。 分类 直接创建索引和间接创建索引 直接创建: 使用 sql 语句创建，Android 中可以在 SQLiteOpenHelper 的 onCreate 或是 onUpgrade 中直接 excuSql 创建语句，如 CREATE INDEX mycolumn_index ON mytable (myclumn) 间接创建: 定义主键约束或者唯一性键约束，可以间接创建索引，主键默认为唯一索引。 普通索引和唯一性索引 普通索引：CREATEINDEXmycolumn_indexONmytable(myclumn) 唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，语句为 CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn) 单个索引和复合索引 单个索引：索引建立语句中仅包含单个字段，如上面的普通索引和唯一性索引创建示例。 复合索引：又叫组合索引，在索引建立语句中同时包含多个字段，如 CREATEINDEXname_indexONusername(firstname,lastname)，其中 firstname 为前导列。 聚簇索引和非聚簇索引 (聚集索引，群集索引) 聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列，如 CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH ALLOW_DUP_ROW，其中 WITH ALLOW_DUP_ROW 表示允许有重复记录的聚簇索引 非聚簇索引：CREATEUNCLUSTEREDINDEXmycolumn_cindexONmytable(mycolumn)，索引默认为非聚簇索引 使用场景 当某字段数据更新频率较低，查询频率较高，经常有范围查询 (&gt;, &lt;, =,&gt;=, &lt;=) 或 order by、group by 发生时建议使用索引。并且选择度（一个字段中唯一值的数量 / 总的数量）越大，建索引越有优势 经常同时存取多列，且每列都含有重复值可考虑建立复合索引 使用规则 对于复合索引，把使用最频繁的列做为前导列 (索引中第一个字段)。如果查询时前导列不在查询条件中则该复合索引不会被使用。如 create unique index PK_GRADE_CLASS on student (grade, class)，select * from student where class = 2 未使用到索引，select * from dept where grade = 3 使用到了索引 避免对索引列进行计算，对 where 子句列的任何计算如果不能被编译优化，都会导致查询时索引失效 select * from student where tochar(grade)=’2 比较值避免使用 NULL 多表查询时要注意是选择合适的表做为内表。连接条件要充份考虑带有索引的表、行数多的表，内外表的选择可由公式：外层表中的匹配行数 * 内层表中每一次查找的次数确定，乘积最小为最佳方案。实际多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案 查询列与索引列次序一致 用多表连接代替 EXISTS 子句 把过滤记录数最多的条件放在最前面 善于使用存储过程，它使 sql 变得更加灵活和高效 (Sqlite 不支持存储过程) 其它通用优化 经常用的数据读取后缓存起来，以免多次重复读写造成“写入放大” 子线程读写数据 ObjectOutputStream 在序列化磁盘时，会把内存中的每个对象保存到磁盘，在保存对象的 时候，每个数据成员会带来一次 I/O 操作。在 ObjectOutputStream 上面再封装一个输出流 ByteArrayOutputStream 或 BufferedOutputStream，先将对象序列化后的信息写到缓存区中，然后再一次性地写到磁盘上；相应的，用 ByteArrayInputStream 或 BufferedInputStream 替代 ObjectInputStream。 合理选择缓冲区 Buffer 的大小。太小导致 I/O 操作次数增多，太大导致申请时间变长。比如 4-8 KB。 网络优化 互联网时代, App作为于用户交互的端, 可以说实际上是一个界面, 产品的业务, 服务都是由Server提供的. 而App与Server的交互依赖于网络, 故而网络优化, 也是我们的App优化中不可缺少的一个优化项。除了客户端, 接口的优化外, 很多一部分优化还依赖于服务器端, 包括服务器端的代码开发, 部署方式等。 网络连接对用户的影响 App的网络连接对于用户来说, 影响很多, 且多数情况下都很直观, 直接影响用户对这个App的使用体验. 其中较为重要的几点: 流量App的流量消耗对用户来说是比较敏感的, 毕竟流量是花钱的嘛. 现在大部分人的手机上都有安装流量监控的工具App, 用来监控App的流量使用. 如果我们的App这方面没有控制好, 会给用户不好的使用体验. 电量电量相对于用户来说, 没有那么明显. 一般用户可能不会太注意. 但是如电量优化中的那样, 网络连接(radio)是对电量影响很大的一个因素. 所以我们也要加以注意. 用户等待也就是用户体验, 良好的用户体验, 才是我们留住用户的第一步. 如果App请求等待时间长, 会给用户网络卡, 应用反应慢的感觉, 如果有对比, 有替代品, 我们的App很可能就会被用户无情抛弃. 分析网络连接的工具 Network Monitor Android Studio内置的Monitor工具中就有一个Network Monitor: 其中: Rx — R(ecive) 表示下行流量, 即下载接收. Tx — T(ransmit) 表示上行流量, 即上传发送. 怎么使用Network Monitor? Network monitor实时跟踪选定应用的数据请求情况. 我们可以连上手机, 选定调试应用进程, 然后在App上操作我们需要分析的页面请求. 例如, 上图就是以CoderPub为例, 针对从repo列表界面进入repo详情界面的监控数据. 可以看到从10s到30s之间, 20s时间内发生了多次数据请求, 且22s到27s之间的请求数据量还很大. 分析代码可以看到, 在请求repo详情的时候是打包了很多请求的: @Override public Observable&lt;RepoDetail&gt; getRepoDetail(String owner, String name) { return Observable.zip(mRepoService.get(owner, name), mRepoService.contributors(owner, name), mRepoService.listForks(owner, name, \"newest\"), mRepoService.readme(owner, name), isStarred(owner, name), new Func5&lt;Repo, ArrayList&lt;User&gt;, ArrayList&lt;Repo&gt;, Content, Boolean, RepoDetail&gt;() { @Override public RepoDetail call(Repo repo, ArrayList&lt;User&gt; users, ArrayList&lt;Repo&gt; forks, Content readme, Boolean isStarred) { RepoDetail detail = new RepoDetail(); repo.setStarred(isStarred); detail.setBaseRepo(repo); detail.setForks(forks); // because the readme content is encode with Base64 by github. readme.content = StringUtil.base64Decode(readme.content); detail.setReadme(readme); detail.setContributors(users); return detail; } }); } 这也验证了14s到20s间的四次数据请求, 另外由于repo详情界面会显示作者以及贡献者的图片, 而图片的数据量相对大, 故而23s到27s间有多次数据量很大的请求发生. 网络代理工具 一般来说, 网络代理工具有两个作用: 截获网络请求响应包, 分析网络请求 设置代理网络, 移动App开发中一般用来做不同网络环境的测试, 例如Wifi/4G/3G/弱网等. 代理工具很多, 诸如Wireshark, Fiddler, Charles等, 在此不一一细说了, 使用方法自行问谷歌度娘. :) 从哪些方面优化网络连接 简单来说, 两个方面: 减少Radio活跃时间 也就是减少网络数据获取的频次. 这就减少了radio的电量消耗, 控制电量使用. 减少获取数据包的大小 可以减少流量消耗 也可以让每次请求更快, 在网络情况不好的情况下也有良好表现, 提升用户体验. 接口设计 API设计 App与Server之间的API设计要考虑网络请求的频次, 资源的状态等. 以便App可以以较少的请求来完成业务需求和界面的展示. 例如, 注册登录. 正常会有两个API, 注册和登录, 但是设计API时我们应该给注册接口包含一个隐式的登录. 来避免App在注册后还得请求一次登录接口(有可能失败, 从而导致业务流程失败). 例如, 之前提到的获取repo详情, 实际上请求了4个接口, 请求了repo的信息, forks列表, contributors列表, readme, 这是因为github提供的接口是尽量单一职责的. 然而在我们的实际开发中, 我们的Server除了提供这些单一职责的小接口外, 最好还能组合一个满足客户端业务需求的repo详情接口出来. Gzip压缩 使用Gzip来压缩request和response, 减少传输数据量, 从而减少流量消耗. 考虑使用Protocol Buffer代替JSON 以前我们传输数据使用XML, 后来使用JSON代替了XML, 很大程度上也是为了可读性和减少数据量(当然还有映射成POJO的方便程度). Protocol Buffer是Google推出的一种数据交换格式. 如果我们的接口每次传输的数据量很大的话, 可以考虑下protobuf, 会比JSON数据量小很多. 当然相比来说, JSON也有其优势, 可读性更高. 本节以网络流量优化的角度推荐protobuf作为一个选择, 具体还需更具实际情况考虑. 图片的Size 上面Network Monitor中看到的22s到27s之间的有多次请求, 且数据量还很大. 就是在获取图片资源. 图片相对于接口请求来说, 数据量要大得多. 故而也是我们需要优化的一个点. 我们可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费. 我们现在很多公司的图片资源都是使用第三方的云存储服务的(七牛, 阿里云存储之类的). 以七牛为例, 可以在请求图片的url中添加诸如质量, 格式, width, height等path来获取合适的图片资源: imageView2/&lt;mode&gt;/w/&lt;LongEdge&gt; /h/&lt;ShortEdge&gt; /format/&lt;Format&gt; /interlace/&lt;Interlace&gt; /q/&lt;Quality&gt; /ignore-error/&lt;ignoreError&gt; 网络缓存 适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗. 打包网络请求 当接口设计不能满足我们的业务需求时. 例如可能一个界面需要请求多个接口, 或是网络良好, 处于Wifi状态下时我们想获取更多的数据等. 这时就可以打包一些网络请求, 例如请求列表的同时, 获取Header点击率较高的的item项的详情数据. 可以通过一些统计数据来帮助我们定位用户接下来的操作是高概率的, 提前获取这部分的数据. 监听相关状态 通过监听设备的状态: 休眠状态 充电状态 网络状态 结合JobScheduler来根据实际情况做网络请求. 比方说Splash闪屏广告图片, 我们可以在连接到Wifi时下载缓存到本地; 新闻类的App可以在充电, Wifi状态下做离线缓存. 弱网测试&amp;优化 除了正常的网络优化, 我们还需考虑到弱网情况下, App的表现. 弱网测试 有几种方式来模拟弱网进行测试. Android Emulator 创建和启动Android模拟器可以设置网络速度和延迟: 创建时: 启动时, 使用emulator命令: $emulator -netdelay gprs -netspeed gsm -avd Nexus_5_API_22 具体参数参考这里和这里, 需要翻墙. 使用网络代理工具 以Charles为例:保持手机和PC处于同一个局域网, 在手机端wifi设置高级设置中设置代理方式为手动, 代理ip填写PC端ip地址, 端口号默认8888. 其他模拟弱网方式 如果你恰好也是iOS的开发者, Apple提供了Network Link Conditioner, 非常好用. 可以模拟的网络情况与上述类似: ​ 如果你使用Linux环境开发, 还可以试下facebook出的ATC. 弱网优化 利用上述工具模拟弱网, 在弱网情况下体验我们的App. 一般来说, 网络延迟在60ms内, 是OK的, 超过200ms就比较糟糕了. 我们需要做的是在比较糟糕的网络环境下还能给用户较好的体验. 弱网优化, 本质上是在弱网的情况下能让用户流畅的使用我们的App. 我们要做的就是结合上述的优化项: 压缩/减少数据传输量 利用缓存减少网络传输 针对弱网(移动网络), 不自动加载图片 界面先反馈, 请求延迟提交例如, 用户点赞操作, 可以直接给出界面的点赞成功的反馈, 使用JobScheduler在网络情况较好的时候打包请求. 耗电优化 实践中，如果我们的应用需要播放视频、需要获取 GPS 信息、需要拍照，这些耗电看起来是无法避免的。 如何判断哪些耗电是可以避免，或者是需要去优化的呢？可以看下面这张图，当用户去看耗电排行榜的时候，发现“王者荣耀”使用了 7 个多小时，这时用户对“王者荣耀”的耗电是有预期的。 假设这个时候发现某个应用他根本没怎么使用（前台时间很少），但是耗电却非常多。这种情况会跟用户的预期差别很大，他可能就会想去投诉。 所以耗电优化的第一个方向是优化应用的后台耗电。 知道了系统是如何计算耗电的，那反过来看，我们也就可以知道应用在后台不应该做什么，例如长时间获取 WakeLock、WiFi 和蓝牙的扫描等。为什么说耗电优化第一个方向就是优化应用后台耗电，因为大部分厂商预装项目要求最严格的正是应用后台待机耗电。 当然前台耗电我们不会完全不管，但是标准会放松很多。再来看看下面这张图，如果系统对你的应用弹出这个对话框，可能对于微信来说，用户还可以忍受，但是对其他大多数的应用来说，可能很多用户就直接把你加入到后台限制的名单中了 耗电优化的第二个方向是符合系统的规则，让系统认为你耗电是正常的。 而 Android P 是通过 Android Vitals 监控后台耗电，所以我们需要符合 Android Vitals 的规则，目前它的具体规则如下： 虽然上面的标准可能随时会改变，但是可以看到，Android 系统目前比较关心后台 Alarm 唤醒、后台网络、后台 WiFi 扫描以及部分长时间 WakeLock 阻止系统后台休眠。 耗电监控 对于耗电监控也是如此，我们首先需要抽象出具体的规则，然后收集尽量多的辅助信息，帮助问题的排查。 Android Vitals Android Vitals 的几个关于电量的监控方案与规则： Alarm Manager wakeup 唤醒过多 频繁使用局部唤醒锁 后台网络使用量过高 后台 WiFi scans 过多 在使用了一段时间之后，我发现它并不是那么好用。以 Alarm wakeup 为例，Vitals 以每小时超过 10 次作为规则。由于这个规则无法做修改，很多时候我们可能希望针对不同的系统版本做更加细致的区分。 其次跟 Battery Historian 一样，我们只能拿到 wakeup 的标记的组件，拿不到申请的堆栈，也拿不到当时手机是否在充电、剩余电量等信息。 对于网络、WiFi scans 以及 WakeLock 也是如此。虽然 Vitals 帮助我们缩小了排查的范围，但是依然需要在茫茫的代码中寻找对应的可疑代码。 耗电监控都监控什么 Android Vitals并不是那么好用，而且对于国内的应用来说其实也根本无法使用。不管怎样，我们还是需要搭建自己的耗电监控系统。 那我们的耗电监控系统应该监控哪些内容，怎么样才能比 Android Vitals 做得更好呢？ 监控信息。简单来说系统关心什么，我们就监控什么，而且应该以后台耗电监控为主。类似 Alarm wakeup、WakeLock、WiFi scans、Network 都是必须的，其他的可以根据应用的实际情况。如果是地图应用，后台获取 GPS 是被允许的；如果是计步器应用，后台获取 Sensor 也没有太大问题。 现场信息。监控系统希望可以获得完整的堆栈信息，比如哪一行代码发起了 WiFi scans、哪一行代码申请了 WakeLock 等。还有当时手机是否在充电、手机的电量水平、应用前台和后台时间、CPU 状态等一些信息也可以帮助我们排查某些问题。 提炼规则。最后我们需要将监控的内容抽象成规则，当然不同应用监控的事项或者参数都不太一样。 由于每个应用的具体情况都不太一样，下面是一些可以用来参考的简单规则。 在安卓绿色联盟的会议中，华为公开过他们后台资源使用的“红线”，你也可以参考里面的一些规则： 如何监控耗电 明确了我们需要监控什么以及具体的规则之后，就可以来到实现这个环节了。跟 I/O 监控、网络监控一样，我首先想到的还是 Hook 方案。 Java Hook Hook 方案的好处在于使用者接入非常简单，不需要去修改自己的代码。下面我以几个比较常用的规则为例，看看如果使用 Java Hook 达到监控的目的。 WakeLock。WakeLock 用来阻止 CPU、屏幕甚至是键盘的休眠。类似 Alarm、JobService 也会申请 WakeLock 来完成后台 CPU 操作。WakeLock 的核心控制代码都在PowerManagerService中，实现的方法非常简单。 // 代理 PowerManagerService ProxyHook().proxyHook(context.getSystemService(Context.POWER_SERVICE), \"mService\", this)； @Override public void beforeInvoke(Method method, Object[] args) { // 申请 Wakelock if (method.getName().equals(\"acquireWakeLock\")) { if (isAppBackground()) { // 应用后台逻辑，获取应用堆栈等等 } else { // 应用前台逻辑，获取应用堆栈等等 } // 释放 Wakelock } else if (method.getName().equals(\"releaseWakeLock\")) { // 释放的逻辑 } } Alarm。Alarm 用来做一些定时的重复任务，它一共有四个类型，其中ELAPSED_REALTIME_WAKEUP和RTC_WAKEUP类型都会唤醒设备。同样，Alarm 的核心控制逻辑都在AlarmManagerService中，实现如下： // 代理 AlarmManagerService new ProxyHook().proxyHook(context.getSystemService (Context.ALARM_SERVICE), \"mService\", this)； public void beforeInvoke(Method method, Object[] args) { // 设置 Alarm if (method.getName().equals(\"set\")) { // 不同版本参数类型的适配，获取应用堆栈等等 // 清除 Alarm } else if (method.getName().equals(\"remove\")) { // 清除的逻辑 } } 其他。对于后台 CPU，我们可以使用卡顿监控相关的方法。对于后台网络，同样我们可以通过网络监控相关的方法。对于 GPS 监控，我们可以通过 Hook 代理LOCATION_SERVICE。对于 Sensor，我们通过 Hook SENSOR_SERVICE中的“mSensorListeners”，可以拿到部分信息。 通过 Hook，我们可以在申请资源的时候将堆栈信息保存起来。当我们触发某个规则上报问题的时候，可以将收集到的堆栈信息、电池是否充电、CPU 信息、应用前后台时间等辅助信息也一起带上。 插桩 虽然使用 Hook 非常简单，但是某些规则可能不太容易找到合适的 Hook 点。而且在 Android P 之后，很多的 Hook 点都不支持了。 出于兼容性考虑，我首先想到的是写一个基础类，然后在统一的调用接口中增加监控逻辑。以 WakeLock 为例： public class WakelockMetrics { // Wakelock 申请 public void acquire(PowerManager.WakeLock wakelock) { wakeLock.acquire(); // 在这里增加 Wakelock 申请监控逻辑 } // Wakelock 释放 public void release(PowerManager.WakeLock wakelock, int flags) { wakelock.release(); // 在这里增加 Wakelock 释放监控逻辑 } } Facebook 也有一个耗电监控的开源库Battery-Metrics，它监控的数据非常全，包括 Alarm、WakeLock、Camera、CPU、Network 等，而且也有收集电量充电状态、电量水平等信息。 Battery-Metrics 只是提供了一系列的基础类，在实际使用中，接入者可能需要修改大量的源码。但对于一些第三方 SDK 或者后续增加的代码，我们可能就不太能保证可以监控到了。这些场景也就无法监控了，所以 Facebook 内部是使用插桩来动态替换。 遗憾的是，Facebook 并没有开源它们内部的插桩具体实现方案。不过这实现起来其实并不困难，事实上在 Sample 中，已经使用过 ASM、Aspectj 这两种插桩方案了。 插桩方案使用起来兼容性非常好，并且使用者也没有太大的接入成本。但是它并不是完美无缺的，对于系统的代码插桩方案是无法替换的，例如 JobService 申请 PARTIAL_WAKE_LOCK 的场景。 多线程并发优化 在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，非常有必要掌握多线程并发编程的基础技能。 Thread 使用 Thread使用需要注意的点： Thread 中断 常用的有两种方式： (1).通过抛出InterruptedException来中断线程 public static class MyThread extends Thread{ private int count=0; @Override public void run() { super.run(); try{ while(true){ count++; System.out.println(\"count value:\"+count); if (this.interrupted() || this.isInterrupted()){ System.out.println(\"check interrupted show!\"); throw new InterruptedException(); } } }catch ( InterruptedException e) { System.out.println(\"thread is stop!\"); e.printStackTrace(); } } } (2).通过变量来中断（常用） public static class CustomThread extends Thread{ private int count=0; private boolean isCancel = false; @Override public void run() { super.run(); while(!isCancel){ count++; System.out.println(\"count value:\"+count); } } public synchronized void cancel(){ isCancel = true; } } 同步 分变量同步和代码块同步两个方面来讲解 (1).变量同步 使用volatile关键字 /** * 主内存和线程内存缓存进行同步 */ volatile int val = 5; public int getVal() { return val; } public void setVal(int val) { this.val = val; } 使用synchronized关键字 int val2 = 5; /** * 使用一个motinor来监听（实现资源由一个线程进行操作） * 主内存和线程内存缓存进行同步 * @return */ public synchronized int getVal2() { return val2; } public synchronized int setVal2(int val) { this.val2 = val; } 使用关键字AtomicXXXXX AtomicInteger mAtomicValue = new AtomicInteger(0); public void setAtomicValue(int value){ mAtomicValue.getAndSet(value); } public int getAtomicValue(){ return mAtomicValue.get(); } (2).代码块同步 代码块同步分乐观锁和悲观锁来讲解 使用悲观锁时，其他线程等待，进入睡眠，频繁切换任务，消耗cpu资源 synchronized (this) { ..... } 使用乐观锁时，失败重试，避免任务重复切换，减少cpu消耗 ReentrantLock lock = new ReentrantLock(); lock.lock(); ...... lock.unlock(); Android Threading android中很多操作需要在主线程中执行，比如UI的操作，点击事件等等，但是如果主线程操作太多，占有的执行时间过长就会出现前面我们说的卡顿现象： 为了减轻主线程操作过多，避免出现卡顿的现象，我们把一些操作复杂的消耗时间长的任务放到线程池中去执行。下面我们就来介绍android中几种线程的类。 AsyncTask 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。(关于内存泄漏在上面已经讲过) 使用AsyncTask需要注意的问题? (1).在AsyncTask中所有的任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。一旦有任务执行时间过长，队列中其他任务就会阻塞。 对于上面的问题，我们可以使用AsyncTask.executeOnExecutor()让AsyncTask变成并发调度。 (2).AsyncTask对正在执行的任务不具备取消的功能，所以我们要在任务代码中添加取消的逻辑（和上面Thread类似） (3).AsyncTask使用不当会导致内存泄漏（可以参考内存泄漏一章） HandlerThread 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。先来了解下Looper，Handler，MessageQueueLooper: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。Handler: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。MessageQueue: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。 把上面三个组件打包到一起进行协作，这就是HandlerThread 我们先来看下源码： public class HandlerThread extends Thread { public HandlerThread(String name, int priority) { super(name); mPriority = priority; } @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } public Looper getLooper() { if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { while (isAlive() &amp;&amp; mLooper == null) { try { wait(); } catch (InterruptedException e) { } } } return mLooper; } } 从上面的源码发现，HandlerThread其实就是在线程中维持一个消息循环队列。下面我们看下使用： HandlerThread mHanderThread = new HandlerThread(\"hanlderThreadTest\", Process.THREAD_PRIORITY_BACKGROUND); mHanderThread.run(); Looper mHanderThreadLooper = mHanderThread.getLooper(); Handler mHandler = new Handler(mHanderThreadLooper){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); //子线程中执行 ... } }; //发送消息 mHandler.post(new Runnable() { @Override public void run() { ... } }); IntentService 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在onHandlerIntent()的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。 使用IntentService需要特别注意的点： (1).因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。 (2).通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用runOnUiThread()快速回调到主UI线程。 (3).包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。 Loader 对于3.0后ContentProvider中的耗时操作，推荐使用Loader异步加载数据机制。相对其他加载机制，Loader有那些优点呢？ 提供异步加载数据机制 对数据源变化进行监听，实时更新数据 在Activity配置发生变化（如横竖屏切换）时不用重复加载数据 适用于任何Activity和Fragment 下面我们来看下Loader的具体使用： 我们以获得手机中所有的图片为例： getLoaderManager().initLoader(LOADER_TYPE, null, mLoaderCallback); LoaderManager.LoaderCallbacks&lt;Cursor&gt; mLoaderCallback = new LoaderManager.LoaderCallbacks&lt;Cursor&gt;() { private final String[] IMAGE_COLUMNS={ MediaStore.Images.Media.DATA,//图片路径 MediaStore.Images.Media.DISPLAY_NAME,//显示的名字 MediaStore.Images.Media.DATE_ADDED,//添加时间 MediaStore.Images.Media.MIME_TYPE,//图片扩展类型 MediaStore.Images.Media.SIZE,//图片大小 MediaStore.Images.Media._ID,//图片id }; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { toggleShowLoading(true,getString(R.string.common_loading)); CursorLoader cursorLoader = new CursorLoader(ImageSelectActivity.this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI,IMAGE_COLUMNS, IMAGE_COLUMNS[4] + \" &gt; 0 AND \"+IMAGE_COLUMNS[3] + \" =? OR \" +IMAGE_COLUMNS[3] + \" =? \", new String[]{\"image/jpeg\",\"image/png\"},IMAGE_COLUMNS[2] + \" DESC\"); return cursorLoader; } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { if(data != null &amp;&amp; data.getCount() &gt; 0){ ArrayList&lt;String&gt; imageList = new ArrayList&lt;&gt;(); if(mShowCamera){ imageList.add(\"\"); } while (data.moveToNext()){ String path = data.getString(data.getColumnIndexOrThrow(IMAGE_COLUMNS[0])); imageList.add(path); Log.e(\"ImageSelect\", \"IIIIIIIIIIIIIIIIIIII=====&gt;\"+path); } //显示数据 showListData(imageList); toggleShowLoading(false,getString(R.string.common_loading)); } } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } onCreateLoader() 实例化并返回一个新创建给定ID的Loader对象onLoadFinished() 当创建好的Loader完成了数据的load之后回调此方法onLoaderReset() 当创建好的Loader被reset时调用此方法，这样保证它的数据无效LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到onLoadFinished()，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调onLoaderReset()方法，我们可以在这里做数据的清除等等操作。 ThreadPool 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。线程池适合用在把任务进行分解，并发进行执行的场景。系统提供ThreadPoolExecutor帮助类来帮助我们简化实现线程池。 使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。 /** * 核心线程数 * 最大线程数 * 保活时间 * 时间单位 * 任务队列 * 线程工厂 */ threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, linkedBlockingQueue, sThreadFactory); threadPoolExecutor.execute(runnable); 我们知道系统还提供了Executors类中几种线程池，下面我们来看下这些线程池的缺点： **newFixedThreadPool 和 newSingleThreadExecutor:**主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。**newCachedThreadPool 和 newScheduledThreadPool:**主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM 我们看到这些线程池但是有缺点的，所以具体使用那种方式实现要根据我们的需求来选择。 如果想要避开上面的问题，可以参考OKHttp中线程池的实现，OKHttp中队线程调度又封装了一层，使用安全且方便，有兴趣的可以去看看源码。 线程优先级 Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。 默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。 在Android系统里面，我们可以通过android.os.Process.setThreadPriority(int)设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。 大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用THREAD_PRIORITY_LESS_FAVORABLE或者THREAD_PRIORITY_MORE_FAVORABLE来控制线程的优先级。 安装包优化 安装包优化的主要方向就是APP瘦身，那么App瘦身带来哪些好处呢？ (1).下载时省流量 (2).用户好的体验，下载更快，安装更快 常用的优化方式 清理无用资源 在我们应用版本的迭代中，肯定有废弃的代码和资源，我们要及时地清理，来减小App体积。 清理的方法： (1).使用Refactor-&gt;Remove unused Resource 这个一键清除的小功能不是特别的又用，因为资源是经过反射或字符拼接等方式获取，所以检查不完全，需要我们不断的实验。 (2).使用Lint工具 lint工具还是很有用的，它给我们需要优化的点 需要注意的点： 检测没有用的布局并且删除 把未使用到的资源删除 建议String.xml有一些没有用到的字符也删除掉 (3).开启shrinkResources去除无用资源 在build.gradle 里面配置shrinkResources true，在打包的时候会自动清除掉无用的资源，但经过实验发现打出的包并不会，而是会把部分无用资源用更小的东西代替掉。注意，这里的“无用”是指调用图片的所有父级函数最终是废弃代码，而shrinkResources true 只能去除没有任何父函数调用的情况. android { buildTypes { release { shrinkResources true } } } (4).删除无用的语言资源 大部分应用其实并不需要支持几十种语言的国际化支持。比如我们只是保存中文支持： android { defaultConfig { resConfigs \"zh\" } } (5).清理第三方库中冗余代码 对于第三方库，可能我们只是用到库中的一个功能，那么我们就可以导入源码，并且删除无关的代码，来减小体积。 图片资源优化 图片是占用空间比较大的资源，这是我们要重点优化的地方。 (1).使用压缩过的图片 这个点在这里就不再累赘。 (2).只用一套图片 对于绝大对数APP来说，只需要取一套设计图就足够了。从内存占用和适配的角度考虑，这一套图建议放在xhdpi文件夹下； (3).使用不带alpha值的jpg图片 对于非透明的大图，jpg将会比png的大小有显著的优势，虽然不是绝对的，但是通常会减小到一半都不止。 (4).使用tinypng有损压缩 支持上传PNG图片到官网上压缩，然后下载保存，在保持alpha通道的情况下对PNG的压缩可以达到1/3之内，而且用肉眼基本上分辨不出压缩的损失. (5).使用webp格式 webp支持透明度，压缩比比jpg更高但显示效果却不输于jpg,从Android 4.0+开始原生支持，但是不支持包含透明度，直到Android 4.2.1+才支持显示含透明度的webp，使用的时候要特别注意。 (6).使用svg 矢量图是由点与线组成,和位图不一样,它再放大也能保持清晰度，而且使用矢量图比位图设计方案能节约30～40%的空间，现在谷歌一直在强调扁平化方式，矢量图可很好的契合该设计理念。 占用存储空间小 无极拉伸不会出现锯齿，可以照顾不同尺寸的机型 Android Studio自带很多资源 (7).使用shape 特别是在扁平化盛行的当下，很多纯色的渐变的圆角的图片都可以用shape实现，代码灵活可控，省去了大量的背景图片。 (8).使用着色方案 相信你的工程里也有很多selector文件，也有很多相似的图片只是颜色不同，通过着色方案我们能大大减轻这样的工作量，减少这样的文件。 (9).对打包后的图片进行压缩 使用7zip压缩方式对图片进行压缩,建议使用微信的AndResGuard 资源动态加载 资源可以动态加载，减小apk体积。 (1).在线化素材库 如果你的APP支持素材库(比如聊天表情库)的话，考虑在线加载模式，因为往往素材库都有不小的体积 (2).皮肤加载 有的app用到皮肤库，这是就可以使用动态加载。 (3).模块插件化 如果模块过多，apk体积过大，可以考虑插件化，来减少体积。 lib库优化 只提供对主流架构的支持，比如arm，对于mips和x86架构可以考虑不支持，这样可以大大减小APK的体积. 7zip压缩资源 对于assets或者raw文件夹中的资源，可以使用7zip压缩，使用时进行解压。 代码混淆 在gradle使用minifyEnabled进行Proguard混淆的配置. android { buildTypes { release { minifyEnabled true } } } 为什么代码混淆可以让apk变小? 可以删除注释和不用的代码。 将java文件名改成短名 将方法名改成短名 资源(res)混淆 资源混淆简单来说希望实现将res/drawable/icon,png变成res/drawable/a.png,或我们甚至可以将文件路径也同时混淆，改成r/s/a.png。 建议使用微信的AndResGuard 使用微信AndResGuard 使用微信AndResGuard对资源混淆并且压缩图片res等资源 apply plugin: 'AndResGuard' buildscript { dependencies { classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.1.7' } } andResGuard { mappingFile = null use7zip = true useSign = true keepRoot = false // add &lt;your_application_id&gt;.R.drawable.icon into whitelist. // because the launcher will get thgge icon with his name def packageName = &lt;your_application_id&gt; whiteList = [ //for your icon packageName + \".R.drawable.icon\", //for fabric packageName + \".R.string.com.crashlytics.*\", //for umeng update packageName + \".R.string.umeng*\", packageName + \".R.string.UM*\", packageName + \".R.string.tb_*\", packageName + \".R.layout.umeng*\", packageName + \".R.layout.tb_*\", packageName + \".R.drawable.umeng*\", packageName + \".R.drawable.tb_*\", packageName + \".R.anim.umeng*\", packageName + \".R.color.umeng*\", packageName + \".R.color.tb_*\", packageName + \".R.style.*UM*\", packageName + \".R.style.umeng*\", packageName + \".R.id.umeng*\" ] compressFilePattern = [ \"*.png\", \"*.jpg\", \"*.jpeg\", \"*.gif\", \"resources.arsc\" ] sevenzip { artifact = 'com.tencent.mm:SevenZip:1.1.7' //path = \"/usr/local/bin/7za\" } } Facebook的redex优化字节码 redex是facebook发布的一款android字节码的优化工具. redex","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Vi编辑","slug":"docs/操作系统/Linux/Vi编辑","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/vi-bian-ji/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/vi-bian-ji/","excerpt":"","text":"i 进入编辑模式 按ESC键 退出编辑模式，然后： :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi q: 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Ubuntu看不到图形界面解决办法","slug":"docs/操作系统/Linux/Ubuntu看不到图形界面解决办法","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/ubuntu-kan-bu-dao-tu-xing-jie-mian-jie-jue-ban-fa/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/ubuntu-kan-bu-dao-tu-xing-jie-mian-jie-jue-ban-fa/","excerpt":"","text":"ubuntu 看不到图形界面桌面的解决办法 1、使用Ctrl + Alt + F1组合键进入字符命令行界面 2、试试 restartx 3、如果第2条解决不了，再试试 sudo service lightdm restart 重启 lightdm 4、如果第3条解决不了，再试试 sudo dpkg-reconfigre lightdm 选择 lightdm 5、如果第4条解决不了，就只能重装 unity 了 sudo apt-get update sudo apt-get install –reinstall ubuntu-desktop sudo apt-get install unity","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"samba共享文件","slug":"docs/操作系统/Linux/samba共享文件","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/samba-gong-xiang-wen-jian/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/samba-gong-xiang-wen-jian/","excerpt":"","text":"Samba共享文件 Samba共享文件 Windows上无法访问共享文件","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"bash执行命令相关问题","slug":"docs/操作系统/Linux/bash执行命令相关问题","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/bash-zhi-xing-ming-ling-xiang-guan-wen-ti/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/bash-zhi-xing-ming-ling-xiang-guan-wen-ti/","excerpt":"","text":"sh 执行问题 bash: ./xxx.sh: /bin/bash^M: bad interpreter: No such file or directory 解决方案： 方法一 vim xxx.sh 进入 xxx.sh后 在底部模式下执行 :set fileformat=unix 后执行 :x 或者 :wq 保存修改 然后就可以执行./***.sh运行脚本了。 方法二： 直接执行 sed -i \"s/\\r//\" xxx.sh 来转化， 然后就可以执行 ./***.sh 运行脚本了。 方法三： 直接执行 dos2unix xxx.sh 来转化， 然后就可以执行 ./xxx.sh 运行脚本了. 如执行报错bash: dos2unix: command not found，请使用busybox dos2unix ***.sh继续操作。 bash: ./XXX: No such file or directory/ 没有那个文件或目录 64-bit上运行32-bit软件时，会出现这种问题 需要安装32位支持库 sudo apt-get install ia32-libs 安装这个库可能会提示找不到，安装不了 没有可用的软件包 ia32-libs，但是它被其它的软件包引用了。 这可能意味着这个缺失的软件包可能已被废弃， 或者只能在其他发布源中找到 然而下列软件包会取代它： lib32z1 E: 软件包 ia32-libs 没有可安装候选 根据错误提示安装下面这个这个库 sudo apt-get install lib32z1","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"卸载已安装的Qt","slug":"docs/操作系统/Linux/卸载已安装的Qt","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/xie-zai-yi-an-zhuang-de-qt/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/xie-zai-yi-an-zhuang-de-qt/","excerpt":"","text":"linux下卸载之前的qt4 打开终端，进入安装Qt的目录 运行命令 ./MaintenanceTool ​​​​​​​ 如果没有这个的话，则执行： sudo apt autoremove '.*qt4.*-dev' 还不行的话： rm /usr/lib/x86_64-linux-gnu/libQt* 安装Qt5 以安装qt5.9.9为例 从以下网址中下载qt安装包 Qt5.12.12下载 打开终端，输入以下命令赋予安装包权限 chmod -R 777 qtopensource-linux-x64-5.12.12.run 输入以下命令开始进行安装 ./qt-opensource-linux-x64-5.12.12.run 然后进入到安装页面，并且跟着提示一步一步走就好了（现在安装还要登录账户） 安装完成后不要马上打开qt软件，而是按照如下步骤配置环境变量 在终端输入以下命令 cd ls -a gedit ./bashrc 然后在.bashrc文件中添加如下内容 #其中下面第一行代码中的路劲是qt安装位置所对应的路径 #32位系统 export QTDIR=/opt/Qt5.12.12/5.12.12 export PATH=$QTDIR/gcc/bin:$PATH export LD_LIBRARY_PATH=$QTDIR/gcc/lib:$LD_LIBRARY_PATH #64位 export QTDIR=/opt/Qt5.12.12/5.12.12 export PATH=$QTDIR/gcc_64/bin:$PATH export LD_LIBRARY_PATH=$QTDIR/gcc_64/lib:$LD_LIBRARY_PATH 保存退出，执行以下命令让环境变量生效 source ~/.bashrc 输入以下命令，验证qt是否安装成功 qmake -version 如果出现qt信息则证明安装成功","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"安装Webmin","slug":"docs/操作系统/Linux/安装Webmin","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/an-zhuang-webmin/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/an-zhuang-webmin/","excerpt":"","text":"原文链接 在本教程中，我们将向您展示如何在香港服务器Linux Mint 20系统上安装Webmin。Webmin是用于管理VPS的免费控制面板。Webmin是基于Web的界面，用于管理VPS Web托管服务器。借助Webmin，您可以设置用户帐户，apache，DNS和文件共享以及其他操作。Webmin非常适合对Unix或Linux命令行不太了解的初学者。 步骤1.在运行以下教程之前，重要的是通过apt在终端中运行以下命令来确保系统是最新的： sudo apt update sudo apt install gnupg2 步骤2.在Linux Mint 20上安装Webmin。现在，我们在Linux Mint系统上添加新的Webmin存储库： sudo nano /etc/apt/sources.list 然后，将此行添加到文件底部以添加新的存储库： deb http://download.webmin.com/download/repository sarge contrib 启用存储库后，使用以下命令安装Webmin： wget -q -O- http://www.webmin.com/jcameron-key.asc | sudo apt-key add sudo apt update sudo apt install webmin 此过程将需要一些时间，具体取决于您的互联网速度。我建议您有耐心，不要强行关闭安装，否则将破坏安装。 步骤3.配置防火墙。默认情况下，Webmin侦听所有网络接口上端口10000上的连接。如果您的服务器运行UFW防火墙，则需要打开Webmin端口： sudo ufw allow 10000/tcp 步骤4.访问Webmin界面。最后，将Webmin安装在Linux Mint系统上，启动Web浏览器，然后输入服务器的域名或公共IP地址，然后带上Webmin端口10000：你的域名或者ip:10000至此，您已经成功安装了Webmin。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"安装Wine","slug":"docs/操作系统/Linux/安装Wine","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/linux/an-zhuang-wine/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/linux/an-zhuang-wine/","excerpt":"","text":"先得添加ubuntu-wine/ppa这个官方的源地址指令是： sudo add-apt-repository ppa:ubuntu-wine/ppa 当然，你如果直接开始安装也是可以的，但是不能获取到最新的wine哦！建议以上的操作。 再更新安装包安装包的更新指令是： sudo apt-get update ``` 安装wine1.8 sudo apt-get install wine1.8 第一步，在终端中使用如下命令，添加软件仓库并自动刷新缓存： wget -O- https://deepin-wine.i-m.dev/setup.sh | sh 软件仓库添加完毕，会提示使用 apt 命令即可安装微信、QQ 了，与安装 Linux 原生软件一样 第二步，在终端中使用 apt 命令安装微信、QQ 等软件，以下以微信为例。安装其他软件只需使用相应的软件名称即可。 sudo apt-get install com.qq.weixin.deepin 安装后需要注销重登录才能显示应用图标。 常用应用的软件包名如下 |应用 | 包名 |---- |----| |TIM |com.qq.office.deepin |QQ |com.qq.im.deepin |微信 |com.qq.weixin.deepin |钉钉 |com.dingtalk.deepin 完整列表见 https://deepin-wine.i-m.dev/","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Windows文件夹映射成硬盘","slug":"docs/操作系统/Windows/Windows文件夹映射成硬盘","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/windows/windows-wen-jian-jia-ying-she-cheng-ying-pan/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/windows/windows-wen-jian-jia-ying-she-cheng-ying-pan/","excerpt":"","text":"Windows文件夹映射成硬盘 方法一，使用命令 映射 将D:\\files文件夹映射为E:盘 subst e: d:\\files 取消映射 subst d: /d 虚拟盘符可以用h~z任意一个做盘符,不能用已有的盘符的名称,包括光驱盘符，否则会报错。 注意：这种映射重启电脑后会失效 方法二，使用共享文件夹映射网络驱动器 映射网络驱动器","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"win+R 运行命令","slug":"docs/操作系统/Windows/win+R 运行命令","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/windows/win-r-yun-xing-ming-ling/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/windows/win-r-yun-xing-ming-ling/","excerpt":"","text":"[TOC] win+R 运行命令 系统激活相关 查询操作系统版本 winver 查询操作系统版本、部分产品密钥、许可证状态等 slmgr.vbs -dli 查询系统是试用激活码还是永久激活码 slmgr.vbs -xpr","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"关闭Windows的下载目录的自动分组功能","slug":"docs/操作系统/Windows/关闭Windows的下载目录的自动分组功能","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/windows/guan-bi-windows-de-xia-zai-mu-lu-de-zi-dong-fen-zu-gong-neng/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/windows/guan-bi-windows-de-xia-zai-mu-lu-de-zi-dong-fen-zu-gong-neng/","excerpt":"","text":"关闭Windows的下载目录的自动分组功能 升级到 windows 11 后，下载目录总是会自动分组，手动关了之后，下次打开又会自动分组。这里通过修改注册表彻底关闭。 键盘快捷键(win+R)，打开运行输入regedit，注册表找到下面的内容： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderTypes\\{885a186e-a440-4ada-812b-db871b942259}\\TopViews\\{00000000-0000-0000-0000-000000000000} 修改右侧内容区域： GroupBy：从 System.DateModified 改为 System.Null SortByList：从 prop:System.DateModified 改为 prop:System.ItemNameDisplay 然后重启电脑 方法来自：如何彻底禁用 win10 资源管理器的分组依据功能 如果修改提示 写入值的新内容时出错，右键 {00000000-0000-0000-0000-000000000000} 项，选择 权限，弹出窗口中点击 高级，然后弹出窗口的左上角的 所有者，点击 更改。弹出的 选择用户或组 窗口中点击 高级 ，然后点击 立即找查 ，在搜索结果的选项中选择 Administrators ，确定之后就可以正常修改了。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"微软商店跳过系统代理","slug":"docs/操作系统/Windows/微软商店跳过系统代理","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/cao-zuo-xi-tong/windows/wei-ruan-shang-dian-tiao-guo-xi-tong-dai-li/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/cao-zuo-xi-tong/windows/wei-ruan-shang-dian-tiao-guo-xi-tong-dai-li/","excerpt":"","text":"一打开系统代理就无法使用微软商店了，解决办法配置Microsoft Store等软件绕过V2ray全局代理 管理员权限打开终端，执行 CheckNetIsolation.exe loopbackexempt -a -p=S-1-15-2-1609473798-1231923017-684268153-4268514328-882773646-2760585773-1760938157 完成","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"RecyclerView个性化设置","slug":"docs/Android/View/RecycleView/RecyclerView个性化设置","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/recycleview/recyclerview-ge-xing-hua-she-zhi/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/recycleview/recyclerview-ge-xing-hua-she-zhi/","excerpt":"","text":"属性 预览视图样式 tools:itemCount=\"13\" //预览item数量 tools:listitem=\"@layout/item_goal\" //预览item视图 tools:itemCount=\"5\" //线性布局item数量 tools:layoutManager=\"androidx.recyclerview.widget.GridLayoutManager\" //预览布局管理器 tools:spanCount=\"5\" //网格布局列数 滑动到底部时显示padding，滑动过程中不显示 android:clipToPadding=\"false\" android:paddingBottom=\"60dp\" 方法 加载item动画 @Override public void onBindViewHolder(@NonNull InnerHolder holder, int position) { holder.binding.getRoot().setAnimation(AnimationUtils.loadAnimation(holder.itemView.getContext(), R.anim.scale)); } 设置间距 SpaceItemDecoration dividerItemDecoration = new SpaceItemDecoration(16); binding.recyclerView.addItemDecoration(dividerItemDecoration); 加载更多 private boolean isLoading; binding.recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) { if (dy &lt;= 0) { return; } boolean slideToBottom = RecyclerViewUtils.isSlideToBottom(recyclerView); if (slideToBottom) { boolean nextPage = viewModel.getPagingResult().isNextPage(); if (nextPage &amp;&amp; !isLoading) { isLoading = true; binding.progressBar.setVisibility(View.VISIBLE); viewModel.loadFoodList(); } } } }); 判断滑动状态 是否到底部 protected boolean isSlideToBottom(RecyclerView recyclerView) { if (recyclerView == null) return false; return recyclerView.computeVerticalScrollExtent() + recyclerView.computeVerticalScrollOffset() &gt;= recyclerView.computeVerticalScrollRange(); } 流式布局 引入google流式布局google/flexbox-layout： Flexbox for Android (github.com)dependencies { implementation 'com.google.android.flexbox:flexbox:3.0.0' } 使用FlexboxLayoutManager manager = new FlexboxLayoutManager(requireContext()); binding.recyclerView.setLayoutManager(manager);","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"},{"name":"RecycleView","slug":"Android/View/RecycleView","permalink":"http://virogu.github.io/categories/Android/View/RecycleView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"Paging3相关","slug":"docs/Android/View/RecycleView/Paging3相关","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/recycleview/paging3-xiang-guan/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/recycleview/paging3-xiang-guan/","excerpt":"","text":"Paging局部修改数据 //转成LiveData private val _pagerData: MutableLiveData&lt;PagingData&lt;Item&gt;&gt; = repository.pagingData.cachedIn(viewModelScope).asLiveData().let { it as MutableLiveData&lt;PagingData&lt;Item&gt;&gt; } val pagerData: LiveData&lt;PagingData&lt;Item&gt;&gt; get() = _pagerData fun mod( old: Item, new: Item, ) { _pagerData.value?.map { if (it.id == old.id) { new } else { it } }.also { _pagerData.value = it } } 这里还有一个不修改数据源实现的示例 getRefreshKey示例 override fun getRefreshKey(state: PagingState&lt;Int, Item&gt;): Int? { return state.anchorPosition?.let { state.closestPageToPosition(it)?.prevKey?.plus(1) ?: state.closestPageToPosition(it)?.nextKey?.minus(1) } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"},{"name":"RecycleView","slug":"Android/View/RecycleView","permalink":"http://virogu.github.io/categories/Android/View/RecycleView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"RecycleView滑动删除","slug":"docs/Android/View/RecycleView/RecycleView滑动删除","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/recycleview/recycleview-hua-dong-shan-chu/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/recycleview/recycleview-hua-dong-shan-chu/","excerpt":"","text":"RecycleView实现滑动删除或拖动排序 ItemTouchHelper(object : ItemTouchHelper.Callback() { override fun getMovementFlags( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ): Int { return (viewHolder as? MyAdapter.MyHolder)?.data?.let { //dragFlags 拖拽的方式 //swipeFlags 滑动触发的方式 makeMovementFlags(0, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) } ?: makeMovementFlags(0, 0) } override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean = false override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (viewHolder as? MyAdapter.MyHolder)?.data?.let { //删除某一项的操作 //model.onViewEvent(ItemViewEvents.Remove(it.id)) } } }).attachToRecyclerView(recyclerView) 仿QQ侧滑删除示例","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"},{"name":"RecycleView","slug":"Android/View/RecycleView","permalink":"http://virogu.github.io/categories/Android/View/RecycleView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]},{"title":"RecycleView-Selection","slug":"docs/Android/View/RecycleView/RecycleView-Selection","date":"2023-08-31T12:00:00.000Z","updated":"2023-08-31T12:00:00.000Z","comments":true,"path":"2023/08/31/docs/android/view/recycleview/recycleview-selection/","link":"","permalink":"http://virogu.github.io/2023/08/31/docs/android/view/recycleview/recycleview-selection/","excerpt":"","text":"class AFragment : Fragment() { private lateinit var tracker: SelectionTracker&lt;Long&gt; override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) //...... adapter = MyAdapter() recyclerView.adapter = adapter recyclerView.setHasFixedSize(true) tracker = SelectionTracker.Builder&lt;Long&gt;( \"appt_unreviewed_selection\", recyclerView, MyAdapter.KeyProvider(recyclerView), MyAdapter.DetailsLookup(recyclerView), StorageStrategy.createLongStorage() ).withSelectionPredicate(MyAdapter.SelectionPredicate(recyclerView)).build() adapter.setSelectionTracker(tracker) tracker.addObserver(object : SelectionTracker.SelectionObserver&lt;Long&gt;() { override fun onSelectionRefresh() { super.onSelectionRefresh() adapter.refreshSelection() } override fun onSelectionChanged() { super.onSelectionChanged() val size = tracker.selection.size() } }) //...... } override fun onViewStateRestored(savedInstanceState: Bundle?) { super.onViewStateRestored(savedInstanceState) tracker.onRestoreInstanceState(savedInstanceState) } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) tracker.onSaveInstanceState(outState) } internal class MyAdapter( workerDispatcher: CoroutineDispatcher = Dispatchers.IO, ) : PagingDataAdapter&lt;Item, MyAdapter.MyHolder&gt;( diffCallback = COMPARATOR, workerDispatcher = workerDispatcher ) { //...... override fun onBindViewHolder(holder: VisitAppointHolder, position: Int) { holder.bindView(position, getData(position), PAYLOAD_ALL) } internal inner class MyHolder( itemView: View, val binding: ItemBinding ) : RecyclerView.ViewHolder(itemView) { private val details = ItemDetails() fun bindView( position: Int, data: Item?, payload: Set&lt;*&gt; ) { //val index = if (data == null) -position else position val key = if (data == null) -position.toLong() else position.toLong() details.setIndex(position) details.setKey(key) binding.tvNumber.tag = key // ..... } } class ItemDetails : ItemDetailsLookup.ItemDetails&lt;Long&gt;() { private var mIndex: Int = RecyclerView.NO_POSITION private var mKey: Long = -1 override fun getPosition(): Int { return mIndex } fun setIndex(index: Int) { this.mIndex = index } fun setKey(key: Long) { this.mKey = key } override fun getSelectionKey(): Long { return mKey } override fun inSelectionHotspot(e: MotionEvent): Boolean { return false } override fun inDragRegion(e: MotionEvent): Boolean { return mKey &gt;= 0 } } class DetailsLookup( private val recyclerView: RecyclerView ) : ItemDetailsLookup&lt;Long&gt;() { override fun getItemDetails(e: MotionEvent): ItemDetails&lt;Long&gt;? { val view = recyclerView.findChildViewUnder(e.x, e.y) val viewHolder = view?.let { try { recyclerView.getChildViewHolder(it) } catch (e: Throwable) { null } } if (viewHolder is MyAdapter.MyHolder) { return viewHolder.getItemDetails() } return null } } class KeyProvider( private val recyclerView: RecyclerView ) : ItemKeyProvider&lt;Long?&gt;(SCOPE_MAPPED) { override fun getKey(position: Int): Long? { if (position &lt; 0) return null val viewHolder = recyclerView.findViewHolderForAdapterPosition(position) if (viewHolder is MyAdapter.MyHolder) { return viewHolder.getItemDetails().selectionKey } return null } override fun getPosition(@NonNull key: Long): Int { return abs(key).toInt() } } class SelectionPredicate( private val recyclerView: RecyclerView ) : SelectionTracker.SelectionPredicate&lt;Long&gt;() { override fun canSetStateForKey(key: Long, nextState: Boolean): Boolean { if (!nextState) return true return key &gt;= 0 } override fun canSetStateAtPosition(position: Int, nextState: Boolean): Boolean { if (!nextState) return true if (position &lt; 0) return false val viewHolder = recyclerView.findViewHolderForAdapterPosition(position) if (viewHolder is MyAdapter.MyHolder) { return canSetStateForKey(viewHolder.getItemDetails().selectionKey, nextState) } return false } override fun canSelectMultiple(): Boolean = true } } }","categories":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"},{"name":"RecycleView","slug":"Android/View/RecycleView","permalink":"http://virogu.github.io/categories/Android/View/RecycleView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"}]}],"categories":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/categories/ADB/"},{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/categories/Git/"},{"name":"C","slug":"C","permalink":"http://virogu.github.io/categories/C/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/categories/Kotlin/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/categories/MarkDown/"},{"name":"Java","slug":"Java","permalink":"http://virogu.github.io/categories/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/categories/Gradle/"},{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/categories/ssh/"},{"name":"Others","slug":"Others","permalink":"http://virogu.github.io/categories/Others/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/categories/Android/"},{"name":"JNI","slug":"Android/JNI","permalink":"http://virogu.github.io/categories/Android/JNI/"},{"name":"工具类","slug":"Android/工具类","permalink":"http://virogu.github.io/categories/Android/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"View","slug":"Android/View","permalink":"http://virogu.github.io/categories/Android/View/"},{"name":"其他","slug":"Android/其他","permalink":"http://virogu.github.io/categories/Android/%E5%85%B6%E4%BB%96/"},{"name":"知识汇总","slug":"Android/知识汇总","permalink":"http://virogu.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"},{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"http://virogu.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"RecycleView","slug":"Android/View/RecycleView","permalink":"http://virogu.github.io/categories/Android/View/RecycleView/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://virogu.github.io/tags/ADB/"},{"name":"Git","slug":"Git","permalink":"http://virogu.github.io/tags/Git/"},{"name":"C","slug":"C","permalink":"http://virogu.github.io/tags/C/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://virogu.github.io/tags/Kotlin/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://virogu.github.io/tags/MarkDown/"},{"name":"Java","slug":"Java","permalink":"http://virogu.github.io/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"http://virogu.github.io/tags/Gradle/"},{"name":"ssh","slug":"ssh","permalink":"http://virogu.github.io/tags/ssh/"},{"name":"Others","slug":"Others","permalink":"http://virogu.github.io/tags/Others/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://virogu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Android","slug":"Android","permalink":"http://virogu.github.io/tags/Android/"},{"name":"操作系统","slug":"操作系统","permalink":"http://virogu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}