

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/resources/img/logo.png">
  <link rel="icon" href="/resources/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="未知">
  <meta name="keywords" content="">
  
    <meta name="description" content="OKHttp OKHttp请求流程 新建OKHttpClient客户端 同步请求流程 异步请求流程   网络请求缓存处理 连接池   Retrofit 基本使用流程 Retrofit构建过程 Retrofit核心对象解析 Builder内部构造 添加baseUrl 添加GsonConverterFactory build过程   创建网络请求接口实例过程 创建网络请求接口类实例并执行请求过程 R">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开源库源码分析">
<meta property="og:url" content="http://virogu.github.io/2023/08/24/docs/android/zhi-shi-hui-zong/android-kai-yuan-ku-yuan-ma-fen-xi/index.html">
<meta property="og:site_name" content="半漠清风">
<meta property="og:description" content="OKHttp OKHttp请求流程 新建OKHttpClient客户端 同步请求流程 异步请求流程   网络请求缓存处理 连接池   Retrofit 基本使用流程 Retrofit构建过程 Retrofit核心对象解析 Builder内部构造 添加baseUrl 添加GsonConverterFactory build过程   创建网络请求接口实例过程 创建网络请求接口类实例并执行请求过程 R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976154d56c224d96b33b1ca424e935a2~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab58d6242cc4fae96cd73eb198e325a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2478933d44534c2fabb6466049b9f3b7~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a307a034fea446a486c4f988849751a0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33114794d81a421ea4345806826919b7~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9da2924eeab4ef79249b5836fd916da~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ea30aea6034e939918d0da2b43c9d9~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0363331db824e7ab342e4bd74702a93~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ada0907b50b75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ada0907c082ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2023-08-24T12:00:00.000Z">
<meta property="article:modified_time" content="2023-08-24T12:00:00.000Z">
<meta property="article:author" content="Virogu">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976154d56c224d96b33b1ca424e935a2~tplv-k3u1fbpfcp-zoom-1.image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Android开源库源码分析 - 半漠清风</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"virogu.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="半漠清风" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 40vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>半漠清风</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android开源库源码分析</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        未知
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-24 20:00" pubdate>
          2023年8月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          185k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Android"
        id="heading-e84e30b9390cdb64db6db2c9ab87846d" role="tab" data-toggle="collapse" href="#collapse-e84e30b9390cdb64db6db2c9ab87846d"
        aria-expanded="true"
      >
        Android
        <span class="list-group-count">(34)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-e84e30b9390cdb64db6db2c9ab87846d"
           role="tabpanel" aria-labelledby="heading-e84e30b9390cdb64db6db2c9ab87846d">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="JNI"
        id="heading-4ceb3f5b846fa736acaada4c2f37a419" role="tab" data-toggle="collapse" href="#collapse-4ceb3f5b846fa736acaada4c2f37a419"
        aria-expanded="false"
      >
        JNI
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-4ceb3f5b846fa736acaada4c2f37a419"
           role="tabpanel" aria-labelledby="heading-4ceb3f5b846fa736acaada4c2f37a419">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/30/docs/android/jni/jni-zhong-da-yin-androidlog/" title="JNI中打印AndroidLog"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">JNI中打印AndroidLog</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="View"
        id="heading-4351cfebe4b61d8aa5efa1d020710005" role="tab" data-toggle="collapse" href="#collapse-4351cfebe4b61d8aa5efa1d020710005"
        aria-expanded="false"
      >
        View
        <span class="list-group-count">(12)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-4351cfebe4b61d8aa5efa1d020710005"
           role="tabpanel" aria-labelledby="heading-4351cfebe4b61d8aa5efa1d020710005">
        
        
          
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/27/docs/android/view/edittext/" title="EditText属性配置"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">EditText属性配置</span>
        </a>
      
    
      
      
        <a href="/2023/08/27/docs/android/view/textview-shu-xing/" title="TextView属性"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">TextView属性</span>
        </a>
      
    
      
      
        <a href="/2023/08/27/docs/android/view/textview-xian-zhi-shu-ru-nei-rong/" title="TextView限制输入内容"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">TextView限制输入内容</span>
        </a>
      
    
      
      
        <a href="/2023/08/27/docs/android/view/radiobutton/" title="RadioButton属性"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">RadioButton属性</span>
        </a>
      
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="CustomView"
        id="heading-e4ab316ef21a84809676e0065a208779" role="tab" data-toggle="collapse" href="#collapse-e4ab316ef21a84809676e0065a208779"
        aria-expanded="false"
      >
        CustomView
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-e4ab316ef21a84809676e0065a208779"
           role="tabpanel" aria-labelledby="heading-e4ab316ef21a84809676e0065a208779">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/29/docs/android/view/customview/animeview/" title="AnimeView"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">AnimeView</span>
        </a>
      
    
      
      
        <a href="/2023/08/29/docs/android/view/customview/customradiogroup/" title="自定义RadioGroup"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">自定义RadioGroup</span>
        </a>
      
    
      
      
        <a href="/2023/08/29/docs/android/view/customview/ipeditortext/" title="IP输入框控件"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">IP输入框控件</span>
        </a>
      
    
      
      
        <a href="/2023/08/29/docs/android/view/customview/verticalseekbar/" title="垂直SeekBar,VerticalSeekBar"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">垂直SeekBar,VerticalSeekBar</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="RecycleView"
        id="heading-125499de79f8c3dbffe1583ac986cca3" role="tab" data-toggle="collapse" href="#collapse-125499de79f8c3dbffe1583ac986cca3"
        aria-expanded="false"
      >
        RecycleView
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-125499de79f8c3dbffe1583ac986cca3"
           role="tabpanel" aria-labelledby="heading-125499de79f8c3dbffe1583ac986cca3">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/28/docs/android/view/recycleview/paging3-xiang-guan/" title="Paging3相关"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Paging3相关</span>
        </a>
      
    
      
      
        <a href="/2023/08/28/docs/android/view/recycleview/recycleview-selection/" title="RecycleView多选功能示例，RecycleView-Selection"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">RecycleView多选功能示例，RecycleView-Selection</span>
        </a>
      
    
      
      
        <a href="/2023/08/28/docs/android/view/recycleview/recyclerview-ge-xing-hua-she-zhi/" title="RecyclerView个性化设置"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">RecyclerView个性化设置</span>
        </a>
      
    
      
      
        <a href="/2023/08/28/docs/android/view/recycleview/recycleview-hua-dong-shan-chu/" title="RecycleView滑动删除"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">RecycleView滑动删除</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="其他"
        id="heading-0d98c74797e49d00bcc4c17c9d557a2b" role="tab" data-toggle="collapse" href="#collapse-0d98c74797e49d00bcc4c17c9d557a2b"
        aria-expanded="false"
      >
        其他
        <span class="list-group-count">(11)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-0d98c74797e49d00bcc4c17c9d557a2b"
           role="tabpanel" aria-labelledby="heading-0d98c74797e49d00bcc4c17c9d557a2b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/androidsamples/" title="AndroidSamples"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">AndroidSamples</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/contentresolver/" title="ContentResolver"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">ContentResolver</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/android-mu-lu-wen-jian-jian-xi/" title="Android目录文件简析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Android目录文件简析</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/webrtc-bian-yi/" title="WebRTC编译"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">WebRTC编译</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/cha-kan-apk-qian-ming-xin-xi/" title="查看Apk签名信息"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">查看Apk签名信息</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/an-zhuo-za-ji/" title="安卓杂记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">安卓杂记</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/xi-tong-xin-xi-huo-qu/" title="系统信息获取"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统信息获取</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/xi-tong-guang-bo/" title="系统广播"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统广播</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/qing-qiu-hu-lue-dian-chi-you-hua/" title="请求忽略电池优化"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">请求忽略电池优化</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/xi-tong-ti-gong-de-activity/" title="系统提供的Activity"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统提供的Activity</span>
        </a>
      
    
      
      
        <a href="/2023/08/26/docs/android/qi-ta/ruan-jian-pan-xiang-guan-cao-zuo/" title="软键盘相关操作"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">软键盘相关操作</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="工具类"
        id="heading-a72d8a4ca7a7e4637cefc70e4ba0b248" role="tab" data-toggle="collapse" href="#collapse-a72d8a4ca7a7e4637cefc70e4ba0b248"
        aria-expanded="false"
      >
        工具类
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-a72d8a4ca7a7e4637cefc70e4ba0b248"
           role="tabpanel" aria-labelledby="heading-a72d8a4ca7a7e4637cefc70e4ba0b248">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/25/docs/android/gong-ju-lei/tu-pian-cao-zuo-xuan-zhuan-suo-fang-xiang-hu-zhuan-hua/" title="常用图片操作（旋转、缩放、相互转化等）"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">常用图片操作（旋转、缩放、相互转化等）</span>
        </a>
      
    
      
      
        <a href="/2023/08/25/docs/android/gong-ju-lei/an-zhuo-jing-mo-an-zhuang-ruan-jian/" title="安卓静默安装软件"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">安卓静默安装软件</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="知识汇总"
        id="heading-4514693aa4a351141269d9ac95460bcf" role="tab" data-toggle="collapse" href="#collapse-4514693aa4a351141269d9ac95460bcf"
        aria-expanded="true"
      >
        知识汇总
        <span class="list-group-count">(7)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4514693aa4a351141269d9ac95460bcf"
           role="tabpanel" aria-labelledby="heading-4514693aa4a351141269d9ac95460bcf">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/android-kuo-zhan-zhi-shi-dian/" title="Android扩展知识点"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Android扩展知识点</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/android-zhi-shi-dian-hui-zong/" title="Android知识点汇总"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Android知识点汇总</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/chang-jian-mian-shi-suan-fa-ti-hui-zong/" title="常见面试算法题汇总"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">常见面试算法题汇总</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/she-ji-mo-shi-hui-zong/" title="设计模式汇总"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">设计模式汇总</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/ji-suan-ji-wang-luo-ji-chu/" title="计算机网络基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机网络基础</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/xing-neng-you-hua-zhi-shi-dian-hui-zong/" title="性能优化知识点汇总"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">性能优化知识点汇总</span>
        </a>
      
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-hui-zong/android-kai-yuan-ku-yuan-ma-fen-xi/" title="Android开源库源码分析"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Android开源库源码分析</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="知识笔记"
        id="heading-fc9ad1f315fb8be2c77447125c171f0f" role="tab" data-toggle="collapse" href="#collapse-fc9ad1f315fb8be2c77447125c171f0f"
        aria-expanded="false"
      >
        知识笔记
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-fc9ad1f315fb8be2c77447125c171f0f"
           role="tabpanel" aria-labelledby="heading-fc9ad1f315fb8be2c77447125c171f0f">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/24/docs/android/zhi-shi-bi-ji/yi-xie-livedata-nian-xing-shi-jian-jie-jue-fang-an/" title="一些LiveData粘性事件解决方案"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">一些LiveData粘性事件解决方案</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android开源库源码分析</h1>
            
            
              <div class="markdown-body">
                
                <ul>
<li><a href="#OKHttp">OKHttp</a><ul>
<li><a href="#OKHttp%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">OKHttp请求流程</a><ul>
<li><a href="#%E6%96%B0%E5%BB%BAOKHttpClient%E5%AE%A2%E6%88%B7%E7%AB%AF">新建OKHttpClient客户端</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">同步请求流程</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">异步请求流程</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E4%B9%8BCacheInterceptor">网络请求缓存处理</a></li>
<li><a href="#ConnectInterceptor%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%B1%A0">连接池</a></li>
</ul>
</li>
<li><a href="#Retrofit">Retrofit</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">基本使用流程</a></li>
<li><a href="#Retrofit%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">Retrofit构建过程</a><ul>
<li><a href="#Retrofit%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%90">Retrofit核心对象解析</a></li>
<li><a href="#Builder%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0">Builder内部构造</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0baseUrl">添加baseUrl</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0GsonConverterFactory">添加GsonConverterFactory</a></li>
<li><a href="#build%E8%BF%87%E7%A8%8B">build过程</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E8%BF%87%E7%A8%8B">创建网络请求接口实例过程</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%B9%B6%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">创建网络请求接口类实例并执行请求过程</a></li>
<li><a href="#Retrofit%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%9B%BE">Retrofit源码流程图</a></li>
</ul>
</li>
<li><a href="#Glide">Glide</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B-1">基本使用流程</a></li>
<li><a href="#GlideAppwithcontext%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">GlideApp.with(context)源码详解</a></li>
<li><a href="#loadurl%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">load(url)源码详解</a></li>
<li><a href="#intoiv%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">into(iv)源码详解</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4Glide%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%9B%BE">完整Glide加载流程图</a></li>
</ul>
</li>
<li><a href="#GreenDao">GreenDao</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B-2">基本使用流程</a></li>
<li><a href="#GreenDao%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">GreenDao使用流程分析</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%AE%E5%8A%A9%E7%B1%BB%E5%AF%B9%E8%B1%A1DaoMasterDevOpenHelper">创建数据库帮助类对象DaoMaster.DevOpenHelper</a></li>
<li><a href="#%E5%88%9B%E5%BB%BADaoMaster%E5%AF%B9%E8%B1%A1">创建DaoMaster对象</a></li>
<li><a href="#%E5%88%9B%E5%BB%BADaoSession%E5%AF%B9%E8%B1%A1">创建DaoSession对象</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">插入源码分析</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">查询源码分析</a></li>
</ul>
</li>
<li><a href="#GreenDao%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8EReactiveX%E7%BB%93%E5%90%88">GreenDao是如何与ReactiveX结合？</a></li>
</ul>
</li>
<li><a href="#RxJava">RxJava</a><ul>
<li><a href="#RxJava%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">RxJava是什么？</a></li>
<li><a href="#RxJava%E7%9A%84%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B">RxJava的订阅流程</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85%E8%BF%87%E7%A8%8B">创建被观察者过程</a></li>
<li><a href="#%E8%AE%A2%E9%98%85%E8%BF%87%E7%A8%8B">订阅过程</a></li>
</ul>
</li>
<li><a href="#RxJava%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2">RxJava的线程切换</a></li>
</ul>
</li>
<li><a href="#LeakCanary">LeakCanary</a><ul>
<li><a href="#%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0">原理概述</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">简单示例</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a></li>
<li><a href="#LeakCanary%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B">LeakCanary运作流程</a></li>
</ul>
</li>
<li><a href="#ButterKnife">ButterKnife</a><ul>
<li><a href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-1">简单示例</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1">源码分析</a><ul>
<li><a href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">模板代码解析</a></li>
<li><a href="#ButterKnife-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E7%9A%84">ButterKnife 是怎样实现代码注入的</a></li>
<li><a href="#ButterKnife%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84">ButterKnife是如何在编译时生成代码的？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Dagger-2">Dagger 2</a><ul>
<li><a href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">预备知识</a><ul>
<li><a href="#@Inject">@Inject</a></li>
<li><a href="#@Module">@Module</a></li>
<li><a href="#@Singleton">@Singleton</a></li>
<li><a href="#@Providers">@Providers</a></li>
<li><a href="#@Component">@Component</a></li>
<li><a href="#@Scope">@Scope</a></li>
<li><a href="#@Qualifier">@Qualifier</a></li>
<li><a href="#dependencies">dependencies</a></li>
<li><a href="#@SubComponent">@SubComponent</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-2">简单示例</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2">源码分析</a></li>
</ul>
</li>
<li><a href="#EventBus">EventBus</a><ul>
<li><a href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-3">简单示例</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3">源码分析</a></li>
</ul>
</li>
</ul>
<h1 id="OKHttp"><a href="#OKHttp" class="headerlink" title="OKHttp"></a>OKHttp</h1><h2 id="OKHttp请求流程"><a href="#OKHttp请求流程" class="headerlink" title="OKHttp请求流程"></a>OKHttp请求流程</h2><p>OKHttp内部的大致请求流程图如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976154d56c224d96b33b1ca424e935a2~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<p>如下为使用OKHttp进行Get请求的步骤：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.新建OKHttpClient客户端</span><br>OkHttpClient client = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OkHttpClient()</span>;<br><span class="hljs-comment">//新建一个Request对象</span><br>Request request = <span class="hljs-keyword">new</span> Request.<span class="hljs-constructor">Builder()</span><br>        .url(url)<br>        .build<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//2.Response为OKHttp中的响应</span><br>Response response = client.<span class="hljs-keyword">new</span><span class="hljs-constructor">Call(<span class="hljs-params">request</span>)</span>.execute<span class="hljs-literal">()</span>;<br></code></pre></td></tr></tbody></table></figure>

<h3 id="新建OKHttpClient客户端"><a href="#新建OKHttpClient客户端" class="headerlink" title="新建OKHttpClient客户端"></a>新建OKHttpClient客户端</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">OkHttpClient client = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OkHttpClient()</span>;<br><br>public <span class="hljs-constructor">OkHttpClient()</span> {<br>    this(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Builder()</span>);<br>}<br><br><span class="hljs-constructor">OkHttpClient(Builder <span class="hljs-params">builder</span>)</span> {<br>    ....<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，OkHttpClient使用了建造者模式，Builder里面的可配置参数如下：</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>{<br>    Dispatcher dispatcher;<span class="hljs-comment">// 分发器</span><br>    <span class="hljs-meta">@Nullable</span> Proxy proxy;<br>    List&lt;Protocol&gt; protocols;<br>    List&lt;ConnectionSpec&gt; connectionSpecs;<span class="hljs-comment">// 传输层版本和连接协议</span><br>    <span class="hljs-keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">// 拦截器</span><br>    <span class="hljs-keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    EventListener.Factory eventListenerFactory;<br>    ProxySelector proxySelector;<br>    CookieJar cookieJar;<br>    <span class="hljs-meta">@Nullable</span> Cache cache;<br>    <span class="hljs-meta">@Nullable</span> InternalCache internalCache;<span class="hljs-comment">// 内部缓存</span><br>    SocketFactory socketFactory;<br>    <span class="hljs-meta">@Nullable</span> SSLSocketFactory sslSocketFactory;<span class="hljs-comment">// 安全套接层socket 工厂，用于HTTPS</span><br>    <span class="hljs-meta">@Nullable</span> CertificateChainCleaner certificateChainCleaner;<span class="hljs-comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span><br>    HostnameVerifier hostnameVerifier;<span class="hljs-comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。  </span><br>    CertificatePinner certificatePinner;<span class="hljs-comment">// 证书锁定，使用CertificatePinner来约束哪些认证机构被信任。</span><br>    Authenticator proxyAuthenticator;<span class="hljs-comment">// 代理身份验证</span><br>    Authenticator authenticator;<span class="hljs-comment">// 身份验证</span><br>    ConnectionPool connectionPool;<span class="hljs-comment">// 连接池</span><br>    Dns dns;<br>    <span class="hljs-keyword">boolean</span> followSslRedirects; <span class="hljs-comment">// 安全套接层重定向</span><br>    <span class="hljs-keyword">boolean</span> followRedirects;<span class="hljs-comment">// 本地重定向</span><br>    <span class="hljs-keyword">boolean</span> retryOnConnectionFailure;<span class="hljs-comment">// 重试连接失败</span><br>    <span class="hljs-keyword">int</span> callTimeout;<br>    <span class="hljs-keyword">int</span> connectTimeout;<br>    <span class="hljs-keyword">int</span> readTimeout;<br>    <span class="hljs-keyword">int</span> writeTimeout;<br>    <span class="hljs-keyword">int</span> pingInterval;<br><br>    <span class="hljs-comment">// 这里是默认配置的构建参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>{<br>        dispatcher = <span class="hljs-keyword">new</span> Dispatcher();<br>        protocols = DEFAULT_PROTOCOLS;<br>        connectionSpecs = DEFAULT_CONNECTION_SPECS;<br>        ...<br>    }<br><br>    <span class="hljs-comment">// 这里传入自己配置的构建参数</span><br>    Builder(OkHttpClient okHttpClient) {<br>        <span class="hljs-keyword">this</span>.dispatcher = okHttpClient.dispatcher;<br>        <span class="hljs-keyword">this</span>.proxy = okHttpClient.proxy;<br>        <span class="hljs-keyword">this</span>.protocols = okHttpClient.protocols;<br>        <span class="hljs-keyword">this</span>.connectionSpecs = okHttpClient.connectionSpecs;<br>        <span class="hljs-keyword">this</span>.interceptors.addAll(okHttpClient.interceptors);<br>        <span class="hljs-keyword">this</span>.networkInterceptors.addAll(okHttpClient.networkInterceptors);<br>        ...<br>    }<br></code></pre></td></tr></tbody></table></figure>

<h3 id="同步请求流程"><a href="#同步请求流程" class="headerlink" title="同步请求流程"></a>同步请求流程</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Prepares the {<span class="hljs-doctag">@code</span> request} to be executed at   some point in the future.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Call <span class="hljs-title function_">newCall</span><span class="hljs-params">(Request request)</span> {<br>    <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-built_in">this</span>, request, <span class="hljs-literal">false</span> <span class="hljs-comment">/* for web socket */</span>);<br>}<br><br><span class="hljs-comment">// RealCall为真正的请求执行者</span><br><span class="hljs-keyword">static</span> RealCall <span class="hljs-title function_">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-type">boolean</span> forWebSocket)</span> {<br>    <span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span><br>    <span class="hljs-type">RealCall</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealCall</span>(client, originalRequest, forWebSocket);<br>    call.eventListener = client.eventListenerFactory().create(call);<br>    <span class="hljs-keyword">return</span> call;<br>}<br><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {<br>        <span class="hljs-comment">// 每个Call只能执行一次</span><br>        <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"Already Executed"</span>);<br>        executed = <span class="hljs-literal">true</span>;<br>    }<br>    captureCallStackTrace();<br>    timeout.enter();<br>    eventListener.callStart(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 通知dispatcher已经进入执行状态</span><br>        client.dispatcher().executed(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 通过一系列的拦截器请求处理和响应处理得到最终的返回结果</span><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getResponseWithInterceptorChain();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"Canceled"</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    } <span class="hljs-keyword">catch</span> (IOException e) {<br>        e = timeoutExit(e);<br>        eventListener.callFailed(<span class="hljs-built_in">this</span>, e);<br>        <span class="hljs-keyword">throw</span> e;<br>    } <span class="hljs-keyword">finally</span> {<br>        <span class="hljs-comment">// 通知 dispatcher 自己已经执行完毕</span><br>        client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>    }<br>}<br><br>Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 在配置 OkHttpClient 时设置的 interceptors；</span><br>    interceptors.addAll(client.interceptors());<br>    <span class="hljs-comment">// 负责失败重试以及重定向</span><br>    interceptors.add(retryAndFollowUpInterceptor);<br>    <span class="hljs-comment">// 请求时，对必要的Header进行一些添加，接收响应时，移除必要的Header</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>    <span class="hljs-comment">// 负责读取缓存直接返回、更新缓存</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>    <span class="hljs-comment">// 负责和服务器建立连接</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) {<br>        <span class="hljs-comment">// 配置 OkHttpClient 时设置的 networkInterceptors</span><br>        interceptors.addAll(client.networkInterceptors());<br>    }<br>    <span class="hljs-comment">// 负责向服务器发送请求数据、从服务器读取响应数据</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br><br>    Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>,<br>        originalRequest, <span class="hljs-built_in">this</span>, eventListener, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-comment">// 使用责任链模式开启链式调用</span><br>    <span class="hljs-keyword">return</span> chain.proceed(originalRequest);<br>}<br><br><span class="hljs-comment">// StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流</span><br><span class="hljs-comment">// 和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="hljs-params">  RealConnection connection)</span> <span class="hljs-keyword">throws</span> IOException {<br>    ...<br><br>    <span class="hljs-comment">// Call the next interceptor in the chain.</span><br>    <span class="hljs-comment">// 实例化下一个拦截器对应的RealIterceptorChain对象</span><br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, streamAllocation, httpCodec,<br>        connection, index + <span class="hljs-number">1</span>, request, call, eventListener, connectTimeout, readTimeout,<br>        writeTimeout);<br>    <span class="hljs-comment">// 得到当前的拦截器</span><br>    <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>    <span class="hljs-comment">// 调用当前拦截器的intercept()方法，并将下一个拦截器的RealIterceptorChain对象传递下去,最后得到响应</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br><br>    ...<br>    <br>    <span class="hljs-keyword">return</span> response;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="异步请求流程"><a href="#异步请求流程" class="headerlink" title="异步请求流程"></a>异步请求流程</h3><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>    .url(<span class="hljs-string">"http://publicobject.com/helloworld.txt"</span>)<br>    .build();<br><br>client.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {<br>    @Override <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onFailure(<span class="hljs-keyword">Call</span> <span class="hljs-keyword">call</span>, IOException e) {<br>      e.printStackTrace();<br>    }<br><br>    @Override <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResponse(<span class="hljs-keyword">Call</span> <span class="hljs-keyword">call</span>, Response response) <span class="hljs-keyword">throws</span> IOException {<br>        ...<br>    }<br>    <br><span class="hljs-keyword">void</span> enqueue(AsyncCall <span class="hljs-keyword">call</span>) {<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>        readyAsyncCalls.add(<span class="hljs-keyword">call</span>);<br>    }<br>    promoteAndExecute();<br>}<br><br><span class="hljs-comment">// 正在准备中的异步请求队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br><span class="hljs-comment">// 运行中的异步请求</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br><span class="hljs-comment">// 同步请求</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br><span class="hljs-comment">// Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs</span><br><span class="hljs-comment">// them on the executor service. Must not be called with synchronization because executing calls</span><br><span class="hljs-comment">// can call into user code.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> promoteAndExecute() {<br>    assert (!Thread.holdsLock(<span class="hljs-keyword">this</span>));<br><br>    List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span> isRunning;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>      <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {<br>        AsyncCall asyncCall = i.<span class="hljs-keyword">next</span>();<br><br>        <span class="hljs-comment">// 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行，</span><br>        <span class="hljs-comment">// 同时利用线程池执行call；否者将call加入到readyAsyncCalls中。</span><br>        <span class="hljs-keyword">if</span> (runningAsyncCalls.<span class="hljs-keyword">size</span>() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span><br>        <span class="hljs-keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span><br><br>        i.remove();<br>        executableCalls.add(asyncCall);<br>        runningAsyncCalls.add(asyncCall);<br>      }<br>      isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-keyword">size</span> = executableCalls.<span class="hljs-keyword">size</span>(); i &lt; <span class="hljs-keyword">size</span>; i++) {<br>      AsyncCall asyncCall = executableCalls.get(i);<br>      asyncCall.executeOn(executorService());<br>    }<br><br>    <span class="hljs-keyword">return</span> isRunning;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最后，我们在看看AsynCall的代码。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncCall</span> <span class="hljs-title">extends</span> <span class="hljs-title">NamedRunnable</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;<br><br>    AsyncCall(Callback responseCallback) {<br>      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());<br>      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;<br>    }<br><br>    String host() {<br>      <span class="hljs-keyword">return</span> originalRequest.url().host();<br>    }<br><br>    Request request() {<br>      <span class="hljs-keyword">return</span> originalRequest;<br>    }<br><br>    RealCall <span class="hljs-keyword">get</span>() {<br>      <span class="hljs-keyword">return</span> RealCall.<span class="hljs-keyword">this</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Attempt to enqueue this async call on {<span class="hljs-doctag">@code</span>    executorService}. This will attempt to clean up</span><br><span class="hljs-comment">     * if the executor has been shut down by reporting    the call as failed.</span><br><span class="hljs-comment">     */</span><br>    void executeOn(ExecutorService executorService) {<br>      assert (!Thread.holdsLock(client.dispatcher()));<br>      boolean success = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">try</span> {<br>        executorService.execute(<span class="hljs-keyword">this</span>);<br>        success = <span class="hljs-literal">true</span>;<br>      } <span class="hljs-keyword">catch</span> (RejectedExecutionException e) {<br>        InterruptedIOException ioException = new InterruptedIOException(<span class="hljs-string">"executor rejected"</span>);<br>        ioException.initCause(e);<br>        eventListener.callFailed(RealCall.<span class="hljs-keyword">this</span>, ioException);<br>        responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, ioException);<br>      } <span class="hljs-keyword">finally</span> {<br>        <span class="hljs-keyword">if</span> (!success) {<br>          client.dispatcher().finished(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// This call is no longer running!</span><br>        }<br>      }<br>    }<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> void execute() {<br>      boolean signalledCallback = <span class="hljs-literal">false</span>;<br>      timeout.enter();<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 跟同步执行一样，最后都会调用到这里</span><br>        Response response = getResponseWithInterceptorChain();<br>        <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) {<br>          signalledCallback = <span class="hljs-literal">true</span>;<br>          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, new   IOException(<span class="hljs-string">"Canceled"</span>));<br>        } <span class="hljs-keyword">else</span> {<br>          signalledCallback = <span class="hljs-literal">true</span>;<br>          responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>,   response);<br>        }<br>      } <span class="hljs-keyword">catch</span> (IOException e) {<br>        e = timeoutExit(e);<br>        <span class="hljs-keyword">if</span> (signalledCallback) {<br>          <span class="hljs-comment">// Do not signal the callback twice!</span><br>          Platform.<span class="hljs-keyword">get</span>().log(INFO, <span class="hljs-string">"Callback failure   for "</span> + toLoggableString(), e);<br>        } <span class="hljs-keyword">else</span> {<br>          eventListener.callFailed(RealCall.<span class="hljs-keyword">this</span>, e);<br>          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);<br>        }<br>      } <span class="hljs-keyword">finally</span> {<br>        client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>      }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从上面的源码可以知道，拦截链的处理OKHttp帮我们默认做了五步拦截处理，其中RetryAndFollowUpInterceptor、BridgeInterceptor、CallServerInterceptor内部的源码很简洁易懂，此处不再多说。</p>
<h2 id="网络请求缓存处理之CacheInterceptor"><a href="#网络请求缓存处理之CacheInterceptor" class="headerlink" title="网络请求缓存处理之CacheInterceptor"></a>网络请求缓存处理之CacheInterceptor</h2><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override public Response intercept(Chain chain) throws IOException {<br>    <span class="hljs-comment">// 根据request得到cache中缓存的response</span><br>    Response cacheCandidate = cache != null<br>        ? cache.get(chain.request<span class="hljs-literal">()</span>)<br>        : null;<br><br>    long now = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br><br>    <span class="hljs-comment">// request判断缓存的策略，是否要使用了网络，缓存或两者都使用</span><br>    CacheStrategy strategy = <span class="hljs-keyword">new</span> CacheStrategy.<span class="hljs-constructor">Factory(<span class="hljs-params">now</span>, <span class="hljs-params">chain</span>.<span class="hljs-params">request</span>()</span>,     cacheCandidate).get<span class="hljs-literal">()</span>;<br>    Request networkRequest = strategy.networkRequest;<br>    Response cacheResponse = strategy.cacheResponse;<br><br>    <span class="hljs-keyword">if</span> (cache != null) {<br>      cache.track<span class="hljs-constructor">Response(<span class="hljs-params">strategy</span>)</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (cacheCandidate != null<span class="hljs-operator"> &amp;&amp; </span>cacheResponse<span class="hljs-operator"> == </span>null) {<br>      close<span class="hljs-constructor">Quietly(<span class="hljs-params">cacheCandidate</span>.<span class="hljs-params">body</span>()</span>); <span class="hljs-comment">// The cache   candidate wasn't applicable. Close it.</span><br>    }<br><br>    <span class="hljs-comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span><br>    <span class="hljs-keyword">if</span> (networkRequest<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>cacheResponse<span class="hljs-operator"> == </span>null) {<br>      return <span class="hljs-keyword">new</span> Response.<span class="hljs-constructor">Builder()</span><br>          .request(chain.request<span class="hljs-literal">()</span>)<br>          .protocol(Protocol.HTTP_1_1)<br>          .code(<span class="hljs-number">504</span>)<br>          .message(<span class="hljs-string">"Unsatisfiable Request (only-if-cached)"</span>)<br>          .body(Util.EMPTY_RESPONSE)<br>          .sent<span class="hljs-constructor">RequestAtMillis(-1L)</span><br>          .received<span class="hljs-constructor">ResponseAtMillis(System.<span class="hljs-params">currentTimeMillis</span>()</span>)<br>          .build<span class="hljs-literal">()</span>;<br>    }<br><br>    <span class="hljs-comment">// If we don't need the network, we're done.</span><br>    <span class="hljs-keyword">if</span> (networkRequest<span class="hljs-operator"> == </span>null) {<br>      return cacheResponse.<span class="hljs-keyword">new</span><span class="hljs-constructor">Builder()</span><br>          .cache<span class="hljs-constructor">Response(<span class="hljs-params">stripBody</span>(<span class="hljs-params">cacheResponse</span>)</span>)<br>          .build<span class="hljs-literal">()</span>;<br>    }<br><br>    Response networkResponse = null;<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 调用下一个拦截器，决定从网络上来得到response</span><br>        networkResponse = chain.proceed(networkRequest);<br>    } finally {<br>        <span class="hljs-comment">// If we're crashing on I/O or otherwise,   don't leak the cache body.</span><br>        <span class="hljs-keyword">if</span> (networkResponse<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>cacheCandidate != null) {<br>          close<span class="hljs-constructor">Quietly(<span class="hljs-params">cacheCandidate</span>.<span class="hljs-params">body</span>()</span>);<br>        }<br>    }<br><br>    <span class="hljs-comment">// If we have a cache response too, then we're doing a conditional get.</span><br>    <span class="hljs-comment">// 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse</span><br>    <span class="hljs-keyword">if</span> (cacheResponse != null) {<br>        <span class="hljs-keyword">if</span> (networkResponse.code<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>HTTP_NOT_MODIFIED)   {<br>          Response response = cacheResponse.<span class="hljs-keyword">new</span><span class="hljs-constructor">Builder()</span><br>                  .headers(combine(cacheResponse.headers<span class="hljs-literal">()</span>, networkResponse.headers<span class="hljs-literal">()</span>))<br>                  .sent<span class="hljs-constructor">RequestAtMillis(<span class="hljs-params">networkResponse</span>.<span class="hljs-params">sentRequestAtMillis</span>()</span>)<br>                  .received<span class="hljs-constructor">ResponseAtMillis(<span class="hljs-params">networkResponse</span>.<span class="hljs-params">receivedResponseAtMillis</span>()</span>)<br>                  .cache<span class="hljs-constructor">Response(<span class="hljs-params">stripBody</span>(<span class="hljs-params">cacheResponse</span>)</span>)<br>                  .network<span class="hljs-constructor">Response(<span class="hljs-params">stripBody</span>(<span class="hljs-params">networkResponse</span>)</span>)<br>              .build<span class="hljs-literal">()</span>;<br>          networkResponse.body<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>;<br>    <br>          <span class="hljs-comment">// Update the cache after combining headers but before stripping the</span><br>          <span class="hljs-comment">// Content-Encoding header (as performed by initContentStream()).</span><br>          cache.track<span class="hljs-constructor">ConditionalCacheHit()</span>;<br>          cache.update(cacheResponse, response);<br>          return response;<br>        } <span class="hljs-keyword">else</span> {<br>          close<span class="hljs-constructor">Quietly(<span class="hljs-params">cacheResponse</span>.<span class="hljs-params">body</span>()</span>);<br>        }<br>    }<br><br>    Response response = networkResponse.<span class="hljs-keyword">new</span><span class="hljs-constructor">Builder()</span><br>        .cache<span class="hljs-constructor">Response(<span class="hljs-params">stripBody</span>(<span class="hljs-params">cacheResponse</span>)</span>)<br>        .network<span class="hljs-constructor">Response(<span class="hljs-params">stripBody</span>(<span class="hljs-params">networkResponse</span>)</span>)<br>        .build<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-keyword">if</span> (cache != null) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpHeaders</span>.</span></span>has<span class="hljs-constructor">Body(<span class="hljs-params">response</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CacheStrategy</span>.</span></span>is<span class="hljs-constructor">Cacheable(<span class="hljs-params">response</span>,   <span class="hljs-params">networkRequest</span>)</span>) {<br>        <span class="hljs-comment">// Offer this request to the cache.</span><br>        <span class="hljs-comment">// 缓存未经缓存过的response</span><br>        CacheRequest cacheRequest = cache.put(response);<br>        return cache<span class="hljs-constructor">WritingResponse(<span class="hljs-params">cacheRequest</span>, <span class="hljs-params">response</span>)</span>;<br>      }<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpMethod</span>.</span></span>invalidates<span class="hljs-constructor">Cache(<span class="hljs-params">networkRequest</span>.<span class="hljs-params">method</span>()</span>)) {<br>        <span class="hljs-keyword">try</span> {<br>          cache.remove(networkRequest);<br>        } catch (IOException ignored) {<br>          <span class="hljs-comment">// The cache cannot be written.</span><br>        }<br>      }<br>    }<br><br>    return response;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存给用户，否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。</p>
<h2 id="ConnectInterceptor之连接池"><a href="#ConnectInterceptor之连接池" class="headerlink" title="ConnectInterceptor之连接池"></a>ConnectInterceptor之连接池</h2><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException {<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Request request = realChain.request();<br>    StreamAllocation streamAllocation = realChain.streamAllocation();<br><br>    <span class="hljs-comment">// We need the network to satisfy this request.     Possibly for validating a conditional GET.</span><br>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);<br>    <span class="hljs-comment">// HttpCodec是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。在这个方法的内部实现连接池的复用处理</span><br>    HttpCodec httpCodec = streamAllocation.newStream(client, chain,     doExtensiveHealthChecks);<br>    RealConnection connection = streamAllocation.connection();<br><br>    <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);<br>}<br><br><br><br><span class="hljs-comment">// Returns a connection to host a new stream. This // prefers the existing connection if it exists,</span><br><span class="hljs-comment">// then the pool, finally building a new connection.</span><br><span class="hljs-comment">// 调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列</span><br><span class="hljs-comment">// 的判断到达 StreamAllocation 中的 findConnection() 方法</span><br><span class="hljs-keyword">private</span> RealConnection findConnection(<span class="hljs-keyword">int</span>   connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,<br>    <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled) <span class="hljs-keyword">throws</span> IOException {<br>      ...<br>    <br>      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span><br>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new streams.</span><br>      <span class="hljs-comment">// 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流</span><br>      releasedConnection = <span class="hljs-keyword">this</span>.connection;<br>      <span class="hljs-comment">// 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接</span><br>      toClose = releaseIfNoNewStreams();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-comment">// We had an already-allocated connection and it's good.</span><br>        result = <span class="hljs-keyword">this</span>.connection;<br>        releasedConnection = <span class="hljs-keyword">null</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (!reportedAcquired) {<br>        <span class="hljs-comment">// If the connection was never reported acquired, don't report it as released!</span><br>        <span class="hljs-comment">// 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire()   方法修改</span><br>        releasedConnection = <span class="hljs-keyword">null</span>;<br>      }<br>    <br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-comment">// Attempt to get a connection from the pool.</span><br>        <span class="hljs-comment">// 尝试供连接池中获取一个连接</span><br>        Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) {<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = connection;<br>        } <span class="hljs-keyword">else</span> {<br>          selectedRoute = route;<br>        }<br>      }<br>    }<br>    <span class="hljs-comment">// 关闭连接</span><br>    closeQuietly(toClose);<br>    <br>    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) {<br>      eventListener.connectionReleased(<span class="hljs-keyword">call</span>, releasedConnection);<br>    }<br>    <span class="hljs-keyword">if</span> (foundPooledConnection) {<br>      eventListener.connectionAcquired(<span class="hljs-keyword">call</span>, result);<br>    }<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {<br>      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span><br>      <span class="hljs-comment">// 如果已经从连接池中获取到了一个连接，就将其返回</span><br>      <span class="hljs-keyword">return</span> result;<br>    }<br>    <br>    <span class="hljs-comment">// If we need a route selection, make one. This   is a blocking operation.</span><br>    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) {<br>      newRouteSelection = <span class="hljs-keyword">true</span>;<br>      routeSelection = routeSelector.<span class="hljs-keyword">next</span>();<br>    }<br>    <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) {<br>      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br>    <br>      <span class="hljs-keyword">if</span> (newRouteSelection) {<br>        <span class="hljs-comment">// Now that we have a set of IP addresses,   make another attempt at getting a   connection from</span><br>        <span class="hljs-comment">// the pool. This could match due to   connection coalescing.</span><br>         <span class="hljs-comment">// 根据一系列的 IP地址从连接池中获取一个链接</span><br>        List&lt;Route&gt; routes = routeSelection.getAll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-keyword">size</span> = routes.<span class="hljs-keyword">size</span>(); i &lt; <span class="hljs-keyword">size</span>;i++) {<br>          Route route = routes.get(i);<br>          <span class="hljs-comment">// 从连接池中获取一个连接</span><br>          Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, route);<br>          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) {<br>            foundPooledConnection = <span class="hljs-keyword">true</span>;<br>            result = connection;<br>            <span class="hljs-keyword">this</span>.route = route;<br>            <span class="hljs-keyword">break</span>;<br>          }<br>        }<br>      }<br>    <br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) {<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) {<br>          selectedRoute = routeSelection.<span class="hljs-keyword">next</span>();<br>        }<br>    <br>        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it   possible</span><br>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span><br>        <span class="hljs-comment">// 在连接池中如果没有该连接，则创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端</span><br>        route = selectedRoute;<br>        refusedStreamCount = <span class="hljs-number">0</span>;<br>        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);<br>        acquire(result, <span class="hljs-keyword">false</span>);<br>      }<br>    }<br>    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we're done.</span><br>    <span class="hljs-keyword">if</span> (foundPooledConnection) {<br>    <span class="hljs-comment">// 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回</span><br>      eventListener.connectionAcquired(<span class="hljs-keyword">call</span>, result);<br>      <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">// Do TCP + TLS handshakes. This is a blocking     operation.</span><br>     <span class="hljs-comment">// 进行 TCP 和 TLS 握手</span><br>    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,<br>      connectionRetryEnabled, <span class="hljs-keyword">call</span>, eventListener);<br>    routeDatabase().connected(result.route());<br><br>    Socket socket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) {<br>      reportedAcquired = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-comment">// Pool the connection.</span><br>      <span class="hljs-comment">// 将该连接放进连接池中</span><br>      Internal.instance.put(connectionPool, result);<br><br>      <span class="hljs-comment">// If another multiplexed connection to the same   address was created concurrently, then</span><br>      <span class="hljs-comment">// release this connection and acquire that one.</span><br>      <span class="hljs-comment">// 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接</span><br>      <span class="hljs-keyword">if</span> (result.isMultiplexed()) {<br>        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);<br>        result = connection;<br>      }<br>    }<br>    closeQuietly(socket);<br><br>    eventListener.connectionAcquired(<span class="hljs-keyword">call</span>, result);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从以上的源码分析可知：</p>
<ul>
<li>判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流；</li>
<li>如果当前的连接无法使用，就从连接池中获取一个连接；</li>
<li>连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。</li>
</ul>
<p>在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient<br>的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。并且，从中我们明白了连接复用的一个好处就是省去了进行<br>TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。</p>
<p>接下来详细分析下ConnectionPool是如何实现连接管理的。</p>
<p>OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在<br>ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(RealConnection connection)</span> {<br><span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-built_in">this</span>));<br>    <span class="hljs-keyword">if</span> (!cleanupRunning) {<br>      cleanupRunning = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 使用线程池执行清理任务</span><br>      executor.execute(cleanupRunnable);<br>    }<br>    <span class="hljs-comment">// 将新建的连接插入到双端队列中</span><br>    connections.add(connection);<br>}<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">cleanupRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {<br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>        <span class="hljs-comment">// 内部调用 cleanup() 方法来清理无效的连接</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">waitNanos</span> <span class="hljs-operator">=</span> cleanup(System.nanoTime());<br>        <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) {<br>          <span class="hljs-type">long</span> <span class="hljs-variable">waitMillis</span> <span class="hljs-operator">=</span> waitNanos / <span class="hljs-number">1000000L</span>;<br>          waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);<br>          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-built_in">this</span>) {<br>            <span class="hljs-keyword">try</span> {<br>              ConnectionPool.<span class="hljs-built_in">this</span>.wait(waitMillis, (<span class="hljs-type">int</span>) waitNanos);<br>            } <span class="hljs-keyword">catch</span> (InterruptedException ignored) {<br>            }<br>          }<br>        }<br>    }<br>};<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">inUseConnectionCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idleConnectionCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">RealConnection</span> <span class="hljs-variable">longestIdleConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">longestIdleDurationNs</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {<br>        <span class="hljs-comment">// 遍历所有的连接</span><br>        <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) {<br>          <span class="hljs-type">RealConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> i.next();<br>    <br>          <span class="hljs-comment">// If the connection is in use, keep     searching.</span><br>          <span class="hljs-comment">// 遍历所有的连接</span><br>          <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) {<br>            inUseConnectionCount++;<br>            <span class="hljs-keyword">continue</span>;<br>          }<br>    <br>          idleConnectionCount++;<br>    <br>          <span class="hljs-comment">// If the connection is ready to be     evicted,     we're done.</span><br>          <span class="hljs-comment">// 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放</span><br>          <span class="hljs-type">long</span> <span class="hljs-variable">idleDurationNs</span> <span class="hljs-operator">=</span> now - connection.idleAtNanos;<br>          <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) {<br>            longestIdleDurationNs = idleDurationNs;<br>            longestIdleConnection = connection;<br>          }<br>        }<br>    <br>        <span class="hljs-comment">// maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。</span><br>        <span class="hljs-comment">// 默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。</span><br>        <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-built_in">this</span>.keepAliveDurationNs<br>            || idleConnectionCount &gt; <span class="hljs-built_in">this</span>.maxIdleConnections) {<br>          <span class="hljs-comment">// We've found a connection to evict. Remove it from the list, then close it     below (outside</span><br>          <span class="hljs-comment">// of the synchronized block).</span><br>          <span class="hljs-comment">// 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除</span><br>          connections.remove(longestIdleConnection);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) {<br>          <span class="hljs-comment">// A connection will be ready to evict soon.</span><br>          <span class="hljs-comment">// 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）</span><br>          <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) {<br>          <span class="hljs-comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span><br>          <span class="hljs-comment">// 所有的连接都在使用中，5分钟后再清理</span><br>          <span class="hljs-keyword">return</span> keepAliveDurationNs;<br>        } <span class="hljs-keyword">else</span> {<br>          <span class="hljs-comment">// No connections, idle or in use.</span><br>           <span class="hljs-comment">// 没有连接</span><br>          cleanupRunning = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从以上的源码分析可知，首先会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。</p>
<blockquote>
</blockquote>
<p>经过上面对OKHttp内部工作机制的一系列分析，相信你已经对OKHttp已经有了一个比较深入的了解了。首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()<br>方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()<br>方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。</p>
<blockquote>
<p>其中，除了OKHttp的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，相信经过讲解，大家对这三部分重点内容已经有了自己的理解。</p>
</blockquote>
<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><h2 id="基本使用流程"><a href="#基本使用流程" class="headerlink" title="基本使用流程"></a>基本使用流程</h2><h3 id="定义HTTP-API，用于描述请求"><a href="#定义HTTP-API，用于描述请求" class="headerlink" title="定义HTTP API，用于描述请求"></a>定义HTTP API，用于描述请求</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">GitHubService</span> {<br><br>     <span class="hljs-variable">@GET</span>(<span class="hljs-string">"users/{user}/repos"</span>)<br>     Call&lt;List&lt;Repo&gt;&gt; <span class="hljs-built_in">listRepos</span>(<span class="hljs-variable">@Path</span>(<span class="hljs-string">"user"</span>) String user);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="创建Retrofit并生成API的实现"><a href="#创建Retrofit并生成API的实现" class="headerlink" title="创建Retrofit并生成API的实现"></a>创建Retrofit并生成API的实现</h3><blockquote>
<p>（<strong>注意：</strong> 方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）</p>
</blockquote>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 1.Retrofit构建过程</span><br>Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.<span class="hljs-constructor">Builder()</span><br>.base<span class="hljs-constructor">Url(<span class="hljs-string">"https://api.github.com/"</span>)</span><br>.build<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// 2.创建网络请求接口类实例过程</span><br>GitHubService service = retrofit.create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GitHubService</span>.</span></span><span class="hljs-keyword">class</span>);<br></code></pre></td></tr></tbody></table></figure>

<h3 id="调用API方法，生成Call，执行请求"><a href="#调用API方法，生成Call，执行请求" class="headerlink" title="调用API方法，生成Call，执行请求"></a>调用API方法，生成Call，执行请求</h3><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 3.生成并执行请求过程</span><br><span class="hljs-type">Call</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Repo</span>&gt;&gt; repos <span class="hljs-operator">=</span> service.listRepos(<span class="hljs-string">"octocat"</span>);<br>repos.execute() or repos.enqueue()<br></code></pre></td></tr></tbody></table></figure>

<p>Retrofit的基本使用流程很简洁，但是简洁并不代表简单，Retrofit为了实现这种简洁的使用流程，内部使用了优秀的架构设计和大量的设计模式，在分析过Retrofit最新版的源码和大量优秀的Retrofit源码分析文章后发现，要想真正理解Retrofit内部的核心源码流程和设计思想，首先，需要对这九大设计模式有一定的了解，如下：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">1.Retrofit构建过程 <br>建造者模式、工厂方法模式<br><br>2.创建网络请求接口实例过程<br>外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式）<br><br>3.生成并执行请求过程<br>适配器模式（代理模式、装饰模式）<br></code></pre></td></tr></tbody></table></figure>

<p>其次，需要对OKHttp源码有一定的了解。让我们按以上流程去深入Retrofit源码内部，领悟它带给我们的<strong>设计之美</strong>。</p>
<h2 id="Retrofit构建过程"><a href="#Retrofit构建过程" class="headerlink" title="Retrofit构建过程"></a>Retrofit构建过程</h2><h3 id="Retrofit核心对象解析"><a href="#Retrofit核心对象解析" class="headerlink" title="Retrofit核心对象解析"></a>Retrofit核心对象解析</h3><p>首先Retrofit中有一个全局变量非常关键，在V2.5之前的版本，使用的是LinkedHashMap()，它是一个网络请求配置对象，是由网络请求接口中方法注解进行解析后得到的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Retrofit</span> {<br><br>    <span class="hljs-comment">// 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Method</span>, <span class="hljs-type">ServiceMethod</span>&lt;?&gt;&gt; serviceMethodCache <span class="hljs-operator">=</span> new <span class="hljs-type">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure>

<p>Retrofit使用了建造者模式通过内部类Builder类建立一个Retrofit实例，如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> {<br><br>    <span class="hljs-comment">// 平台类型对象（Platform -&gt; Android)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Platform</span> platform;<br>    <span class="hljs-comment">// 网络请求工厂，默认使用OkHttpCall（工厂方法模式）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> okhttp3.<span class="hljs-type">Call</span>.<span class="hljs-type">Factory</span> callFactory;<br>    <span class="hljs-comment">// 网络请求的url地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">HttpUrl</span> baseUrl;<br>    <span class="hljs-comment">// 数据转换器工厂的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">Converter</span>.<span class="hljs-type">Factory</span>&gt; converterFactories <span class="hljs-operator">=</span> new <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 网络请求适配器工厂的集合，默认是ExecutorCallAdapterFactory</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">CallAdapter</span>.<span class="hljs-type">Factory</span>&gt; callAdapterFactories <span class="hljs-operator">=</span> new <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 回调方法执行器，在 Android 上默认是封装了 handler 的 MainThreadExecutor, 默认作用是：切换线程（子线程 -&gt; 主线程）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">Executor</span> callbackExecutor;<br>    <span class="hljs-comment">// 一个开关，为true则会缓存创建的ServiceMethod</span><br>    <span class="hljs-keyword">private</span> boolean validateEagerly;<br></code></pre></td></tr></tbody></table></figure>

<h3 id="Builder内部构造"><a href="#Builder内部构造" class="headerlink" title="Builder内部构造"></a>Builder内部构造</h3><p>下面看看Builder内部构造做了什么。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> {<br><br>    ...<br>    <br>    Builder(Platform platform) {<br>        <span class="hljs-built_in">this</span>.platform = platform;<br>    }<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">this</span>(Platform.get());<br>    }<br>    <br>    ...<br>    <br>}<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Platform</span> {<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Platform</span> <span class="hljs-variable">PLATFORM</span> <span class="hljs-operator">=</span> findPlatform();<br>    <br>    <span class="hljs-keyword">static</span> Platform <span class="hljs-title function_">get</span><span class="hljs-params">()</span> {<br>      <span class="hljs-keyword">return</span> PLATFORM;<br>    }<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Platform <span class="hljs-title function_">findPlatform</span><span class="hljs-params">()</span> {<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 使用JVM加载类的方式判断是否是Android平台</span><br>        Class.forName(<span class="hljs-string">"android.os.Build"</span>);<br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT != <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Android</span>();<br>        }<br>      } <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) {<br>      }<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 同时支持Java平台</span><br>        Class.forName(<span class="hljs-string">"java.util.Optional"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Java8</span>();<br>      } <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) {<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Platform</span>();<br>    }<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Android</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Platform</span> {<br><br>    ...<br><br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">defaultCallbackExecutor</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">//切换线程（子线程 -&gt; 主线程）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainThreadExecutor</span>();<br>    }<br><br>    <span class="hljs-comment">// 创建默认的网络请求适配器工厂，如果是Android7.0或Java8上，则使</span><br>    <span class="hljs-comment">// 用了并发包中的CompletableFuture保证了回调的同步</span><br>    <span class="hljs-comment">// 在Retrofit中提供了四种CallAdapterFactory(策略模式)：</span><br>    <span class="hljs-comment">// ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、</span><br>    <span class="hljs-comment">// va8CallAdapterFactory、RxJavaCallAdapterFactory</span><br>    <span class="hljs-meta">@Override</span> List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CallAdapter</span>.Factory&gt; defaultCallAdapterFactories(<br>        <span class="hljs-meta">@Nullable</span> Executor callbackExecutor) {<br>      <span class="hljs-keyword">if</span> (callbackExecutor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>      <span class="hljs-type">ExecutorCallAdapterFactory</span> <span class="hljs-variable">executorFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>   <span class="hljs-title class_">ExecutorCallAdapterFactory</span>(callbackExecutor);<br>      <span class="hljs-keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="hljs-number">24</span><br>        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)<br>        : singletonList(executorFactory);<br>    }<br>    <br>    ...<br><br>    <span class="hljs-meta">@Override</span> List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Converter</span>.Factory&gt; defaultConverterFactories() {<br>      <span class="hljs-keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="hljs-number">24</span><br>          ? singletonList(OptionalConverterFactory.INSTANCE)<br>          : Collections.&lt;Converter.Factory&gt;emptyList();<br>    }<br><br>    ...<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThreadExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> {<br>    <br>        <span class="hljs-comment">// 获取Android 主线程的Handler </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> {<br>        <br>            <span class="hljs-comment">// 在UI线程对网络请求返回数据处理</span><br>            handler.post(r);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，在Builder内部构造时设置了默认Platform、callAdapterFactories和callbackExecutor。</p>
<h3 id="添加baseUrl"><a href="#添加baseUrl" class="headerlink" title="添加baseUrl"></a>添加baseUrl</h3><p>很简单，就是将String类型的url转换为OkHttp的HttpUrl过程如下：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set the API base URL.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @see #baseUrl(HttpUrl)</span><br><span class="hljs-comment"> */</span><br>public Builder base<span class="hljs-constructor">Url(String <span class="hljs-params">baseUrl</span>)</span> {<br>    check<span class="hljs-constructor">NotNull(<span class="hljs-params">baseUrl</span>, <span class="hljs-string">"baseUrl == null"</span>)</span>;<br>    return base<span class="hljs-constructor">Url(HttpUrl.<span class="hljs-params">get</span>(<span class="hljs-params">baseUrl</span>)</span>);<br>}<br><br>public Builder base<span class="hljs-constructor">Url(HttpUrl <span class="hljs-params">baseUrl</span>)</span> {<br>    check<span class="hljs-constructor">NotNull(<span class="hljs-params">baseUrl</span>, <span class="hljs-string">"baseUrl == null"</span>)</span>;<br>    List&lt;String&gt; pathSegments = baseUrl.path<span class="hljs-constructor">Segments()</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(pathSegments.get(pathSegments.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>))) {<br>      throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">"baseUrl must end in /: "</span> + <span class="hljs-params">baseUrl</span>)</span>;<br>    }<br>    this.baseUrl = baseUrl;<br>    return this;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="添加GsonConverterFactory"><a href="#添加GsonConverterFactory" class="headerlink" title="添加GsonConverterFactory"></a>添加GsonConverterFactory</h3><p>首先，看到GsonConverterFactory.creat()的源码。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GsonConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Converter</span>.<span class="hljs-title">Factory</span> </span>{<br> <br>    public static <span class="hljs-type">GsonConverterFactory</span> create() {<br>        <span class="hljs-keyword">return</span> create(<span class="hljs-keyword">new</span> <span class="hljs-type">Gson</span>());<br>    }<br>    <br>    <br>    public static <span class="hljs-type">GsonConverterFactory</span> create(<span class="hljs-type">Gson</span> gson) {<br>        <span class="hljs-keyword">if</span> (gson == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">"gson ==   null"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">GsonConverterFactory</span>(gson);<br>    }<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Gson</span> gson;<br>    <br>    <span class="hljs-comment">// 创建了一个含有Gson对象实例的GsonConverterFactory</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">GsonConverterFactory</span>(<span class="hljs-type">Gson</span> gson) {<br>        <span class="hljs-keyword">this</span>.gson = gson;<br>    }<br><br></code></pre></td></tr></tbody></table></figure>

<p>然后，看看addConverterFactory()方法内部。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">addConverterFactory</span>(<span class="hljs-params">Converter.Factory factory</span>)</span> {<br>    converterFactories.<span class="hljs-keyword">add</span>(checkNotNull(factory, <span class="hljs-string">"factory null"</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可知，这一步是将一个含有Gson对象实例的GsonConverterFactory放入到了数据转换器工厂converterFactories里。</p>
<h3 id="build过程"><a href="#build过程" class="headerlink" title="build过程"></a>build过程</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Retrofit build<span class="hljs-literal">()</span> {<br><br>    <span class="hljs-keyword">if</span> (baseUrl<span class="hljs-operator"> == </span>null) {<br>      throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalStateException(<span class="hljs-string">"Base URL required."</span>)</span>;<br>    }<br>    <br>    okhttp3.Call.Factory callFactory = this.callFactory;<br>    <span class="hljs-keyword">if</span> (callFactory<span class="hljs-operator"> == </span>null) {<br>        <span class="hljs-comment">// 默认使用okhttp</span><br>         callFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OkHttpClient()</span>;<br>    }<br>    <br>    Executor callbackExecutor = this.callbackExecutor;<br>    <span class="hljs-keyword">if</span> (callbackExecutor<span class="hljs-operator"> == </span>null) {<br>        <span class="hljs-comment">// Android默认的callbackExecutor</span><br>        callbackExecutor = platform.default<span class="hljs-constructor">CallbackExecutor()</span>;<br>    }<br>    <br>    <span class="hljs-comment">// Make a defensive copy of the adapters and add the defaultCall adapter.</span><br>    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(this.callAdapterFactories);<br>    <span class="hljs-comment">// 添加默认适配器工厂在集合尾部</span><br>    callAdapterFactories.add<span class="hljs-constructor">All(<span class="hljs-params">platform</span>.<span class="hljs-params">defaultCallAdapterFactorisca</span>  <span class="hljs-params">llbackExecutor</span>)</span>);<br>    <br>    <span class="hljs-comment">// Make a defensive copy of the converters.</span><br>    List&lt;Converter.Factory&gt; converterFactories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<br>        <span class="hljs-number">1</span> + this.converterFactories.size<span class="hljs-literal">()</span> + platform.default<span class="hljs-constructor">ConverterFactoriesSize()</span>);<br>    <span class="hljs-comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span><br>    <span class="hljs-comment">// ensures correct behavior when using converters thatconsumeall types.</span><br>    converterFactories.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">BuiltInConverters()</span>);<br>    converterFactories.add<span class="hljs-constructor">All(<span class="hljs-params">this</span>.<span class="hljs-params">converterFactories</span>)</span>;<br>    converterFactories.add<span class="hljs-constructor">All(<span class="hljs-params">platform</span>.<span class="hljs-params">defaultConverterFactories</span>()</span>;<br>    <br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Retrofit(<span class="hljs-params">callFactory</span>, <span class="hljs-params">baseUrl</span>, <span class="hljs-params">unmodifiableList</span>(<span class="hljs-params">converterFactories</span>)</span>,<br>        unmodifiable<span class="hljs-constructor">List(<span class="hljs-params">callAdapterFactories</span>)</span>, callbackExecutor, validateEagerly);<br>        <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，最终我们在Builder类中看到的6大核心对象都已经配置到Retrofit对象中了。</p>
<h2 id="创建网络请求接口实例过程"><a href="#创建网络请求接口实例过程" class="headerlink" title="创建网络请求接口实例过程"></a>创建网络请求接口实例过程</h2><p>retrofit.create()使用了外观模式和代理模式创建了网络请求的接口实例，我们分析下create方法。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;T&gt; T create(final Class&lt;T&gt; service) {<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>validate<span class="hljs-constructor">ServiceInterface(<span class="hljs-params">service</span>)</span>;<br>    <span class="hljs-keyword">if</span> (validateEagerly) {<br>        <span class="hljs-comment">// 判断是否需要提前缓存ServiceMethod对象</span><br>        eagerly<span class="hljs-constructor">ValidateMethods(<span class="hljs-params">service</span>)</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 使用动态代理拿到请求接口所有注解配置后，创建网络请求接口实例</span><br>    return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">service</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span>  Class&lt;?&gt;<span class="hljs-literal">[]</span> { service },<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> {<br>          <span class="hljs-keyword">private</span> final Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br>          <span class="hljs-keyword">private</span> final Object<span class="hljs-literal">[]</span> emptyArgs = <span class="hljs-keyword">new</span> Object<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br><br>          @Override public Object invoke(Object proxy, Method <span class="hljs-keyword">method</span>, @Nullable Object<span class="hljs-literal">[]</span> args)<br>              throws Throwable {<br>            <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">class</span>) {<br>              return <span class="hljs-keyword">method</span>.invoke(this, args);<br>            }<br>            <span class="hljs-keyword">if</span> (platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) {<br>              return platform.invoke<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>, <span class="hljs-params">service</span>, <span class="hljs-params">proxy</span>, <span class="hljs-params">args</span>)</span>;<br>            }<br>            return load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>.invoke(args != null ? args : emptyArgs);<br>          }<br>    });<br> }<br><br><span class="hljs-keyword">private</span> void eagerly<span class="hljs-constructor">ValidateMethods(Class&lt;?&gt; <span class="hljs-params">service</span>)</span> {<br><br>  Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br>  <span class="hljs-keyword">for</span> (Method <span class="hljs-keyword">method</span> : service.get<span class="hljs-constructor">DeclaredMethods()</span>) {<br>    <span class="hljs-keyword">if</span> (!platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) {<br>      load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>;<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>继续看看loadServiceMethod的内部流程</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">ServiceMethod&lt;?&gt; loadServiceMethod(<span class="hljs-keyword">Method</span> <span class="hljs-title function_">method</span>) <span class="hljs-comment">{</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="hljs-comment">    if (result != null) return result;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    synchronized (serviceMethodCache) {</span><br><span class="hljs-comment">      result = serviceMethodCache.get(method);</span><br><span class="hljs-comment">      if (result == null) {</span><br><span class="hljs-comment">            // 解析注解配置得到了ServiceMethod</span><br><span class="hljs-comment">            result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="hljs-comment">            // 可以看到，最终加入到ConcurrentHashMap缓存中</span><br><span class="hljs-comment">            serviceMethodCache.put(method, result);</span><br><span class="hljs-comment">      }</span><br>    }<br>    <span class="hljs-title function_">return</span> <span class="hljs-title function_">result</span>;<br>}<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> ServiceMethod&lt;T&gt; <span class="hljs-comment">{</span><br><span class="hljs-comment">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method   method) {</span><br><span class="hljs-comment">        // 通过RequestFactory解析注解配置（工厂模式、内部使用了建造者模式）</span><br><span class="hljs-comment">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        Type returnType = method.getGenericReturnType();</span><br><span class="hljs-comment">        if (Utils.hasUnresolvableType(returnType)) {</span><br><span class="hljs-comment">          throw methodError(method,</span><br><span class="hljs-comment">              "Method return type must not include a type variable or wildcard: %s", returnType);</span><br><span class="hljs-comment">        }</span><br>        <span class="hljs-keyword">if</span> (returnType == void.class) <span class="hljs-comment">{</span><br><span class="hljs-comment">          throw methodError(method, "Service methods cannot return void.");</span><br><span class="hljs-comment">        }</span><br>    <br>        <span class="hljs-comment">// 最终是通过HttpServiceMethod构建的请求方法</span><br>        return HttpServiceMethod.parseAnnotations(retrofit, <span class="hljs-keyword">method</span>, <span class="hljs-title function_">requestFactory</span>);<br>    }<br><br>    <span class="hljs-keyword">abstract</span> T invoke(Object[] args)<span class="hljs-punctuation">;</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="请求构造核心流程"><a href="#请求构造核心流程" class="headerlink" title="请求构造核心流程"></a>请求构造核心流程</h3><p>根据RequestFactory#Builder构造方法和parseAnnotations方法的源码，可知的它的作用就是用来解析注解配置的。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Builder(Retrofit <span class="hljs-params">retrofit</span>, Method <span class="hljs-params">method</span>)</span> {<br>    this.retrofit = retrofit;<br>    this.<span class="hljs-keyword">method</span> = <span class="hljs-keyword">method</span>;<br>    <span class="hljs-comment">// 获取网络请求接口方法里的注释</span><br>    this.methodAnnotations = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Annotations()</span>;<br>    <span class="hljs-comment">// 获取网络请求接口方法里的参数类型       </span><br>    this.parameterTypes = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">GenericParameterTypes()</span>;<br>    <span class="hljs-comment">// 获取网络请求接口方法里的注解内容    </span><br>    this.parameterAnnotationsArray = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ParameterAnnotations()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接着看HttpServiceMethod.parseAnnotations()的内部流程。</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">static</span> &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(<br>      Retrofit retrofit, <span class="hljs-keyword">Method</span> <span class="hljs-title function_">method</span>, <span class="hljs-title function_">RequestFactory</span> <span class="hljs-title function_">requestFactory</span>) <span class="hljs-comment">{</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    //1.根据网络请求接口方法的返回值和注解类型，</span><br><span class="hljs-comment">    // 从Retrofit对象中获取对应的网络请求适配器</span><br><span class="hljs-comment">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit,method);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    // 得到响应类型</span><br><span class="hljs-comment">    Type responseType = callAdapter.responseType();</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //2.根据网络请求接口方法的返回值和注解类型从Retrofit对象中获取对应的数据转换器 </span><br><span class="hljs-comment">    Converter&lt;ResponseBody, ResponseT&gt;responseConverter =</span><br><span class="hljs-comment">        createResponseConverter(retrofit,method, responseType);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    return newHttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter,responseConverter);</span><br><span class="hljs-comment">}</span><br></code></pre></td></tr></tbody></table></figure>

<h4 id="createCallAdapter-retrofit-method"><a href="#createCallAdapter-retrofit-method" class="headerlink" title="createCallAdapter(retrofit, method)"></a>createCallAdapter(retrofit, method)</h4><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;<span class="hljs-title class_">ResponseT</span>, <span class="hljs-title class_">ReturnT</span>&gt; <span class="hljs-title class_">CallAdapter</span>&lt;<span class="hljs-title class_">ResponseT</span>, <span class="hljs-title class_">ReturnT</span>&gt;     <span class="hljs-title function_">createCallAdapter</span>(<span class="hljs-params"></span><br><span class="hljs-params">      Retrofit retrofit, Method method</span>) {<br>      <br>    <span class="hljs-comment">// 获取网络请求接口里方法的返回值类型</span><br>    <span class="hljs-title class_">Type</span> returnType = method.<span class="hljs-title function_">getGenericReturnType</span>();<br>    <br>    <span class="hljs-comment">// 获取网络请求接口接口里的注解</span><br>    <span class="hljs-title class_">Annotation</span>[] annotations = method.<span class="hljs-title function_">getAnnotations</span>();<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">//noinspection unchecked</span><br>      <span class="hljs-keyword">return</span> (<span class="hljs-title class_">CallAdapter</span>&lt;<span class="hljs-title class_">ResponseT</span>, <span class="hljs-title class_">ReturnT</span>&gt;)  retrofit.<span class="hljs-title function_">callAdapter</span>(returnType, annotations);<br>    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">RuntimeException</span> e) { <span class="hljs-comment">// Wide exception range because factories are user code.</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-title function_">methodError</span>(method, e, <span class="hljs-string">"Unable to create call adapter for %s"</span>, returnType);<br>    }<br>}<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_">CallAdapter</span>&lt;?, ?&gt; <span class="hljs-title function_">callAdapter</span>(<span class="hljs-params">Type returnType, Annotation[] annotations</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">nextCallAdapter</span>(<span class="hljs-literal">null</span>, returnType, annotations);<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">CallAdapter</span>&lt;?, ?&gt; <span class="hljs-title function_">nextCallAdapter</span>(<span class="hljs-params"><span class="hljs-meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="hljs-params">  Annotation[] annotations</span>) {<br>    ...<br><br>    int start = callAdapterFactories.<span class="hljs-title function_">indexOf</span>(skipPast) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 遍历 CallAdapter.Factory 集合寻找合适的工厂</span><br>    <span class="hljs-keyword">for</span> (int i = start, count = callAdapterFactories.<span class="hljs-title function_">size</span>(); i &lt;count; i++) {<br>        <span class="hljs-title class_">CallAdapter</span>&lt;?, ?&gt; adapter = callAdapterFactories.<span class="hljs-title function_">get</span>(i).<span class="hljs-title function_">get</span>(returnType, annotations, <span class="hljs-variable language_">this</span>);<br>        <span class="hljs-keyword">if</span> (adapter != <span class="hljs-literal">null</span>) {<br>          <span class="hljs-keyword">return</span> adapter;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType"><a href="#createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType" class="headerlink" title="createResponseConverter(Retrofit retrofit, Method method, Type responseType)"></a>createResponseConverter(Retrofit retrofit, Method method, Type responseType)</h4><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;<span class="hljs-title class_">ResponseT</span>&gt; <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, <span class="hljs-title class_">ResponseT</span>&gt;  <span class="hljs-title function_">createResponseConverter</span>(<span class="hljs-params"></span><br><span class="hljs-params">     Retrofit retrofit, Method method, Type responseType</span>) {<br>   <span class="hljs-title class_">Annotation</span>[] annotations = method.<span class="hljs-title function_">getAnnotations</span>();<br>   <span class="hljs-keyword">try</span> {<br>     <span class="hljs-keyword">return</span> retrofit.<span class="hljs-title function_">responseBodyConverter</span>(responseType,annotations);<br>   } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">RuntimeException</span> e) { <span class="hljs-comment">// Wide exception range because    factories are user code.</span><br>     <span class="hljs-keyword">throw</span> <span class="hljs-title function_">methodError</span>(method, e, <span class="hljs-string">"Unable to create converter for%s"</span>,   responseType);<br>   }<br>}<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, T&gt; <span class="hljs-title function_">responseBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] annotations</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">nextResponseBodyConverter</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">type</span>, annotations);<br>}<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, T&gt; <span class="hljs-title function_">nextResponseBodyConverter</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-meta">@Nullable</span> Converter.Factory skipPast, Type <span class="hljs-keyword">type</span>, Annotation[] annotations</span>) {<br>...<br><br>int start = converterFactories.<span class="hljs-title function_">indexOf</span>(skipPast) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 遍历 Converter.Factory 集合并寻找合适的工厂, 这里是GsonResponseBodyConverter</span><br><span class="hljs-keyword">for</span> (int i = start, count = converterFactories.<span class="hljs-title function_">size</span>(); i &lt; count; i++) {<br>  <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, ?&gt; converter =<br>      converterFactories.<span class="hljs-title function_">get</span>(i).<span class="hljs-title function_">responseBodyConverter</span>(<span class="hljs-keyword">type</span>, annotations, <span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) {<br>    <span class="hljs-comment">//noinspection unchecked</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, T&gt;) converter;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="执行HttpServiceMethod的invoke方法"><a href="#执行HttpServiceMethod的invoke方法" class="headerlink" title="执行HttpServiceMethod的invoke方法"></a>执行HttpServiceMethod的invoke方法</h4><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span> <span class="hljs-title class_">ReturnT</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span>[] args</span>) {<br>    <span class="hljs-keyword">return</span> callAdapter.<span class="hljs-title function_">adapt</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最终在adapt中创建了一个ExecutorCallbackCall对象，它是一个装饰者，而在它内部真正去执行网络请求的还是OkHttpCall。</p>
<h2 id="创建网络请求接口类实例并执行请求过程"><a href="#创建网络请求接口类实例并执行请求过程" class="headerlink" title="创建网络请求接口类实例并执行请求过程"></a>创建网络请求接口类实例并执行请求过程</h2><h3 id="service-listRepos"><a href="#service-listRepos" class="headerlink" title="service.listRepos()"></a>service.listRepos()</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>、Call&lt;List&lt;Repo&gt;&gt; repos <span class="hljs-operator">=</span> service.listRepos(<span class="hljs-string">"octocat"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure>

<p>service对象是动态代理对象Proxy.newProxyInstance()，当调用getCall()时会被 它拦截，然后调用自身的InvocationHandler#invoke()<br>，得到最终的Call对象。</p>
<h3 id="同步执行流程-repos-execute"><a href="#同步执行流程-repos-execute" class="headerlink" title="同步执行流程 repos.execute()"></a>同步执行流程 repos.execute()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response&lt;T&gt; <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    okhttp3.Call call;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"Already executed."</span>);<br>      executed = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">if</span> (creationFailure != <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">if</span> (creationFailure <span class="hljs-keyword">instanceof</span> IOException) {<br>          <span class="hljs-keyword">throw</span> (IOException) creationFailure;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (creationFailure <span class="hljs-keyword">instanceof</span> RuntimeException) {<br>          <span class="hljs-keyword">throw</span> (RuntimeException) creationFailure;<br>        } <span class="hljs-keyword">else</span> {<br>          <span class="hljs-keyword">throw</span> (Error) creationFailure;<br>        }<br>      }<br><br>      call = rawCall;<br>      <span class="hljs-keyword">if</span> (call == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">try</span> {<br>          <span class="hljs-comment">// 创建一个OkHttp的Request对象请求</span><br>          call = rawCall = createRawCall();<br>        } <span class="hljs-keyword">catch</span> (IOException | RuntimeException | Error e) {<br>          throwIfFatal(e); <span class="hljs-comment">//  Do not assign a fatal error to     creationFailure.</span><br>          creationFailure = e;<br>          <span class="hljs-keyword">throw</span> e;<br>        }<br>      }<br>    }<br><br>    <span class="hljs-keyword">if</span> (canceled) {<br>      call.cancel();<br>    }<br><br>    <span class="hljs-comment">// 调用OkHttpCall的execute()发送网络请求（同步），</span><br>    <span class="hljs-comment">// 并解析网络请求返回的数据</span><br>    <span class="hljs-keyword">return</span> parseResponse(call.execute());<br>}<br><br><br><span class="hljs-keyword">private</span> okhttp3.Call <span class="hljs-title function_">createRawCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-comment">// 创建 一个okhttp3.Request</span><br>    okhttp3.<span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span><br>    callFactory.newCall(requestFactory.create(args));<br>    <span class="hljs-keyword">if</span> (call == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"Call.Factory returned null."</span>);<br>    }<br>    <span class="hljs-keyword">return</span> call;<br>}<br><br><br>Response&lt;T&gt; <span class="hljs-title function_">parseResponse</span><span class="hljs-params">(okhttp3.Response rawResponse)</span> <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-type">ResponseBody</span> <span class="hljs-variable">rawBody</span> <span class="hljs-operator">=</span> rawResponse.body(); <br>    <br>    <span class="hljs-comment">// Remove the body's source (the only stateful object) so we can   pass the response along.</span><br>    rawResponse = rawResponse.newBuilder()<br>        .body(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoContentResponseBody</span>(rawBody.contentType(), rawBody.contentLength()))<br>        .build();    <br>    <br>    <span class="hljs-comment">// 根据响应返回的状态码进行处理    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> rawResponse.code();<br>    <span class="hljs-keyword">if</span> (code &lt; <span class="hljs-number">200</span> || code &gt;= <span class="hljs-number">300</span>) {<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// Buffer the entire body to avoid future I/O.</span><br>        <span class="hljs-type">ResponseBody</span> <span class="hljs-variable">bufferedBody</span> <span class="hljs-operator">=</span> Utils.buffer(rawBody);<br>        <span class="hljs-keyword">return</span> Response.error(bufferedBody, rawResponse);<br>      } <span class="hljs-keyword">finally</span> {<br>        rawBody.close();<br>      }<br>    }    <br>    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) {<br>      rawBody.close();<br>      <span class="hljs-keyword">return</span> Response.success(<span class="hljs-literal">null</span>, rawResponse);<br>    }    <br>    <br>    <br>    <span class="hljs-type">ExceptionCatchingResponseBody</span> <span class="hljs-variable">catchingBody</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionCatchingResponseBody</span>(rawBody);<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">// 将响应体转为Java对象</span><br>      <span class="hljs-type">T</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> responseConverter.convert(catchingBody);<br>      <br>      <span class="hljs-keyword">return</span> Response.success(body, rawResponse);<br>    } <span class="hljs-keyword">catch</span> (RuntimeException e) {<br>      <span class="hljs-comment">// If the underlying source threw an exception, propagate that     rather than indicating it was</span><br>      <span class="hljs-comment">// a runtime exception.</span><br>      catchingBody.throwIfCaught();<br>      <span class="hljs-keyword">throw</span> e;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="异步请求流程-reponse-enqueque"><a href="#异步请求流程-reponse-enqueque" class="headerlink" title="异步请求流程 reponse.enqueque"></a>异步请求流程 reponse.enqueque</h3><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{<br><br>    <span class="hljs-comment">// 使用静态代理 delegate进行异步请求 </span><br>    delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;T&gt;() {<br><br>      <span class="hljs-meta">@Override</span> <br>      <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;T&gt; call, finalResponse&lt;T&gt;response)</span> </span>{<br>        <span class="hljs-comment">// 线程切换，在主线程显示结果</span><br>        callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span> <br>             <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">if</span> (delegate.isCanceled()) {<br>              callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, newIOException(<span class="hljs-string">"Canceled"</span>));<br>            } <span class="hljs-keyword">else</span> {<br>              callback.onResponse(ExecutorCallbackCall.<span class="hljs-keyword">this</span>,respons);<br>            }<br>          }<br>        });<br>      }<br>      <span class="hljs-meta">@Override</span> <br>      <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;T&gt; call, <span class="hljs-keyword">final</span> Throwable t)</span> </span>{<br>        callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() {<br>          <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, t);<br>          }<br>        });<br>      }<br>    });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>看看 delegate.enqueue 内部流程。</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{<br>   <br>    okhttp3.Call call;<br>    Throwable failure;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already executed."</span>);<br>      executed = <span class="hljs-keyword">true</span>;<br><br>      call = rawCall;<br>      failure = creationFailure;<br>      <span class="hljs-keyword">if</span> (call == <span class="hljs-keyword">null</span> &amp;&amp; failure == <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">try</span> {<br>          <span class="hljs-comment">// 创建OkHttp的Request对象，再封装成OkHttp.call</span><br>          <span class="hljs-comment">// 方法同发送同步请求，此处上面已分析</span><br>          call = rawCall = createRawCall(); <br>        } <span class="hljs-keyword">catch</span> (Throwable t) {<br>          failure = creationFailure = t;<br>        }<br>      }<br><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{<br>  checkNotNull(callback, <span class="hljs-string">"callback == null"</span>);<br><br>  okhttp3.Call call;<br>  Throwable failure;<br><br>  ...<br><br>  call.enqueue(<span class="hljs-keyword">new</span> okhttp3.Callback() {<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>{<br>      Response&lt;T&gt; response;<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 此处上面已分析</span><br>        response = parseResponse(rawResponse);<br>      } <span class="hljs-keyword">catch</span> (Throwable e) {<br>        throwIfFatal(e);<br>        callFailure(e);<br>        <span class="hljs-keyword">return</span>;<br>      }<br><br>      <span class="hljs-keyword">try</span> {<br>        callback.onResponse(OkHttpCall.<span class="hljs-keyword">this</span>, response);<br>      } <span class="hljs-keyword">catch</span> (Throwable t) {<br>        t.printStackTrace();<br>      }<br>    }<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(okhttp3.Call call, IOException e)</span> </span>{<br>      callFailure(e);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callFailure</span><span class="hljs-params">(Throwable e)</span> </span>{<br>      <span class="hljs-keyword">try</span> {<br>        callback.onFailure(OkHttpCall.<span class="hljs-keyword">this</span>, e);<br>      } <span class="hljs-keyword">catch</span> (Throwable t) {<br>        t.printStackTrace();<br>      }<br>    }<br>  });<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="Retrofit源码流程图"><a href="#Retrofit源码流程图" class="headerlink" title="Retrofit源码流程图"></a>Retrofit源码流程图</h2><p>建议大家自己主动配合着Retrofit最新版的源码一步步去彻底地认识它，只有这样，你才能看到它真实的内心，附上一张Retrofit源码流程图，要注意的是，这是V2.5之前版本的流程，但是，在看完上面的源码分析后，我们知道，主体流程是没有变化的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab58d6242cc4fae96cd73eb198e325a~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<blockquote>
<p>从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了<br>OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理的方式，动态将网络请求接口的注解解析成HTTP请求，最后执行请求的过程。</p>
</blockquote>
<h1 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h1><h2 id="基本使用流程-1"><a href="#基本使用流程-1" class="headerlink" title="基本使用流程"></a>基本使用流程</h2><p>Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">GlideApp.<span class="hljs-keyword">with</span>(context).<span class="hljs-keyword">load</span>(url).<span class="hljs-keyword">into</span>(iv);<br></code></pre></td></tr></tbody></table></figure>

<p>其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">@GlideModule<br>public class MyAppGlideModule extends AppGlideModule {<br><br>    @Override<br>    public void applyOptions(Context context, GlideBuilder builder) {<br>        // 实际使用中根据情况可以添加如下配置<br>        <span class="hljs-comment">&lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt;</span><br>        <span class="hljs-comment">&lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt;</span><br>        <span class="hljs-comment">&lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt;</span><br>        <span class="hljs-comment">&lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt;</span><br>        <span class="hljs-comment">&lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt;</span><br>        <span class="hljs-comment">&lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt;</span><br>        <span class="hljs-comment">&lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt;</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。</p>
<h2 id="GlideApp-with-context-源码详解"><a href="#GlideApp-with-context-源码详解" class="headerlink" title="GlideApp.with(context)源码详解"></a>GlideApp.with(context)源码详解</h2><p>首先，用这份Glide框架图让我们对Glide的总体框架有一个初步的了解。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2478933d44534c2fabb6466049b9f3b7~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<p>从GlideApp.with这行代码开始，内部主线执行流程如下。</p>
<h3 id="GlideApp-with"><a href="#GlideApp-with" class="headerlink" title="GlideApp#with"></a>GlideApp#with</h3><figure class="highlight vhdl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">return</span> (GlideRequests) Glide.<span class="hljs-keyword">with</span>(<span class="hljs-keyword">context</span>);<br></code></pre></td></tr></tbody></table></figure>

<h3 id="Glide-with"><a href="#Glide-with" class="headerlink" title="Glide#with"></a>Glide#with</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">return get<span class="hljs-constructor">Retriever(<span class="hljs-params">context</span>)</span>.get(context);<br><br>return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Glide</span>.</span></span>get(context).get<span class="hljs-constructor">RequestManagerRetriever()</span>;<br><br><span class="hljs-comment">// 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化</span><br>check<span class="hljs-constructor">AndInitializeGlide(<span class="hljs-params">context</span>)</span>;<br><br>initialize<span class="hljs-constructor">Glide(<span class="hljs-params">context</span>)</span>;<br><br><span class="hljs-comment">// 最终执行到Glide的另一个重载方法</span><br>initialize<span class="hljs-constructor">Glide(<span class="hljs-params">context</span>, <span class="hljs-params">new</span> GlideBuilder()</span>);<br><br>@<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">"deprecation"</span>)</span><br>  <span class="hljs-keyword">private</span> static void initialize<span class="hljs-constructor">Glide(@NonNull Context   <span class="hljs-params">context</span>, @NonNull GlideBuilder <span class="hljs-params">builder</span>)</span> {<br>    Context applicationContext =     context.get<span class="hljs-constructor">ApplicationContext()</span>;<br>    <span class="hljs-comment">// 1、获取前面应用中带注解的GlideModule</span><br>    GeneratedAppGlideModule annotationGeneratedModule =     get<span class="hljs-constructor">AnnotationGeneratedGlideModules()</span>;<br>    <span class="hljs-comment">// 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面</span><br>    <span class="hljs-comment">// 配置的GlideModule模块（manifestModules）。</span><br>    List&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt;     manifestModules = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>empty<span class="hljs-constructor">List()</span>;<br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule<span class="hljs-operator"> == </span>null<span class="hljs-operator"> ||     </span>annotationGeneratedModule.is<span class="hljs-constructor">ManifestParsingEnabled(    )</span>) {<br>      manifestModules = <span class="hljs-keyword">new</span>   <span class="hljs-constructor">ManifestParser(<span class="hljs-params">applicationContext</span>)</span>.parse<span class="hljs-literal">()</span>;<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>RequestManagerRetriever.RequestManagerFactory     factory =<br>        annotationGeneratedModule != null<br>            ? annotationGeneratedModule.getRequestManag    er<span class="hljs-constructor">Factory()</span> : null;<br>    builder.set<span class="hljs-constructor">RequestManagerFactory(<span class="hljs-params">factory</span>)</span>;<br>    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> :     manifestModules) {<br>      <span class="hljs-keyword">module</span>.apply<span class="hljs-constructor">Options(<span class="hljs-params">applicationContext</span>, <span class="hljs-params">builder</span>)</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule != null) {<br>      annotationGeneratedModule.apply<span class="hljs-constructor">Options(<span class="hljs-params">applicatio</span>  <span class="hljs-params">nContext</span>, <span class="hljs-params">builder</span>)</span>;<br>    }<br>    <span class="hljs-comment">// 3、初始化各种配置信息</span><br>    Glide glide = builder.build(applicationContext);<br>    <span class="hljs-comment">// 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder</span><br>    <span class="hljs-comment">// 里面（applyOptions）替换glide默认组件（registerComponents）</span><br>    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> :     manifestModules) {<br>      <span class="hljs-keyword">module</span>.register<span class="hljs-constructor">Components(<span class="hljs-params">applicationContext</span>,   <span class="hljs-params">glide</span>, <span class="hljs-params">glide</span>.<span class="hljs-params">registry</span>)</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule != null) {<br>      annotationGeneratedModule.register<span class="hljs-constructor">Components(<span class="hljs-params">appl</span>  <span class="hljs-params">icationContext</span>, <span class="hljs-params">glide</span>, <span class="hljs-params">glide</span>.<span class="hljs-params">registry</span>)</span>;<br>    }<br>    applicationContext.register<span class="hljs-constructor">ComponentCallbacks(<span class="hljs-params">glide</span>    )</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Glide</span>.</span></span>glide = glide;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="GlideBuilder-build"><a href="#GlideBuilder-build" class="headerlink" title="GlideBuilder#build"></a>GlideBuilder#build</h3><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs haxe">@NonNull<br>  Glide build(@NonNull Context context) {<br>    <span class="hljs-comment">// 创建请求图片线程池sourceExecutor</span><br>    <span class="hljs-keyword">if</span> (sourceExecutor == <span class="hljs-literal">null</span>) {<br>      sourceExecutor =   GlideExecutor.<span class="hljs-keyword">new</span><span class="hljs-type">SourceExecutor</span>();<br>    }<br><br>    <span class="hljs-comment">// 创建硬盘缓存线程池diskCacheExecutor</span><br>    <span class="hljs-keyword">if</span> (diskCacheExecutor == <span class="hljs-literal">null</span>) {<br>      diskCacheExecutor =   GlideExecutor.<span class="hljs-keyword">new</span><span class="hljs-type">DiskCacheExecutor</span>();<br>    }<br><br>    <span class="hljs-comment">// 创建动画线程池animationExecutor</span><br>    <span class="hljs-keyword">if</span> (animationExecutor == <span class="hljs-literal">null</span>) {<br>      animationExecutor =   GlideExecutor.<span class="hljs-keyword">new</span><span class="hljs-type">AnimationExecutor</span>();<br>    }<br><br>    <span class="hljs-keyword">if</span> (memorySizeCalculator == <span class="hljs-literal">null</span>) {<br>      memorySizeCalculator = <span class="hljs-keyword">new</span>   <span class="hljs-type">MemorySizeCalculator</span>.Builder(context).build();<br>    }<br><br>    <span class="hljs-keyword">if</span> (connectivityMonitorFactory == <span class="hljs-literal">null</span>) {<br>      connectivityMonitorFactory = <span class="hljs-keyword">new</span>   <span class="hljs-type">DefaultConnectivityMonitorFactory</span>();<br>    }<br><br>    <span class="hljs-keyword">if</span> (bitmapPool == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 依据设备的屏幕密度和尺寸设置各种pool的size</span><br>      int size =   memorySizeCalculator.getBitmapPoolSize();<br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-comment">// 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap</span><br>        <span class="hljs-comment">// 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。</span><br>        <span class="hljs-comment">// 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap</span><br>        bitmapPool = <span class="hljs-keyword">new</span> <span class="hljs-type">LruBitmapPool</span>(size);<br>      } <span class="hljs-keyword">else</span> {<br>        bitmapPool = <span class="hljs-keyword">new</span> <span class="hljs-type">BitmapPoolAdapter</span>();<br>      }<br>    }<br><br>    <span class="hljs-comment">// 创建对象数组缓存池LruArrayPool，默认4M</span><br>    <span class="hljs-keyword">if</span> (arrayPool == <span class="hljs-literal">null</span>) {<br>      arrayPool = <span class="hljs-keyword">new</span>   <span class="hljs-type">LruArrayPool</span>(memorySizeCalculator.getArrayPoolSiz  eInBytes());<br>    }<br><br>    <span class="hljs-comment">// 创建LruResourceCache，内存缓存</span><br>    <span class="hljs-keyword">if</span> (memoryCache == <span class="hljs-literal">null</span>) {<br>      memoryCache = <span class="hljs-keyword">new</span>   <span class="hljs-type">LruResourceCache</span>(memorySizeCalculator.getMemoryCa  cheSize());<br>    }<br><br>    <span class="hljs-keyword">if</span> (diskCacheFactory == <span class="hljs-literal">null</span>) {<br>      diskCacheFactory = <span class="hljs-keyword">new</span>   <span class="hljs-type">InternalCacheDiskCacheFactory</span>(context);<br>    }<br><br>    <span class="hljs-comment">// 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象）</span><br>    <span class="hljs-keyword">if</span> (engine == <span class="hljs-literal">null</span>) {<br>      engine =<br>          <span class="hljs-keyword">new</span> <span class="hljs-type">Engine</span>(<br>              memoryCache,<br>              diskCacheFactory,<br>              diskCacheExecutor,<br>              sourceExecutor,<br>              GlideExecutor.<span class="hljs-keyword">new</span><span class="hljs-type">UnlimitedSourceExecutor</span>(  ),<br>              GlideExecutor.<span class="hljs-keyword">new</span><span class="hljs-type">AnimationExecutor</span>(),<br>              isActiveResourceRetentionAllowed);<br>    }<br>    <br>    RequestManagerRetriever requestManagerRetriever =<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">RequestManagerRetriever</span>(requestManagerFactory);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Glide</span>(<br>        context,<br>        engine,<br>        memoryCache,<br>        bitmapPool,<br>        arrayPool,<br>        requestManagerRetriever,<br>        connectivityMonitorFactory,<br>        logLevel,<br>        defaultRequestOptions.lock(),<br>        defaultTransitionOptions);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="Glide-Glide构造方法"><a href="#Glide-Glide构造方法" class="headerlink" title="Glide#Glide构造方法"></a>Glide#Glide构造方法</h3><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Glide(...) {<br>    ...<br>    <span class="hljs-comment">// 注册管理任务执行对象的类(Registry)</span><br>    <span class="hljs-comment">// Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，</span><br>    <span class="hljs-comment">// 根据当前任务的性质，分发给相应员工进行处理</span><br>    registry = <span class="hljs-keyword">new</span> <span class="hljs-type">Registry</span>();<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件）</span><br>    registry<br>    .append(ByteBuffer.class, <span class="hljs-keyword">new</span> <span class="hljs-type">ByteBufferEncoder</span>())<br>    .append(InputStream.class, <span class="hljs-keyword">new</span> <span class="hljs-type">StreamEncoder</span>(arrayPool))<br>    <br>    <span class="hljs-comment">// 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget)</span><br>    ImageViewTargetFactory imageViewTargetFactory = <span class="hljs-keyword">new</span> <span class="hljs-type">ImageViewTargetFactory</span>();<br>    <br>    glideContext =<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">GlideContext</span>(<br>            context,<br>            arrayPool,<br>            registry,<br>            imageViewTargetFactory,<br>            defaultRequestOptions,<br>            defaultTransitionOptions,<br>            engine,<br>            logLevel);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="RequestManagerRetriever-get"><a href="#RequestManagerRetriever-get" class="headerlink" title="RequestManagerRetriever#get"></a>RequestManagerRetriever#get</h3><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@NonNull</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>{<br>  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You cannot start a load on a null Context"</span>);<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="hljs-keyword">instanceof</span> Application)) {<br>    <span class="hljs-comment">// 如果当前线程是主线程且context不是Application走相应的get重载方法</span><br>    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> FragmentActivity) {<br>      <span class="hljs-keyword">return</span> get((FragmentActivity) context);<br>    } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(context <span class="hljs-keyword">instanceof</span> Activity)</span> </span>{<br>      <span class="hljs-keyword">return</span> get((Activity) context);<br>    } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(context <span class="hljs-keyword">instanceof</span> ContextWrapper)</span> </span>{<br>      <span class="hljs-keyword">return</span> get(((ContextWrapper) context).getBaseContext());<br>    }<br>  }<br><br>  <span class="hljs-comment">// 否则直接将请求与ApplicationLifecycle关联</span><br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">getApplicationManager</span><span class="hljs-params">(context)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(<br>RequestManagerFragment)。</p>
<h3 id="GlideApp-with小结"><a href="#GlideApp-with小结" class="headerlink" title="GlideApp#with小结"></a>GlideApp#with小结</h3><ol>
<li><p>初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象。</p>
</li>
<li><p>将glide请求和application/SupportFragment/Fragment的生命周期绑定在一块。</p>
</li>
</ol>
<h3 id="with方法的执行流程"><a href="#with方法的执行流程" class="headerlink" title="with方法的执行流程"></a>with方法的执行流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a307a034fea446a486c4f988849751a0~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<h2 id="load-url-源码详解"><a href="#load-url-源码详解" class="headerlink" title="load(url)源码详解"></a>load(url)源码详解</h2><h3 id="GlideRequest-RequestManager-load"><a href="#GlideRequest-RequestManager-load" class="headerlink" title="GlideRequest(RequestManager)#load"></a>GlideRequest(RequestManager)#load</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> (GlideRequest&lt;Drawable&gt;) <span class="hljs-keyword">super</span>.load(string);<br><br><span class="hljs-keyword">return</span> asDrawable().load(string);<br><br><span class="hljs-comment">// 1、asDrawable部分</span><br><span class="hljs-keyword">return</span> (GlideRequest&lt;Drawable&gt;) <span class="hljs-keyword">super</span>.asDrawable();<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">as</span>(Drawable.<span class="hljs-keyword">class</span>);<br><br><span class="hljs-comment">// 最终返回了一个GlideRequest（RequestManager的子类）</span><br><span class="hljs-keyword">return</span> new GlideRequest&lt;&gt;(glide, <span class="hljs-keyword">this</span>, resourceClass, context);<br><br><span class="hljs-comment">// 2、load部分</span><br><span class="hljs-keyword">return</span> (GlideRequest&lt;TranscodeType&gt;) <span class="hljs-keyword">super</span>.load(string);<br><br><span class="hljs-keyword">return</span> loadGeneric(string);<br><br><span class="hljs-meta">@NonNull</span><br><span class="hljs-keyword">private</span> RequestBuilder&lt;TranscodeType&gt; loadGeneric(<span class="hljs-meta">@Nullable</span> Object model) {<br>    <span class="hljs-comment">// model则为设置的url</span><br>    <span class="hljs-keyword">this</span>.model = model;<br>    <span class="hljs-comment">// 记录url已设置</span><br>    isModelSet = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。</p>
<h3 id="load方法的执行流程"><a href="#load方法的执行流程" class="headerlink" title="load方法的执行流程"></a>load方法的执行流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33114794d81a421ea4345806826919b7~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<h2 id="into-iv-源码详解"><a href="#into-iv-源码详解" class="headerlink" title="into(iv)源码详解"></a>into(iv)源码详解</h2><p>真正复杂的地方要开始了。</p>
<h3 id="RequestBuilder-into"><a href="#RequestBuilder-into" class="headerlink" title="RequestBuilder.into"></a>RequestBuilder.into</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@NonNull</span><br><span class="hljs-keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt;   <span class="hljs-title function_">into</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ImageView view)</span> {<br>  Util.assertMainThread();<br>  Preconditions.checkNotNull(view);<br><br>  <span class="hljs-type">RequestOptions</span> <span class="hljs-variable">requestOptions</span> <span class="hljs-operator">=</span>     <span class="hljs-built_in">this</span>.requestOptions;<br>  <span class="hljs-keyword">if</span> (!requestOptions.isTransformationSet()<br>      &amp;&amp; requestOptions.isTransformationAllowed()<br>      &amp;&amp; view.getScaleType() != <span class="hljs-literal">null</span>) {<br>    <span class="hljs-comment">// Clone in this method so that if we use this   RequestBuilder to load into a View and then</span><br>    <span class="hljs-comment">// into a different target, we don't retain the   transformation applied based on the previous</span><br>    <span class="hljs-comment">// View's scale type.</span><br>    <span class="hljs-keyword">switch</span> (view.getScaleType()) {<br>      <span class="hljs-comment">// 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、</span><br>      <span class="hljs-comment">// FitCenter、CenterInside四种规格。</span><br>      <span class="hljs-keyword">case</span> CENTER_CROP:<br>        requestOptions =   requestOptions.clone().optionalCenterCrop();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER_INSIDE:<br>        requestOptions =   requestOptions.clone().optionalCenterInside()  ;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_CENTER:<br>      <span class="hljs-keyword">case</span> FIT_START:<br>      <span class="hljs-keyword">case</span> FIT_END:<br>        requestOptions =   requestOptions.clone().optionalFitCenter();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_XY:<br>        requestOptions =   requestOptions.clone().optionalCenterInside()  ;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER:<br>      <span class="hljs-keyword">case</span> MATRIX:<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// Do nothing.</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 注意，这个transcodeClass是指的drawable或bitmap</span><br>  <span class="hljs-keyword">return</span> into(<br>      glideContext.buildImageViewTarget(view,     transcodeClass),<br>      <span class="hljs-comment">/*targetListener=*/</span> <span class="hljs-literal">null</span>,<br>      requestOptions);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="GlideContext-buildImageViewTarget"><a href="#GlideContext-buildImageViewTarget" class="headerlink" title="GlideContext#buildImageViewTarget"></a>GlideContext#buildImageViewTarget</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">return imageViewTargetFactory.build<span class="hljs-constructor">Target(<span class="hljs-params">imageView</span>, <span class="hljs-params">transcodeClass</span>)</span>;<br></code></pre></td></tr></tbody></table></figure>

<h3 id="ImageViewTargetFactory-buildTarget"><a href="#ImageViewTargetFactory-buildTarget" class="headerlink" title="ImageViewTargetFactory#buildTarget"></a>ImageViewTargetFactory#buildTarget</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@NonNull</span><br><span class="hljs-variable">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<br>public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt;   <span class="hljs-built_in">buildTarget</span>(<span class="hljs-variable">@NonNull</span> ImageView view,<br>    <span class="hljs-variable">@NonNull</span> Class&lt;Z&gt; clazz) {<br>  <span class="hljs-comment">// 返回展示Bimtap/Drawable资源的目标对象</span><br>  <span class="hljs-selector-tag">if</span> (Bitmap.class.<span class="hljs-built_in">equals</span>(clazz)) {<br>    <span class="hljs-selector-tag">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="hljs-selector-tag">new</span>   <span class="hljs-selector-tag">BitmapImageViewTarget</span>(view);<br>  } <span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span> (Drawable.class.<span class="hljs-built_in">isAssignableFrom</span>(clazz))     {<br>    <span class="hljs-selector-tag">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="hljs-selector-tag">new</span>   <span class="hljs-selector-tag">DrawableImageViewTarget</span>(view);<br>  } <span class="hljs-selector-tag">else</span> {<br>    <span class="hljs-selector-tag">throw</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">IllegalArgumentException</span>(<br>        <span class="hljs-string">"Unhandled class: "</span> + clazz + <span class="hljs-string">", try   .as*(Class).transcode(ResourceTranscoder)"</span>);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。</p>
<h3 id="RequestBuilder-into-1"><a href="#RequestBuilder-into-1" class="headerlink" title="RequestBuilder#into"></a>RequestBuilder#into</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="hljs-title function_">into</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Y target,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt;   targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> RequestOptions options)</span> {<br>    Util.assertMainThread();<br>    Preconditions.checkNotNull(target);<br>    <span class="hljs-keyword">if</span> (!isModelSet) {<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"You must call   #load() before calling #into()"</span>);<br>    }<br><br>    options = options.autoClone();<br>    <span class="hljs-comment">// 分析1.建立请求</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> buildRequest(target,     targetListener, options);<br><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">previous</span> <span class="hljs-operator">=</span> target.getRequest();<br>    <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)<br>        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques    <span class="hljs-title function_">t</span><span class="hljs-params">(options, previous)</span>) {<br>      request.recycle();<br>      <span class="hljs-comment">// If the request is completed, beginning again   will ensure the result is re-delivered,</span><br>      <span class="hljs-comment">// triggering RequestListeners and Targets. If   the request is failed, beginning again will</span><br>      <span class="hljs-comment">// restart the request, giving it another chance   to complete. If the request is already</span><br>      <span class="hljs-comment">// running, we can let it continue running   without interruption.</span><br>      <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunni  <span class="hljs-title function_">ng</span><span class="hljs-params">()</span>) {<br>        <span class="hljs-comment">// Use the previous request rather than the new     one to allow for optimizations like skipping</span><br>        <span class="hljs-comment">// setting placeholders, tracking and     un-tracking Targets, and obtaining View     dimensions</span><br>        <span class="hljs-comment">// that are done in the individual Request.</span><br>        previous.begin();<br>      }<br>      <span class="hljs-keyword">return</span> target;<br>    }<br>    <br>    requestManager.clear(target);<br>    target.setRequest(request);<br>    <span class="hljs-comment">// 分析2.真正追踪请求的地方</span><br>    requestManager.track(target, request);<br><br>    <span class="hljs-keyword">return</span> target;<br>}<br><br><span class="hljs-comment">// 分析1</span><br><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt;   targetListener,</span><br><span class="hljs-params">      RequestOptions requestOptions)</span> {<br>    <span class="hljs-keyword">return</span> buildRequestRecursive(<br>        target,<br>        targetListener,<br>        <span class="hljs-comment">/*parentCoordinator=*/</span> <span class="hljs-literal">null</span>,<br>        transitionOptions,<br>        requestOptions.getPriority(),<br>        requestOptions.getOverrideWidth(),<br>        requestOptions.getOverrideHeight(),<br>        requestOptions);<br>}<br><br><span class="hljs-comment">// 分析1</span><br><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildRequestRecursive</span><span class="hljs-params">(</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt;   targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestCoordinator parentCoordinator,</span><br><span class="hljs-params">      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt;   transitionOptions,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">      RequestOptions requestOptions)</span> {<br><br>    <span class="hljs-comment">// Build the ErrorRequestCoordinator first if     necessary so we can update parentCoordinator.</span><br>    <span class="hljs-type">ErrorRequestCoordinator</span> <span class="hljs-variable">errorRequestCoordinator</span> <span class="hljs-operator">=</span>     <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (errorBuilder != <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 创建errorRequestCoordinator（异常处理对象）</span><br>      errorRequestCoordinator = <span class="hljs-keyword">new</span>   <span class="hljs-title class_">ErrorRequestCoordinator</span>(parentCoordinator);<br>      parentCoordinator = errorRequestCoordinator;<br>    }<br><br>    <span class="hljs-comment">// 递归建立缩略图请求</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">mainRequest</span> <span class="hljs-operator">=</span><br>        buildThumbnailRequestRecursive(<br>            target,<br>            targetListener,<br>            parentCoordinator,<br>            transitionOptions,<br>            priority,<br>            overrideWidth,<br>            overrideHeight,<br>            requestOptions);<br><br>    <span class="hljs-keyword">if</span> (errorRequestCoordinator == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">return</span> mainRequest;<br>    }<br><br>    ...<br>    <br>    <span class="hljs-type">Request</span> <span class="hljs-variable">errorRequest</span> <span class="hljs-operator">=</span>     errorBuilder.buildRequestRecursive(<br>        target,<br>        targetListener,<br>        errorRequestCoordinator,<br>        errorBuilder.transitionOptions,<br>        errorBuilder.requestOptions.getPriority(),<br>        errorOverrideWidth,<br>        errorOverrideHeight,<br>        errorBuilder.requestOptions);<br>    errorRequestCoordinator.setRequests(mainRequest,     errorRequest);<br>    <span class="hljs-keyword">return</span> errorRequestCoordinator;<br>}<br><br><span class="hljs-comment">// 分析1</span><br><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildThumbnailRequestRecursive</span><span class="hljs-params">(</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestCoordinator parentCoordinator,</span><br><span class="hljs-params">      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; transitionOptions,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">      RequestOptions requestOptions)</span> {<br>    <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// Recursive case: contains a potentially recursive thumbnail request builder.</span><br>      <br>      ...<br><br>      <span class="hljs-type">ThumbnailRequestCoordinator</span> <span class="hljs-variable">coordinator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThumbnailRequestCoordinator</span>(parentCoordinator);<br>      <span class="hljs-comment">// 获取一个正常请求对象</span><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">fullRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              target,<br>              targetListener,<br>              requestOptions,<br>              coordinator,<br>              transitionOptions,<br>              priority,<br>              overrideWidth,<br>              overrideHeight);<br>      isThumbnailBuilt = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// Recursively generate thumbnail requests.</span><br>      <span class="hljs-comment">// 使用递归的方式建立一个缩略图请求对象</span><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">thumbRequest</span> <span class="hljs-operator">=</span><br>          thumbnailBuilder.buildRequestRecursive(<br>              target,<br>              targetListener,<br>              coordinator,<br>              thumbTransitionOptions,<br>              thumbPriority,<br>              thumbOverrideWidth,<br>              thumbOverrideHeight,<br>              thumbnailBuilder.requestOptions);<br>      isThumbnailBuilt = <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// coordinator（ThumbnailRequestCoordinator）是作为两者的协调者，</span><br>      <span class="hljs-comment">// 能够同时加载缩略图和正常的图的请求</span><br>      coordinator.setRequests(fullRequest, thumbRequest);<br>      <span class="hljs-keyword">return</span> coordinator;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span><br>      <span class="hljs-comment">// 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，</span><br>      <span class="hljs-comment">// 不需要递归建立缩略图请求</span><br>      <span class="hljs-type">ThumbnailRequestCoordinator</span> <span class="hljs-variable">coordinator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThumbnailRequestCoordinator</span>(parentCoordinator);<br>      <span class="hljs-type">Request</span> <span class="hljs-variable">fullRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              target,<br>              targetListener,<br>              requestOptions,<br>              coordinator,<br>              transitionOptions,<br>              priority,<br>              overrideWidth,<br>              overrideHeight);<br>      <span class="hljs-type">RequestOptions</span> <span class="hljs-variable">thumbnailOptions</span> <span class="hljs-operator">=</span> requestOptions.clone()<br>          .sizeMultiplier(thumbSizeMultiplier);<br><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">thumbnailRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              target,<br>              targetListener,<br>              thumbnailOptions,<br>              coordinator,<br>              transitionOptions,<br>              getThumbnailPriority(priority),<br>              overrideWidth,<br>              overrideHeight);<br><br>      coordinator.setRequests(fullRequest, thumbnailRequest);<br>      <span class="hljs-keyword">return</span> coordinator;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// Base case: no thumbnail.</span><br>      <span class="hljs-comment">// 没有缩略图请求时，直接获取一个正常图请求</span><br>      <span class="hljs-keyword">return</span> obtainRequest(<br>          target,<br>          targetListener,<br>          requestOptions,<br>          parentCoordinator,<br>          transitionOptions,<br>          priority,<br>          overrideWidth,<br>          overrideHeight);<br>    }<br>}<br><br><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">obtainRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">      RequestOptions requestOptions,</span><br><span class="hljs-params">      RequestCoordinator requestCoordinator,</span><br><span class="hljs-params">      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt;   transitionOptions,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight)</span> {<br>    <span class="hljs-comment">// 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target</span><br>    <span class="hljs-keyword">return</span> SingleRequest.obtain(<br>        context,<br>        glideContext,<br>        model,<br>        transcodeClass,<br>        requestOptions,<br>        overrideWidth,<br>        overrideHeight,<br>        priority,<br>        target,<br>        targetListener,<br>        requestListeners,<br>        requestCoordinator,<br>        glideContext.getEngine(),<br>        transitionOptions.getTransitionFactory());<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从上源码分析可知，我们在分析1处的buildRequest()<br>方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)<br>方法，接着看看track里面做了什么。</p>
<h3 id="RequestManager-track"><a href="#RequestManager-track" class="headerlink" title="RequestManager#track"></a>RequestManager#track</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 分析2</span><br><span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">track</span>(<span class="hljs-variable">@NonNull</span> Target&lt;?&gt; target, <span class="hljs-variable">@NonNull</span> Request request) {<br>    <span class="hljs-comment">// 加入一个target目标集合(Set)</span><br>    <span class="hljs-selector-tag">targetTracker</span><span class="hljs-selector-class">.track</span>(target);<br>    <br>    <span class="hljs-selector-tag">requestTracker</span><span class="hljs-selector-class">.runRequest</span>(request);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="RequestTracker-runRequest"><a href="#RequestTracker-runRequest" class="headerlink" title="RequestTracker#runRequest"></a>RequestTracker#runRequest</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Starts tracking the given request.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 分析2</span><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">runRequest</span>(<span class="hljs-variable">@NonNull</span> Request request) {<br>    <span class="hljs-selector-tag">requests</span><span class="hljs-selector-class">.add</span>(request);<br>    <span class="hljs-selector-tag">if</span> (!isPaused) {<br>      <span class="hljs-comment">// 如果不是暂停状态则开始请求</span><br>      <span class="hljs-selector-tag">request</span><span class="hljs-selector-class">.begin</span>();<br>    } <span class="hljs-selector-tag">else</span> {<br>      <span class="hljs-selector-tag">request</span><span class="hljs-selector-class">.clear</span>();<br>      <span class="hljs-selector-tag">if</span> (Log.<span class="hljs-built_in">isLoggable</span>(TAG, Log.VERBOSE)) {<br>        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.v</span>(TAG, <span class="hljs-string">"Paused, delaying request"</span>);<br>      }<br>      <span class="hljs-comment">// 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现）</span><br>      <span class="hljs-selector-tag">pendingRequests</span><span class="hljs-selector-class">.add</span>(request);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="SingleRequest-begin"><a href="#SingleRequest-begin" class="headerlink" title="SingleRequest#begin"></a>SingleRequest#begin</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 分析2</span><br>@Override<br>public void <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  </span><span class="hljs-keyword">if</span> (model<span class="hljs-operator"> == </span>null) {<span class="hljs-operator"></span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><span class="hljs-comment">// model（url）为空，回调加载失败</span><br>    on<span class="hljs-constructor">LoadFailed(<span class="hljs-params">new</span> GlideException(<span class="hljs-string">"Received null   model"</span>)</span>, logLevel);<br>    return;<br>  }<br><br>  <span class="hljs-keyword">if</span> (status<span class="hljs-operator"> == </span>Status.RUNNING) {<br>    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">"Cannot   restart a running request"</span>)</span>;<br>  }<br><br> <br>  <span class="hljs-keyword">if</span> (status<span class="hljs-operator"> == </span>Status.COMPLETE) {<br>    on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">resource</span>,   DataSource.MEMORY_CACHE)</span>;<br>    return;<br>  }<br><br>  status = Status.WAITING_FOR_SIZE;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Util</span>.</span></span>is<span class="hljs-constructor">ValidDimensions(<span class="hljs-params">overrideWidth</span>, <span class="hljs-params">overrideHeight</span>)</span>) {<br>    <span class="hljs-comment">// 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady，</span><br>    <span class="hljs-comment">// 最终的核心处理位于onSizeReady</span><br>    on<span class="hljs-constructor">SizeReady(<span class="hljs-params">overrideWidth</span>, <span class="hljs-params">overrideHeight</span>)</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady</span><br>    target.get<span class="hljs-constructor">Size(<span class="hljs-params">this</span>)</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> ((status<span class="hljs-operator"> == </span>Status.RUNNING<span class="hljs-operator"> || </span>status<span class="hljs-operator"> ==     </span>Status.WAITING_FOR_SIZE)<span class="hljs-operator"></span><br><span class="hljs-operator">      &amp;&amp; </span>can<span class="hljs-constructor">NotifyStatusChanged()</span>) {<br>    <span class="hljs-comment">// 预先加载设置的缩略图</span><br>    target.on<span class="hljs-constructor">LoadStarted(<span class="hljs-params">getPlaceholderDrawable</span>()</span>);<br>  }<br>  <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) {<br>    log<span class="hljs-constructor">V(<span class="hljs-string">"finished run method in "</span> +   LogTime.<span class="hljs-params">getElapsedMillis</span>(<span class="hljs-params">startTime</span>)</span>);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()<br>方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~</p>
<h3 id="SingleRequest-onSizeReady"><a href="#SingleRequest-onSizeReady" class="headerlink" title="SingleRequest#onSizeReady"></a>SingleRequest#onSizeReady</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 分析2</span><br>@Override<br>public void on<span class="hljs-constructor">SizeReady(<span class="hljs-params">int</span> <span class="hljs-params">width</span>, <span class="hljs-params">int</span> <span class="hljs-params">height</span>)</span> {<br>  stateVerifier.throw<span class="hljs-constructor">IfRecycled()</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  </span>status = Status.RUNNING;<br><br>  <span class="hljs-built_in">float</span> sizeMultiplier =     requestOptions.get<span class="hljs-constructor">SizeMultiplier()</span>;<br>  this.width = maybe<span class="hljs-constructor">ApplySizeMultiplier(<span class="hljs-params">width</span>,     <span class="hljs-params">sizeMultiplier</span>)</span>;<br>  this.height = maybe<span class="hljs-constructor">ApplySizeMultiplier(<span class="hljs-params">height</span>,     <span class="hljs-params">sizeMultiplier</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  </span><span class="hljs-comment">// 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类</span><br>  loadStatus = engine.load(<br>      glideContext,<br>      model,<br>      requestOptions.get<span class="hljs-constructor">Signature()</span>,<br>      this.width,<br>      this.height,<br>      requestOptions.get<span class="hljs-constructor">ResourceClass()</span>,<br>      transcodeClass,<br>      priority,<br>      requestOptions.get<span class="hljs-constructor">DiskCacheStrategy()</span>,<br>      requestOptions.get<span class="hljs-constructor">Transformations()</span>,<br>      requestOptions.is<span class="hljs-constructor">TransformationRequired()</span>,<br>      requestOptions.is<span class="hljs-constructor">ScaleOnlyOrNoTransform()</span>,<br>      requestOptions.get<span class="hljs-constructor">Options()</span>,<br>      requestOptions.is<span class="hljs-constructor">MemoryCacheable()</span>,<br>      requestOptions.getUseUnlimitedSourceGeneratorsP    ool<span class="hljs-literal">()</span>,<br>      requestOptions.get<span class="hljs-constructor">UseAnimationPool()</span>,<br>      requestOptions.get<span class="hljs-constructor">OnlyRetrieveFromCache()</span>,<br>      this);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>终于看到Engine类了，感觉距离成功不远了，继续~</p>
<h3 id="Engine-load"><a href="#Engine-load" class="headerlink" title="Engine#load"></a>Engine#load</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;R&gt; LoadStatus load(<br>    GlideContext glideContext,<br>    Object model,<br>    Key signature,<br>    <span class="hljs-built_in">int</span> width,<br>    <span class="hljs-built_in">int</span> height,<br>    Class&lt;?&gt; resourceClass,<br>    Class&lt;R&gt; transcodeClass,<br>    Priority priority,<br>    DiskCacheStrategy diskCacheStrategy,<br>    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,<br>    boolean isTransformationRequired,<br>    boolean isScaleOnlyOrNoTransform,<br>    Options options,<br>    boolean isMemoryCacheable,<br>    boolean useUnlimitedSourceExecutorPool,<br>    boolean useAnimationPool,<br>    boolean onlyRetrieveFromCache,<br>    ResourceCallback cb) {<span class="hljs-operator"></span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  </span><span class="hljs-comment">// 先从弱引用中查找，如果有的话回调onResourceReady并直接返回</span><br>  EngineResource&lt;?&gt; active = load<span class="hljs-constructor">FromActiveResources(<span class="hljs-params">key</span>, <span class="hljs-params">isMemoryCacheable</span>)</span>;<br>  <span class="hljs-keyword">if</span> (active != null) {<br>    cb.on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">active</span>,   DataSource.MEMORY_CACHE)</span>;<br>    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) {<br>      log<span class="hljs-constructor">WithTimeAndKey(<span class="hljs-string">"Loaded resource from active     resources"</span>, <span class="hljs-params">startTime</span>, <span class="hljs-params">key</span>)</span>;<br>    }<br>    return null;<br>  }<br><br>  <span class="hljs-comment">// 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面</span><br>  EngineResource&lt;?&gt; cached = load<span class="hljs-constructor">FromCache(<span class="hljs-params">key</span>,     <span class="hljs-params">isMemoryCacheable</span>)</span>;<br>  <span class="hljs-keyword">if</span> (cached != null) {<br>    cb.on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">cached</span>,   DataSource.MEMORY_CACHE)</span>;<br>    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) {<br>      log<span class="hljs-constructor">WithTimeAndKey(<span class="hljs-string">"Loaded resource from cache"</span>,     <span class="hljs-params">startTime</span>, <span class="hljs-params">key</span>)</span>;<br>    }<br>    return null;<br>  }<br><br>  EngineJob&lt;?&gt; current = jobs.get(key,     onlyRetrieveFromCache);<br>  <span class="hljs-keyword">if</span> (current != null) {<br>    current.add<span class="hljs-constructor">Callback(<span class="hljs-params">cb</span>)</span>;<br>    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) {<br>      log<span class="hljs-constructor">WithTimeAndKey(<span class="hljs-string">"Added to existing load"</span>,     <span class="hljs-params">startTime</span>, <span class="hljs-params">key</span>)</span>;<br>    }<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoadStatus(<span class="hljs-params">cb</span>, <span class="hljs-params">current</span>)</span>;<br>  }<br><br>  <span class="hljs-comment">// 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）</span><br>  EngineJob&lt;R&gt; engineJob =<br>      engineJobFactory.build(<br>          key,<br>          isMemoryCacheable,<br>          useUnlimitedSourceExecutorPool,<br>          useAnimationPool,<br>          onlyRetrieveFromCache);<br><br>  <span class="hljs-comment">// 创建解析工作对象</span><br>  DecodeJob&lt;R&gt; decodeJob =<br>      decodeJobFactory.build(<br>          glideContext,<br>          model,<br>          key,<br>          signature,<br>          width,<br>          height,<br>          resourceClass,<br>          transcodeClass,<br>          priority,<br>          diskCacheStrategy,<br>          transformations,<br>          isTransformationRequired,<br>          isScaleOnlyOrNoTransform,<br>          onlyRetrieveFromCache,<br>          options,<br>          engineJob);<br><br>  <span class="hljs-comment">// 放在Jobs内部维护的HashMap中</span><br>  jobs.put(key, engineJob);<br><br>  <span class="hljs-comment">// 关注点8 后面分析会用到</span><br>  <span class="hljs-comment">// 注册ResourceCallback接口</span><br>  engineJob.add<span class="hljs-constructor">Callback(<span class="hljs-params">cb</span>)</span>;<br>  <span class="hljs-comment">// 内部开启线程去请求</span><br>  engineJob.start(decodeJob);<br><br>  <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) {<br>    log<span class="hljs-constructor">WithTimeAndKey(<span class="hljs-string">"Started new load"</span>, <span class="hljs-params">startTime</span>,   <span class="hljs-params">key</span>)</span>;<br>  }<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoadStatus(<span class="hljs-params">cb</span>, <span class="hljs-params">engineJob</span>)</span>;<br>}<br><br>public void start(DecodeJob&lt;R&gt; decodeJob) {<br>    this.decodeJob = decodeJob;<br>    <span class="hljs-comment">// willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor</span><br>    GlideExecutor executor =   <br>    decodeJob.will<span class="hljs-constructor">DecodeFromCache()</span><br>        ? diskCacheExecutor<br>        : get<span class="hljs-constructor">ActiveSourceExecutor()</span>;<br>    executor.execute(decodeJob);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，最终Engine(引擎)<br>类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。</p>
<h3 id="DecodeJob-run"><a href="#DecodeJob-run" class="headerlink" title="DecodeJob#run"></a>DecodeJob#run</h3><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp">runWrapped();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWrapped</span>()</span> {<br>    <span class="hljs-keyword">switch</span> (runReason) {<br>      <span class="hljs-keyword">case</span> INITIALIZE:<br>        stage = getNextStage(Stage.INITIALIZE);<br>        <span class="hljs-comment">// 关注点1</span><br>        currentGenerator = getNextGenerator();<br>        <span class="hljs-comment">// 关注点2 内部会调用相应Generator的startNext()</span><br>        runGenerators();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> SWITCH_TO_SOURCE_SERVICE:<br>        runGenerators();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> DECODE_DATA:<br>        <span class="hljs-comment">// 关注点3 将获取的数据解码成对应的资源</span><br>        decodeFromRetrievedData();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-literal">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized     run reason: "</span> + runReason);<br>    }<br>}<br><br><span class="hljs-comment">// 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> DataFetcherGenerator <span class="hljs-title">getNextGenerator</span>()</span> {<br>    <span class="hljs-keyword">switch</span> (stage) {<br>      <span class="hljs-keyword">case</span> RESOURCE_CACHE:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> DATA_CACHE:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> SOURCE:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> FINISHED:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-literal">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized     stage: "</span> + stage);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="SourceGenerator-startNext"><a href="#SourceGenerator-startNext" class="headerlink" title="SourceGenerator#startNext"></a>SourceGenerator#startNext</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关注点2</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> {<br>  <span class="hljs-comment">// dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的）</span><br>  <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-literal">null</span>) {<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataToCache;<br>    dataToCache = <span class="hljs-literal">null</span>;<br>    cacheData(data);<br>  }<br><br>  <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-literal">null</span> &amp;&amp;     sourceCacheGenerator.startNext()) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  sourceCacheGenerator = <span class="hljs-literal">null</span>;<br><br>  loadData = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {<br>    <span class="hljs-comment">// 关注点4 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象</span><br>    <span class="hljs-comment">// （每个Generator对应一个ModelLoader），</span><br>    <span class="hljs-comment">// 并使用modelLoader.buildLoadData方法返回一个loadData列表</span><br>    loadData =   helper.getLoadData().get(loadDataListIndex++);<br>    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span><br>        &amp;&amp; (helper.getDiskCacheStrategy().isDataCache  <span class="hljs-title function_">able</span><span class="hljs-params">(loadData.fetcher.getDataSource()</span>)<br>        || helper.hasLoadPath(loadData.fetcher.getDat  <span class="hljs-title function_">aClass</span><span class="hljs-params">()</span>))) {<br>      started = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 关注点6 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的</span><br>      <span class="hljs-comment">// loadData方法来获取图片数据</span><br>      loadData.fetcher.loadData(helper.getPriority(),     <span class="hljs-built_in">this</span>);<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> started;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="DecodeHelper-getLoadData"><a href="#DecodeHelper-getLoadData" class="headerlink" title="DecodeHelper#getLoadData"></a>DecodeHelper#getLoadData</h3><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;LoadData&lt;?&gt;&gt; getLoadData() {<br>    <span class="hljs-keyword">if</span> (!isLoadDataSet) {<br>      isLoadDataSet = <span class="hljs-keyword">true</span>;<br>      loadData.clear();<br>      List&lt;ModelLoader&lt;<span class="hljs-keyword">Object</span>, ?&gt;&gt; modelLoaders =   glideContext.getRegistry().getModelLoaders(model)  ;<br>      //noinspection ForLoopReplaceableByForEach <span class="hljs-keyword">to</span>   improve perf<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, size = modelLoaders.size(); i &lt;   size; i++) {<br>        ModelLoader&lt;<span class="hljs-keyword">Object</span>, ?&gt; modelLoader =     modelLoaders.<span class="hljs-keyword">get</span>(i);<br>        // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象<br>        LoadData&lt;?&gt; <span class="hljs-keyword">current</span> =<br>            modelLoader.buildLoadData(model, width,     height, <span class="hljs-keyword">options</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span> != <span class="hljs-keyword">null</span>) {<br>          loadData.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">current</span>);<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> loadData;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="HttpGlideUrlLoader-buildLoadData"><a href="#HttpGlideUrlLoader-buildLoadData" class="headerlink" title="HttpGlideUrlLoader#buildLoadData"></a>HttpGlideUrlLoader#buildLoadData</h3><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs processing">@Override<br><span class="hljs-keyword">public</span> LoadData&lt;InputStream&gt; <span class="hljs-title function_">buildLoadData</span>(@NonNull   GlideUrl model, <span class="hljs-type">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">height</span>,<br>    @NonNull Options options) {<br>  <span class="hljs-comment">// GlideUrls memoize parsed URLs so caching them     saves a few object instantiations and time</span><br>  <span class="hljs-comment">// spent parsing urls.</span><br>  GlideUrl url = model;<br>  <span class="hljs-keyword">if</span> (modelCache != <span class="hljs-literal">null</span>) {<br>    url = modelCache.<span class="hljs-property">get</span>(model, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 关注点5</span><br>      modelCache.<span class="hljs-property">put</span>(model, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, model);<br>      url = model;<br>    }<br>  }<br>  <span class="hljs-type">int</span> timeout = options.<span class="hljs-property">get</span>(TIMEOUT);<br>  <span class="hljs-comment">// 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">LoadData</span>&lt;&gt;(url, <span class="hljs-keyword">new </span><span class="hljs-class title_">HttpUrlFetcher</span>(url,     timeout));<br>}<br><br><span class="hljs-comment">// 关注点5</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span>(A model, <span class="hljs-type">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">height</span>, B value) {<br>    ModelKey&lt;A&gt; <span class="hljs-built_in">key</span> = ModelKey.<span class="hljs-property">get</span>(model, <span class="hljs-built_in">width</span>,     <span class="hljs-built_in">height</span>);<br>    <span class="hljs-comment">// 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）</span><br>    cache.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, value);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p>
<h3 id="HttpUrlFetcher-loadData"><a href="#HttpUrlFetcher-loadData" class="headerlink" title="HttpUrlFetcher#loadData"></a>HttpUrlFetcher#loadData</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Priority priority,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> DataCallback&lt;? <span class="hljs-built_in">super</span> InputStream&gt;   callback)</span> {<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-comment">// 关注点6</span><br>    <span class="hljs-comment">// loadDataWithRedirects内部是通过HttpURLConnection网络请求数据</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>   loadDataWithRedirects(glideUrl.toURL(), <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,   glideUrl.getHeaders());<br>    <span class="hljs-comment">// 请求成功回调onDataReady()</span><br>    callback.onDataReady(result);<br>  } <span class="hljs-keyword">catch</span> (IOException e) {<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {<br>      Log.d(TAG, <span class="hljs-string">"Failed to load data for url"</span>, e);<br>    }<br>    callback.onLoadFailed(e);<br>  } <span class="hljs-keyword">finally</span> {<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {<br>      Log.v(TAG, <span class="hljs-string">"Finished http url fetcher fetch in     "</span> + LogTime.getElapsedMillis(startTime));<br>    }<br>  }<br>}<br><br><span class="hljs-keyword">private</span> InputStream <span class="hljs-title function_">loadDataWithRedirects</span><span class="hljs-params">(URL url, <span class="hljs-type">int</span> redirects, URL lastUrl,</span><br><span class="hljs-params">  Map&lt;String, String&gt; headers)</span> <span class="hljs-keyword">throws</span> IOException {<br>    <br>    ...<br><br>    urlConnection.connect();<br>    <span class="hljs-comment">// Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.</span><br>    stream = urlConnection.getInputStream();<br>    <span class="hljs-keyword">if</span> (isCancelled) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> urlConnection.getResponseCode();<br>    <span class="hljs-comment">// 只要是2xx形式的状态码则判断为成功</span><br>    <span class="hljs-keyword">if</span> (isHttpOk(statusCode)) {<br>      <span class="hljs-comment">// 从urlConnection中获取资源流</span><br>      <span class="hljs-keyword">return</span> getStreamForSuccessfulRequest(urlConnection);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isHttpRedirect(statusCode)) {<br>    <br>      ...<br>      <br>      <span class="hljs-comment">// 重定向请求</span><br>      <span class="hljs-keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="hljs-number">1</span>, url,   headers);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusCode == INVALID_STATUS_CODE) {<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(statusCode);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(urlConnection.getResponseMessage(),   statusCode);<br>    }<br>}<br><br><span class="hljs-keyword">private</span> InputStream <span class="hljs-title function_">getStreamForSuccessfulRequest</span><span class="hljs-params">(HttpURLConnection urlConnection)</span><br>  <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-keyword">if</span> (TextUtils.isEmpty(urlConnection.getContentEncoding())) {<br>      <span class="hljs-type">int</span> <span class="hljs-variable">contentLength</span> <span class="hljs-operator">=</span> urlConnection.getContentLength();<br>      stream = ContentLengthInputStream.obtain(urlConnection.getInputStr  <span class="hljs-title function_">eam</span><span class="hljs-params">()</span>, contentLength);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {<br>        Log.d(TAG, <span class="hljs-string">"Got non empty content encoding: "</span> +     urlConnection.getContentEncoding());<br>      }<br>      stream = urlConnection.getInputStream();<br>    }<br>    <span class="hljs-keyword">return</span> stream;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()<br>方法获取到了最终的图片流。</p>
<h3 id="DecodeJob-run-1"><a href="#DecodeJob-run-1" class="headerlink" title="DecodeJob#run"></a>DecodeJob#run</h3><p>在我们通过HtttpUrlFetcher的loadData()方法请求得到对应的流之后，我们还必须对流进行处理得到最终我们想要的资源。这里我们回到第10步DecodeJob#run方法的关注点3处，这行代码将会对流进行解码。</p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decodeFromRetrievedData</span>();<br></code></pre></td></tr></tbody></table></figure>

<p>接下来，继续看看他内部的处理。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> void decodeFromRetrievedData() {<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {<br>      logWithTimeAndKey(<span class="hljs-string">"Retrieved data"</span>, startFetchTime,<br>          <span class="hljs-string">"data: "</span> + currentData<br>              + <span class="hljs-string">", cache key: "</span> + currentSourceKey<br>              + <span class="hljs-string">", fetcher: "</span> + currentFetcher);<br>    }<br>    Resource&lt;R&gt; resource = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">//  核心代码 </span><br>      <span class="hljs-comment">// 从数据中解码得到资源</span><br>      resource = decodeFromData(currentFetcher, currentData,   currentDataSource);<br>    } <span class="hljs-keyword">catch</span> (GlideException e) {<br>      e.setLoggingDetails(currentAttemptingKey, currentDataSource);<br>      throwables.add(e);<br>    }<br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 关注点8 </span><br>      <span class="hljs-comment">// 编码和发布最终得到的Resource&lt;Bitmap&gt;对象</span><br>      notifyEncodeAndRelease(resource, currentDataSource);<br>    } <span class="hljs-keyword">else</span> {<br>      runGenerators();<br>    }<br>}<br><br> <span class="hljs-keyword">private</span> &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data <span class="hljs-keyword">data</span>,<br>  DataSource dataSource) throws GlideException {<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      }<br>      long startTime = LogTime.getLogTime();<br>      <span class="hljs-comment">// 核心代码</span><br>      <span class="hljs-comment">// 进一步包装了解码方法</span><br>      Resource&lt;R&gt; result = decodeFromFetcher(<span class="hljs-keyword">data</span>, dataSource);<br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {<br>        logWithTimeAndKey(<span class="hljs-string">"Decoded result "</span> + result, startTime);<br>      }<br>      <span class="hljs-keyword">return</span> result;<br>    } <span class="hljs-keyword">finally</span> {<br>      fetcher.cleanup();<br>    }<br>}<br><br><span class="hljs-meta">@SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br><span class="hljs-keyword">private</span> &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data <span class="hljs-keyword">data</span>, DataSource dataSource)<br>  throws GlideException {<br>    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) <span class="hljs-keyword">data</span>.getClass());<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-comment">// 将解码任务分发给LoadPath</span><br>    <span class="hljs-keyword">return</span> runLoadPath(<span class="hljs-keyword">data</span>, dataSource, path);<br>}<br><br><span class="hljs-keyword">private</span> &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data <span class="hljs-keyword">data</span>, DataSource dataSource,<br>  LoadPath&lt;Data, ResourceType, R&gt; path) throws GlideException {<br>    Options options = getOptionsWithHardwareConfig(dataSource);<br>    <span class="hljs-comment">// 将数据进一步包装</span><br>    DataRewinder&lt;Data&gt; rewinder =     glideContext.getRegistry().getRewinder(<span class="hljs-keyword">data</span>);<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">// ResourceType in DecodeCallback below is required for   compilation to work with gradle.</span><br>      <span class="hljs-comment">// 核心代码</span><br>      <span class="hljs-comment">// 将解码任务分发给LoadPath</span><br>      <span class="hljs-keyword">return</span> path.load(<br>          rewinder, options, width, height, new   DecodeCallback&lt;ResourceType&gt;(dataSource));<br>    } <span class="hljs-keyword">finally</span> {<br>      rewinder.cleanup();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="LoadPath-load"><a href="#LoadPath-load" class="headerlink" title="LoadPath#load"></a>LoadPath#load</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="hljs-built_in">int</span> width,<br>  <span class="hljs-built_in">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) throws GlideException {<br>List&lt;Throwable&gt; throwables = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Preconditions</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">listPool</span>.<span class="hljs-params">acquire</span>()</span>);<br><span class="hljs-keyword">try</span> {<br>  <span class="hljs-comment">// 核心代码</span><br>  return load<span class="hljs-constructor">WithExceptionList(<span class="hljs-params">rewinder</span>, <span class="hljs-params">options</span>, <span class="hljs-params">width</span>, <span class="hljs-params">height</span>, <span class="hljs-params">decodeCallback</span>, <span class="hljs-params">throwables</span>)</span>;<br>} finally {<br>  listPool.release(throwables);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>}</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder,<br>      @NonNull <span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span>,<br>      <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt;   decodeCallback,<br>      List&lt;Throwable&gt; exceptions) <span class="hljs-keyword">throws</span> GlideException {<br>    Resource&lt;Transcode&gt; result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-keyword">size</span> = decodePaths.<span class="hljs-keyword">size</span>(); i &lt; <span class="hljs-keyword">size</span>; i++) {<br>      DecodePath&lt;Data, ResourceType, Transcode&gt; path =   decodePaths.get(i);<br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 核心代码</span><br>        <span class="hljs-comment">// 将解码任务又进一步分发给DecodePath的decode方法去解码</span><br>        result = path.decode(rewinder, width, height, <span class="hljs-keyword">options</span>,     decodeCallback);<br>      } <span class="hljs-keyword">catch</span> (GlideException e) {<br>        exceptions.add(e);<br>      }<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">break</span>;<br>      }<br>    }<br><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlideException(failureMessage, <span class="hljs-keyword">new</span>   ArrayList&lt;&gt;(exceptions));<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="DecodePath-decode"><a href="#DecodePath-decode" class="headerlink" title="DecodePath#decode"></a>DecodePath#decode</h3><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title function_">decode</span>(DataRewinder&lt;DataType&gt; rewinder,     <span class="hljs-type">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">height</span>,<br>      @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)   <span class="hljs-keyword">throws</span> GlideException {<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-comment">// 继续调用DecodePath的decodeResource方法去解析出数据</span><br>    Resource&lt;ResourceType&gt; decoded = <span class="hljs-title function_">decodeResource</span>(rewinder, <span class="hljs-built_in">width</span>,     <span class="hljs-built_in">height</span>, options);<br>    Resource&lt;ResourceType&gt; transformed =     callback.<span class="hljs-property">onResourceDecoded</span>(decoded);<br>    <span class="hljs-keyword">return</span> transcoder.<span class="hljs-property">transcode</span>(transformed, options);<br>}<br><br>@NonNull<br><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; <span class="hljs-title function_">decodeResource</span>(DataRewinder&lt;DataType&gt;   rewinder, <span class="hljs-type">int</span> <span class="hljs-built_in">width</span>,<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">height</span>, @NonNull Options options) <span class="hljs-keyword">throws</span> GlideException {<br>  List&lt;Throwable&gt; exceptions =     Preconditions.<span class="hljs-property">checkNotNull</span>(listPool.<span class="hljs-property">acquire</span>());<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">decodeResourceWithList</span>(rewinder, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>, options,   exceptions);<br>  } <span class="hljs-keyword">finally</span> {<br>    listPool.<span class="hljs-property">release</span>(exceptions);<br>  }<br>}<br><br>@NonNull<br><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt;   <span class="hljs-title function_">decodeResourceWithList</span>(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-type">int</span> <span class="hljs-built_in">width</span>,<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">height</span>, @NonNull Options options, List&lt;Throwable&gt; exceptions)   <span class="hljs-keyword">throws</span> GlideException {<br>  Resource&lt;ResourceType&gt; result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span> = decoders.<span class="hljs-property">size</span>(); i &lt; <span class="hljs-built_in">size</span>; i++) {<br>    ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.<span class="hljs-property">get</span>(i);<br>    <span class="hljs-keyword">try</span> {<br>      DataType data = rewinder.<span class="hljs-property">rewindAndGet</span>();<br>      <span class="hljs-keyword">if</span> (decoder.<span class="hljs-property">handles</span>(data, options)) {<br>        <span class="hljs-comment">// 获取包装的数据</span><br>        data = rewinder.<span class="hljs-property">rewindAndGet</span>();<br>        <span class="hljs-comment">// 核心代码 </span><br>        <span class="hljs-comment">// 根据DataType和ResourceType的类型分发给不同的解码器Decoder</span><br>        result = decoder.<span class="hljs-property">decode</span>(data, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>, options);<br>      }<br>    } <span class="hljs-title function_">catch</span> (IOException | RuntimeException | OutOfMemoryError e) {<br>      <span class="hljs-keyword">if</span> (Log.<span class="hljs-property">isLoggable</span>(TAG, Log.<span class="hljs-property">VERBOSE</span>)) {<br>        Log.<span class="hljs-property">v</span>(TAG, <span class="hljs-string">"Failed to decode data for "</span> + decoder, e);<br>      }<br>      exceptions.<span class="hljs-property">add</span>(e);<br>    }<br><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">break</span>;<br>    }<br>  }<br><br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">GlideException</span>(failureMessage, <span class="hljs-keyword">new   </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;(exceptions));<br>  }<br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder&lt;DataType, ResourceType&gt;<br>接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。</p>
<h3 id="ByteBufferBitmapDecoder-decode"><a href="#ByteBufferBitmapDecoder-decode" class="headerlink" title="ByteBufferBitmapDecoder#decode"></a>ByteBufferBitmapDecoder#decode</h3><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link    java.nio.ByteBuffer ByteBuffers}.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ByteBufferBitmapDecoder</span> <span class="hljs-symbol">implements</span>     <span class="hljs-symbol">ResourceDecoder</span>&lt;<span class="hljs-symbol">ByteBuffer, <span class="hljs-symbol">Bitmap</span></span>&gt; {<br>  <br>  ...<br><br>  @Override<br>  <span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, <span class="hljs-built_in">int</span> width,   <span class="hljs-built_in">int</span> height,<br>      @NonNull Options options)<br>      throws IOException {<br>    InputStream <span class="hljs-keyword">is</span> = ByteBufferUtil.toStream(source);<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-keyword">return</span> downsampler.decode(<span class="hljs-keyword">is</span>, width, height, options);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。</p>
<h3 id="DownSampler-decode"><a href="#DownSampler-decode" class="headerlink" title="DownSampler#decode"></a>DownSampler#decode</h3><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; decode(InputStream is, <span class="hljs-keyword">int</span> outWidth, <span class="hljs-keyword">int</span> outHeight,<br>  <span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span>) <span class="hljs-keyword">throws</span> IOException {<br>    <span class="hljs-keyword">return</span> decode(is, outWidth, outHeight, <span class="hljs-keyword">options</span>, EMPTY_CALLBACKS);<br>}<br><br> @SuppressWarnings({<span class="hljs-string">"resource"</span>, <span class="hljs-string">"deprecation"</span>})<br><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; decode(InputStream is, <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight,<br>      <span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span>, DecodeCallbacks callbacks) <span class="hljs-keyword">throws</span> IOException {<br>    Preconditions.checkArgument(is.markSupported(), <span class="hljs-string">"You must provide an     InputStream that supports"</span><br>        + <span class="hljs-string">" mark()"</span>);<br><br>    ...<br><br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">// 核心代码</span><br>      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,<br>          downsampleStrategy, decodeFormat, isHardwareConfigAllowed,   requestedWidth,<br>          requestedHeight, fixBitmapToRequestedDimensions, callbacks);<br>      <span class="hljs-comment">// 关注点7   </span><br>      <span class="hljs-comment">// 解码得到Bitmap对象后，包装成BitmapResource对象返回，</span><br>      <span class="hljs-comment">// 通过内部的get方法得到Resource&lt;Bitmap&gt;对象</span><br>      <span class="hljs-keyword">return</span> BitmapResource.obtain(result, bitmapPool);<br>    } <span class="hljs-keyword">finally</span> {<br>      releaseOptions(bitmapFactoryOptions);<br>      byteArrayPool.put(bytesForOptions);<br>    }<br>}<br><br><span class="hljs-keyword">private</span> Bitmap decodeFromWrappedStreams(InputStream is,<br>      BitmapFactory.<span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span>, DownsampleStrategy downsampleStrategy,<br>      DecodeFormat decodeFormat, <span class="hljs-keyword">boolean</span> isHardwareConfigAllowed, <span class="hljs-keyword">int</span> requestedWidth,<br>      <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">boolean</span> fixBitmapToRequestedDimensions,<br>      DecodeCallbacks callbacks) <span class="hljs-keyword">throws</span> IOException {<br>    <br>    <span class="hljs-comment">// 省去计算压缩比例等一系列非核心逻辑</span><br>    ...<br>    <br>    <span class="hljs-comment">// 核心代码</span><br>    Bitmap downsampled = decodeStream(is, <span class="hljs-keyword">options</span>, callbacks, bitmapPool);<br>    callbacks.onDecodeComplete(bitmapPool, downsampled);<br><br>    ...<br><br>    <span class="hljs-comment">// Bimtap旋转处理</span><br>    ...<br>    <br>    <span class="hljs-keyword">return</span> rotated;<br>}<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap decodeStream(InputStream is,     BitmapFactory.<span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span>,<br>      DecodeCallbacks callbacks, BitmapPool bitmapPool) <span class="hljs-keyword">throws</span>   IOException {<br>    <br>    ...<br>    <br>    TransformationUtils.getBitmapDrawableLock().lock();<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-comment">// 核心代码</span><br>      result = BitmapFactory.decodeStream(is, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">options</span>);<br>    } <span class="hljs-keyword">catch</span> (IllegalArgumentException e) {<br>      ...<br>    } <span class="hljs-keyword">finally</span> {<br>      TransformationUtils.getBitmapDrawableLock().unlock();<br>    }<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">options</span>.inJustDecodeBounds) {<br>      is.reset();<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()<br>来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到步骤19的DownSampler#decode方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Resource对象，再回到步骤15的DecodeJob#run方法，这是使用了notifyEncodeAndRelease()<br>方法对Resource对象进行了发布。</p>
<h3 id="DecodeJob-notifyEncodeAndRelease"><a href="#DecodeJob-notifyEncodeAndRelease" class="headerlink" title="DecodeJob#notifyEncodeAndRelease"></a>DecodeJob#notifyEncodeAndRelease</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void notify<span class="hljs-constructor">EncodeAndRelease(Resource&lt;R&gt; <span class="hljs-params">resource</span>, DataSource     <span class="hljs-params">dataSource</span>)</span> {<span class="hljs-operator"></span><br><span class="hljs-operator"> </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>notify<span class="hljs-constructor">Complete(<span class="hljs-params">result</span>, <span class="hljs-params">dataSource</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator"></span>}<br><br><span class="hljs-keyword">private</span> void notify<span class="hljs-constructor">Complete(Resource&lt;R&gt; <span class="hljs-params">resource</span>, DataSource     <span class="hljs-params">dataSource</span>)</span> {<br>    set<span class="hljs-constructor">NotifiedOrThrow()</span>;<br>    callback.on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">resource</span>, <span class="hljs-params">dataSource</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从以上EngineJob的源码可知，它实现了DecodeJob.CallBack这个接口。</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineJob</span>&lt;<span class="hljs-title">R</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">DecodeJob</span></span>.<span class="hljs-title">Callback</span>&lt;<span class="hljs-title">R</span>&gt;,</span><br><span class="hljs-class">    <span class="hljs-title">Poolable</span> </span>{<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="EngineJob-onResourceReady"><a href="#EngineJob-onResourceReady" class="headerlink" title="EngineJob#onResourceReady"></a>EngineJob#onResourceReady</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onResourceReady</span>(<span class="hljs-params">Resource&lt;R&gt; resource, DataSource   dataSource</span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resource</span> = resource;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span> = dataSource;<br>  <span class="hljs-variable constant_">MAIN_THREAD_HANDLER</span>.<span class="hljs-title function_">obtainMessage</span>(<span class="hljs-variable constant_">MSG_COMPLETE</span>, <span class="hljs-variable language_">this</span>).<span class="hljs-title function_">sendToTarget</span>();<br>}<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThreadCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span>.<span class="hljs-property">Callback</span>{<br><br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">Message message</span>) {<br>      <span class="hljs-title class_">EngineJob</span>&lt;?&gt; job = (<span class="hljs-title class_">EngineJob</span>&lt;?&gt;) message.<span class="hljs-property">obj</span>;<br>      <span class="hljs-keyword">switch</span> (message.<span class="hljs-property">what</span>) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">MSG_COMPLETE</span>:<br>          <span class="hljs-comment">// 核心代码</span><br>          job.<span class="hljs-title function_">handleResultOnMainThread</span>();<br>          <span class="hljs-keyword">break</span>;<br>        ...<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从以上源码可知，通过主线程Handler对象进行切换线程，然后在主线程调用了handleResultOnMainThread这个方法。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Synthetic<br>void handle<span class="hljs-constructor">ResultOnMainThread()</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  </span><span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, size = cbs.size<span class="hljs-literal">()</span>; i &lt; size; i++) {<br>    ResourceCallback cb = cbs.get(i);<br>    <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">InIgnoredCallbacks(<span class="hljs-params">cb</span>)</span>) {<br>      engineResource.acquire<span class="hljs-literal">()</span>;<br>      cb.on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">engineResource</span>, <span class="hljs-params">dataSource</span>)</span>;<br>    }<br>  }<span class="hljs-operator"></span><br><span class="hljs-operator"> </span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里又通过一个循环调用了所有ResourceCallback的方法，让我们回到步骤9处Engine#load方法的关注点8这行代码，这里对ResourceCallback进行了注册，在步骤8出SingleRequest#onSizeReady方法里的engine.load中，我们看到最后一个参数，传入的是this，可以明白，engineJob.addCallback(<br>cb)这里的cb的实现类就是SingleRequest。接下来，让我们看看SingleRequest的onResourceReady方法。</p>
<h3 id="SingleRequest-onResourceReady"><a href="#SingleRequest-onResourceReady" class="headerlink" title="SingleRequest#onResourceReady"></a>SingleRequest#onResourceReady</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A callback method that should never be invoked directly.</span><br><span class="hljs-comment"> */</span><br>@<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br>@Override<br>public void on<span class="hljs-constructor">ResourceReady(Resource&lt;?&gt; <span class="hljs-params">resource</span>, DataSource   <span class="hljs-params">dataSource</span>)</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  </span><span class="hljs-comment">// 从Resource&lt;Bitmap&gt;中得到Bitmap对象</span><br>  Object received = resource.get<span class="hljs-literal">()</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><br><span class="hljs-operator">  </span>on<span class="hljs-constructor">ResourceReady((Resource&lt;R&gt;)</span> resource, (R) received, dataSource);<br>}<br><br><span class="hljs-keyword">private</span> void on<span class="hljs-constructor">ResourceReady(Resource&lt;R&gt; <span class="hljs-params">resource</span>, R <span class="hljs-params">resultDataSource</span> <span class="hljs-params">dataSource</span>)</span> {<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span><span class="hljs-keyword">try</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">      ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">      </span><span class="hljs-keyword">if</span> (!anyListenerHandledUpdatingTarget) {<br>        Transition&lt;? super R&gt; animation =<br>            animationFactory.build(dataSource, isFirstResource);<br>        <span class="hljs-comment">// 核心代码</span><br>        target.on<span class="hljs-constructor">ResourceReady(<span class="hljs-params">result</span>, <span class="hljs-params">animation</span>)</span>;<br>      }<br>    } finally {<br>      isCallingCallbacks = <span class="hljs-literal">false</span>;<br>    }<br><br>    notify<span class="hljs-constructor">LoadSuccess()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在SingleRequest#onResourceReady方法中又调用了target.onResourceReady(result, animation)<br>方法，这里的target其实就是我们在into方法中建立的那个BitmapImageViewTarget，看到BitmapImageViewTarget类，我们并没有发现onResourceReady方法，但是我们从它的子类ImageViewTarget中发现了onResourceReady方法，从这里继续往下看。</p>
<h3 id="ImageViewTarget-onResourceReady"><a href="#ImageViewTarget-onResourceReady" class="headerlink" title="ImageViewTarget#onResourceReady"></a>ImageViewTarget#onResourceReady</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageViewTarget&lt;Z&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewTarget&lt;ImageView</span>, <span class="hljs-title">Z&gt;</span></span><br>implements <span class="hljs-type">Transition</span>.<span class="hljs-type">ViewAdapter</span> {<br><br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    public void onResourceReady(<span class="hljs-meta">@NonNull</span> <span class="hljs-type">Z</span> resource, <span class="hljs-meta">@Nullable</span>       <span class="hljs-type">Transition</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">Z</span>&gt; transition) {<br>      <span class="hljs-keyword">if</span> (transition == <span class="hljs-literal">null</span> || !transition.transition(resource, <span class="hljs-keyword">this</span>))   {<br>        <span class="hljs-comment">// 核心代码</span><br>        setResourceInternal(resource);<br>      } <span class="hljs-keyword">else</span> {<br>        maybeUpdateAnimatable(resource);<br>      }<br>    }<br> <br>    ...<br>    <br>    <span class="hljs-keyword">private</span> void setResourceInternal(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Z</span> resource) {<br>        <span class="hljs-comment">// Order matters here. Set the resource first to make sure that the         Drawable has a valid and</span><br>        <span class="hljs-comment">// non-null Callback before starting it.</span><br>        <span class="hljs-comment">// 核心代码</span><br>        setResource(resource);<br>        maybeUpdateAnimatable(resource);<br>    }<br>    <br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> void setResource(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Z</span> resource);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里我们在回到BitmapImageViewTarget的setResource方法中，终于看到Bitmap被设置到了当前的imageView上了。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitmapImageViewTarget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImageViewTarget&lt;Bitmap&gt;</span> </span>{<br><br>    ...<br>    <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void setResource(<span class="hljs-type">Bitmap</span> resource) {<br>      view.setImageBitmap(resource);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>到这里，我们的分析就结束了，从以上的分析可知，Glide将大部分的逻辑处理都放在了最后一个into方法中，里面经过了20多个分析步骤才将请求图片流、解码出图片，到最终设置到对应的imageView上。</p>
<h2 id="完整Glide加载流程图"><a href="#完整Glide加载流程图" class="headerlink" title="完整Glide加载流程图"></a>完整Glide加载流程图</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9da2924eeab4ef79249b5836fd916da~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。</p>
</blockquote>
<h1 id="GreenDao"><a href="#GreenDao" class="headerlink" title="GreenDao"></a>GreenDao</h1><h2 id="基本使用流程-2"><a href="#基本使用流程-2" class="headerlink" title="基本使用流程"></a>基本使用流程</h2><h3 id="导入GreenDao的代码生成插件和库"><a href="#导入GreenDao的代码生成插件和库" class="headerlink" title="导入GreenDao的代码生成插件和库"></a>导入GreenDao的代码生成插件和库</h3><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 项目下的build.gradle</span><br><span class="hljs-keyword">buildscript</span> {<br>    ...<br>    <span class="hljs-keyword">dependencies</span> {<br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">'com.android.tools.build:gradle:2.3.0'</span><br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">'org.greenrobot:greendao-gradle-plugin:3.2.1'</span> <br>    }<br>}<br><br><span class="hljs-comment">// app模块下的build.gradle</span><br>apply plugin: <span class="hljs-string">'com.android.application'</span><br>apply plugin: <span class="hljs-string">'org.greenrobot.greendao'</span><br><br>...<br><br><span class="hljs-keyword">dependencies</span> {<br>    ...<br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">'org.greenrobot:greendao:3.2.0'</span> <br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="创建一个实体类，这里为HistoryData"><a href="#创建一个实体类，这里为HistoryData" class="headerlink" title="创建一个实体类，这里为HistoryData"></a>创建一个实体类，这里为HistoryData</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HistoryData</span> {<br><br>    <span class="hljs-meta">@Id(autoincrement = true)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br><br>    <span class="hljs-keyword">private</span> long date;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">data</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"><a href="#选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。" class="headerlink" title="选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"></a>选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ea30aea6034e939918d0da2b43c9d9~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HistoryData</span> {<br><br>    <span class="hljs-meta">@Id(autoincrement = true)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br><br>    <span class="hljs-keyword">private</span> long date;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">data</span>;<br><br>    <span class="hljs-meta">@Generated(hash = 1371145256)</span><br>    <span class="hljs-keyword">public</span> HistoryData(<span class="hljs-built_in">Long</span> id, long date, String <span class="hljs-keyword">data</span>) {<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.date = date;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>    }<br><br>    <span class="hljs-meta">@Generated(hash = 422767273)</span><br>    <span class="hljs-keyword">public</span> HistoryData() {<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Long</span> getId() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;<br>    }<br><br>    <span class="hljs-keyword">public</span> void setId(<span class="hljs-built_in">Long</span> id) {<br>        <span class="hljs-keyword">this</span>.id = id;<br>    }<br><br>    <span class="hljs-keyword">public</span> long getDate() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.date;<br>    }<br><br>    <span class="hljs-keyword">public</span> void setDate(long date) {<br>        <span class="hljs-keyword">this</span>.date = date;<br>    }<br><br>    <span class="hljs-keyword">public</span> String getData() {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>;<br>    }<br><br>    <span class="hljs-keyword">public</span> void setData(String <span class="hljs-keyword">data</span>) {<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里点明一下这几个类的作用：</p>
<ul>
<li>DaoMaster：所有Dao类的主人，负责整个库的运行，内部的静态抽象子类DevOpenHelper继承并重写了Android的SqliteOpenHelper。</li>
<li>DaoSession：作为一个会话层的角色，用于生成相应的Dao对象、Dao对象的注册，操作Dao的具体对象。</li>
<li>xxDao（HistoryDataDao）：生成的Dao对象，用于进行具体的数据库操作。</li>
</ul>
<h3 id="获取并使用相应的Dao对象进行增删改查操作"><a href="#获取并使用相应的Dao对象进行增删改查操作" class="headerlink" title="获取并使用相应的Dao对象进行增删改查操作"></a>获取并使用相应的Dao对象进行增删改查操作</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">DaoMaster.DevOpenHelper devOpenHelper = <span class="hljs-keyword">new</span> DaoMaster.<span class="hljs-constructor">DevOpenHelper(<span class="hljs-params">this</span>, Constants.DB_NAME)</span>;<br>SQLiteDatabase database = devOpenHelper.get<span class="hljs-constructor">WritableDatabase()</span>;<br>DaoMaster daoMaster = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DaoMaster(<span class="hljs-params">database</span>)</span>;<br>mDaoSession = daoMaster.<span class="hljs-keyword">new</span><span class="hljs-constructor">Session()</span>;<br>HistoryDataDao historyDataDao = daoSession.get<span class="hljs-constructor">HistoryDataDao()</span>;<br><br><span class="hljs-comment">// 省略创建historyData的代码</span><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span><span class="hljs-comment">// 增</span><br>historyDataDao.insert(historyData);<br><br><span class="hljs-comment">// 删</span><br>historyDataDao.delete(historyData);<br><br><span class="hljs-comment">// 改</span><br>historyDataDao.update(historyData);<br><br><span class="hljs-comment">// 查</span><br>List&lt;HistoryData&gt; historyDataList = historyDataDao.load<span class="hljs-constructor">All()</span>;<br></code></pre></td></tr></tbody></table></figure>

<p>本节将会以上述使用流程来对GreenDao的源码进行逐步分析，最后会分析下GreenDao中一些优秀的特性，让大家对GreenDao的理解有更一步的加深。</p>
<h2 id="GreenDao使用流程分析"><a href="#GreenDao使用流程分析" class="headerlink" title="GreenDao使用流程分析"></a>GreenDao使用流程分析</h2><h3 id="创建数据库帮助类对象DaoMaster-DevOpenHelper"><a href="#创建数据库帮助类对象DaoMaster-DevOpenHelper" class="headerlink" title="创建数据库帮助类对象DaoMaster.DevOpenHelper"></a>创建数据库帮助类对象DaoMaster.DevOpenHelper</h3><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">DaoMaster.DevOpenHelper devOpenHelper = <span class="hljs-keyword">new</span> <span class="hljs-type">DaoMaster</span>.DevOpenHelper(<span class="hljs-built_in">this</span>, Constants.DB_NAME);<br></code></pre></td></tr></tbody></table></figure>

<p>创建GreenDao内部实现的数据库帮助类对象devOpenHelper，核心源码如下：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDaoMaster</span> </span>{<br><br>    ...<br><br>    public static <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DatabaseOpenHelper</span> </span>{<br>    <br>    ...<br>    <br>         <span class="hljs-meta">@Override</span><br>        public void onCreate(<span class="hljs-type">Database</span> db) {<br>            <span class="hljs-type">Log</span>.i(<span class="hljs-string">"greenDAO"</span>, <span class="hljs-string">"Creating tables for schema version "</span> + <span class="hljs-type">SCHEMA_VERSION</span>);<br>            createAllTables(db, <span class="hljs-literal">false</span>);<br>        }<br>    }<br>    <br>    public static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevOpenHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OpenHelper</span> </span>{<br>    <br>        ...<br>        <br>        <span class="hljs-meta">@Override</span><br>        public void onUpgrade(<span class="hljs-type">Database</span> db, int oldVersion, int newVersion) {<br>            <span class="hljs-type">Log</span>.i(<span class="hljs-string">"greenDAO"</span>, <span class="hljs-string">"Upgrading schema from version "</span> + oldVersion + <span class="hljs-string">" to "</span> + newVersion + <span class="hljs-string">" by dropping all tables"</span>);<br>            dropAllTables(db, <span class="hljs-literal">true</span>);<br>            onCreate(db);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>DevOpenHelper自身实现了更新的逻辑，这里是弃置了所有的表，并且调用了OpenHelper实现的onCreate方法用于创建所有的表，其中DevOpenHelper继承于OpenHelper，而OpenHelper自身又继承于DatabaseOpenHelper，那么，这个DatabaseOpenHelper这个类的作用是什么呢？</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseOpenHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>{<br><br>    ...<br>    <br>    <span class="hljs-comment">// 关注点1</span><br>    public <span class="hljs-type">Database</span> getWritableDb() {<br>        <span class="hljs-keyword">return</span> wrap(getWritableDatabase());<br>    }<br>    <br>    public <span class="hljs-type">Database</span> getReadableDb() {<br>        <span class="hljs-keyword">return</span> wrap(getReadableDatabase());<br>    }   <br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Database</span> wrap(<span class="hljs-type">SQLiteDatabase</span> sqLiteDatabase) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">StandardDatabase</span>(sqLiteDatabase);<br>    }<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 关注点2</span><br>    public <span class="hljs-type">Database</span> getEncryptedWritableDb(<span class="hljs-type">String</span> password) {<br>        <span class="hljs-type">EncryptedHelper</span> encryptedHelper = checkEncryptedHelper();<br>        <span class="hljs-keyword">return</span> encryptedHelper.wrap(encryptedHelper.getWritableDatabase(password));<br>    }<br>    <br>    public <span class="hljs-type">Database</span> getEncryptedReadableDb(<span class="hljs-type">String</span> password) {<br>        <span class="hljs-type">EncryptedHelper</span> encryptedHelper = checkEncryptedHelper();<br>        <span class="hljs-keyword">return</span> encryptedHelper.wrap(encryptedHelper.getReadableDatabase(password));<br>    }<br>    <br>    ...<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptedHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">net</span>.<span class="hljs-title">sqlcipher</span>.<span class="hljs-title">database</span>.<span class="hljs-title">SQLiteOpenHelper</span> </span>{<br>    <br>        ...<br>    <br>    <br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">Database</span> wrap(net.sqlcipher.database.<span class="hljs-type">SQLiteDatabase</span>     sqLiteDatabase) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">EncryptedDatabase</span>(sqLiteDatabase);<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>其实，DatabaseOpenHelper也是实现了SQLiteOpenHelper的一个帮助类，它内部可以获取到两种不同的数据库类型，一种是标准型的数据库*<br><em>StandardDatabase<strong>，另一种是加密型的数据库</strong>EncryptedDatabase*</em><br>，从以上源码可知，它们内部都通过wrap这样一个包装的方法，返回了对应的数据库类型，我们大致看一下StandardDatabase和EncryptedDatabase的内部实现。</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardDatabase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Database</span> </span>{<br><br>    <span class="hljs-comment">// 这里的SQLiteDatabase是android.database.sqlite.SQLiteDatabase包下的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SQLiteDatabase delegate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StandardDatabase</span><span class="hljs-params">(SQLiteDatabase delegate)</span> </span>{<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Cursor <span class="hljs-title">rawQuery</span><span class="hljs-params">(String sql, String[] selectionArgs)</span> </span>{<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> delegate.<span class="hljs-title">rawQuery</span><span class="hljs-params">(sql, selectionArgs)</span></span>;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execSQL</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>{<br>        delegate.execSQL(sql);<br>    }<br><br>    ...<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptedDatabaseStatement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DatabaseStatement</span>     </span>{<br><br>    <span class="hljs-comment">// 这里的SQLiteStatement是net.sqlcipher.database.SQLiteStatement包下的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SQLiteStatement delegate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EncryptedDatabaseStatement</span><span class="hljs-params">(SQLiteStatement delegate)</span> </span>{<br>        <span class="hljs-keyword">this</span>.delegate = delegate;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{<br>        delegate.execute();<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>StandardDatabase和EncryptedDatabase这两个类内部都使用了<strong>代理模式</strong><br>给相同的接口添加了不同的具体实现，StandardDatabase自然是使用的Android包下的SQLiteDatabase，而EncryptedDatabaseStatement为了实现加密数据库的功能，则使用了一个叫做<br><strong>sqlcipher</strong>的数据库加密三方库，*<br>*<br>如果你项目下的数据库需要保存比较重要的数据，则可以使用getEncryptedWritableDb方法来代替getdWritableDb方法对数据库进行加密，这样，我们之后的数据库操作则会以代理模式的形式间接地使用sqlcipher提供的API去操作数据库<br>**。</p>
<h3 id="创建DaoMaster对象"><a href="#创建DaoMaster对象" class="headerlink" title="创建DaoMaster对象"></a>创建DaoMaster对象</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SQLiteDatabase database <span class="hljs-operator">=</span> devOpenHelper.getWritableDatabase()<span class="hljs-comment">;</span><br>DaoMaster daoMaster <span class="hljs-operator">=</span> new DaoMaster(database)<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure>

<p>首先，DaoMaster作为所有Dao对象的主人，它内部肯定是需要一个SQLiteDatabase对象的，因此，先由DaoMaster的帮助类对象devOpenHelper的getWritableDatabase方法得到一个标准的数据库类对象database，再由此创建一个DaoMaster对象。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDaoMaster</span> </span>{<br><br>    ...<br><br>    public <span class="hljs-type">DaoMaster</span>(<span class="hljs-type">SQLiteDatabase</span> db) {<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StandardDatabase</span>(db));<br>    }<br><br>    public <span class="hljs-type">DaoMaster</span>(<span class="hljs-type">Database</span> db) {<br>        <span class="hljs-keyword">super</span>(db, <span class="hljs-type">SCHEMA_VERSION</span>);<br>        registerDaoClass(<span class="hljs-type">HistoryDataDao</span>.<span class="hljs-keyword">class</span>);<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在DaoMaster的构造方法中，它首先执行了super(db, SCHEMA_VERSION)方法，即它的父类AbstractDaoMaster的构造方法。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDaoMaster</span> {<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractDaoMaster</span>(<span class="hljs-params">Database db, <span class="hljs-built_in">int</span> schemaVersion</span>)</span> {<br>        <span class="hljs-keyword">this</span>.db = db;<br>        <span class="hljs-keyword">this</span>.schemaVersion = schemaVersion;<br><br>        daoConfigMap = <span class="hljs-keyword">new</span> HashMap&lt;Class&lt;? <span class="hljs-function">extends <span class="hljs-title">AbstractDao</span>&lt;?, ?&gt;&gt;, DaoConfig&gt;()</span>;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDaoClass</span>(<span class="hljs-params">Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt; daoClass</span>)</span> {<br>        DaoConfig daoConfig = <span class="hljs-keyword">new</span> DaoConfig(db, daoClass);<br>        daoConfigMap.put(daoClass, daoConfig);<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在AbstractDaoMaster对象的构造方法中，除了记录当前的数据库对象db和版本schemaVersion之外，还创建了一个类型为*<br>*HashMap<code>&lt;Class&gt;</code>, DaoConfig&gt;()的daoConfigMap对象用于保存每一个DAO对应的数据配置对象DaoConfig，并且Daoconfig对象存储了对应的Dao对象所必需的数据<br>**。最后，在DaoMaster的构造方法中使用了registerDaoClass(HistoryDataDao.class)<br>方法将HistoryDataDao类对象进行了注册，实际上，就是为HistoryDataDao这个Dao对象创建了相应的DaoConfig对象并将它放入daoConfigMap对象中保存起来。</p>
<h3 id="创建DaoSession对象"><a href="#创建DaoSession对象" class="headerlink" title="创建DaoSession对象"></a>创建DaoSession对象</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">mDaoSession</span> <span class="hljs-operator">=</span> daoMaster.newSession()<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure>

<p>在DaoMaster对象中使用了newSession方法新建了一个DaoSession对象。</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> DaoSession <span class="hljs-keyword">new</span><span class="hljs-type">Session</span>() {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">DaoSession</span>(db, IdentityScopeType.Session, daoConfigMap);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在DaoSeesion的构造方法中，又做了哪些事情呢？</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoSession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDaoSession</span> </span>{<br><br>    ...<br><br>    public <span class="hljs-type">DaoSession</span>(<span class="hljs-type">Database</span> db, <span class="hljs-type">IdentityScopeType</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Map&lt;Class&lt;?</span>     <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDao&lt;?</span>, <span class="hljs-title">?&gt;&gt;</span>, <span class="hljs-title">DaoConfig&gt;</span></span><br>            daoConfigMap) {<br>        <span class="hljs-keyword">super</span>(db);<br><br>        historyDataDaoConfig = daoConfigMap.get(<span class="hljs-type">HistoryDataDao</span>.<span class="hljs-keyword">class</span>).clone();<br>        historyDataDaoConfig.initIdentityScope(<span class="hljs-class"><span class="hljs-keyword">type</span>)</span>;<br><br>        historyDataDao = <span class="hljs-keyword">new</span> <span class="hljs-type">HistoryDataDao</span>(historyDataDaoConfig, <span class="hljs-keyword">this</span>);<br><br>        registerDao(<span class="hljs-type">HistoryData</span>.<span class="hljs-keyword">class</span>, historyDataDao);<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，调用了父类AbstractDaoSession的构造方法。</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDaoSession</span> {<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractDaoSession</span><span class="hljs-params">(Database db)</span> </span>{<br>        <span class="hljs-keyword">this</span>.db = db;<br>        <span class="hljs-keyword">this</span>.entityToDao = <span class="hljs-keyword">new</span> HashMap&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt;();<br>    }<br>    <br>    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerDao</span><span class="hljs-params">(Class&lt;T&gt; entityClass, AbstractDao&lt;T, ?&gt; dao)</span> </span>{<br>        entityToDao.<span class="hljs-built_in">put</span>(entityClass, dao);<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在AbstractDaoSession构造方法里面<strong>创建了一个实体与Dao对象的映射集合</strong>。接下来，在DaoSession的构造方法中还做了2件事：</p>
<ol>
<li><p><strong>创建每一个Dao对应的DaoConfig对象</strong>，这里是historyDataDaoConfig，<strong>并且根据IdentityScopeType的类型初始化创建一个相应的IdentityScope<br><strong>，根据type的不同，它有两种类型，分别是</strong>IdentityScopeObject</strong>和<strong>IdentityScopeLong</strong><br>，它的作用是根据主键缓存对应的实体数据。当主键是数字类型的时候，如long/Long、int/Integer、short/Short、byte/Byte，则使用IdentityScopeLong缓存实体数据，当主键不是数字类型的时候，则使用IdentityScopeObject缓存实体数据。</p>
</li>
<li><p><strong>根据DaoSession对象和每一个Dao对应的DaoConfig对象，创建与之对应的historyDataDao对象</strong><br>，由于这个项目只创建了一个实体类HistoryData，因此这里只有一个Dao对象historyDataDao，然后就是注册Dao对象，其实就是将实体和对应的Dao对象放入entityToDao这个映射集合中保存起来了。</p>
</li>
</ol>
<h3 id="插入源码分析"><a href="#插入源码分析" class="headerlink" title="插入源码分析"></a>插入源码分析</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HistoryDataDao historyDataDao <span class="hljs-operator">=</span> daoSession.getHistoryDataDao()<span class="hljs-comment">;</span><br><br>// 增<br>historyDataDao.insert(historyData)<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure>

<p>这里首先在会话层DaoSession中获取了我们要操作的Dao对象HistoryDataDao，然后插入了一个我们预先创建好的historyData实体对象。其中HistoryDataDao继承了AbstractDao&lt;<br>HistoryData, Long&gt; 。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoryDataDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDao&lt;HistoryData</span>, <span class="hljs-title">Long&gt;</span> </span>{<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>那么，这个AbstractDao是干什么的呢？</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> AbstractDao&lt;T, K&gt; {<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span>public List&lt;T&gt; load<span class="hljs-constructor">All()</span> {<br>        Cursor cursor = db.raw<span class="hljs-constructor">Query(<span class="hljs-params">statements</span>.<span class="hljs-params">getSelectAll</span>()</span>, null);<br>        return load<span class="hljs-constructor">AllAndCloseCursor(<span class="hljs-params">cursor</span>)</span>;<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span>public long insert(T entity) {<br>        return execute<span class="hljs-constructor">Insert(<span class="hljs-params">entity</span>, <span class="hljs-params">statements</span>.<span class="hljs-params">getInsertStatement</span>()</span>,     <span class="hljs-literal">true</span>);<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span>public void delete(T entity) {<br>        <span class="hljs-keyword">assert</span><span class="hljs-constructor">SinglePk()</span>;<br>        K key = get<span class="hljs-constructor">KeyVerified(<span class="hljs-params">entity</span>)</span>;<br>        delete<span class="hljs-constructor">ByKey(<span class="hljs-params">key</span>)</span>;<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>看到这里，根据程序员优秀的直觉，大家应该能猜到，AbstractDao是所有Dao对象的基类，它实现了实体数据的操作如增删改查。我们接着分析insert是如何实现的，在AbstractDao的insert方法中又调用了executeInsert这个方法。在这个方法中，第二个参里的statements是一个<br><strong>TableStatements</strong>对象，它是在AbstractDao初始化构造器时从DaoConfig对象中取出来的，是一个**根据指定的表格创建SQL语句的一个帮助类<br>**。使用statements.getInsertStatement()则是获取了一个插入的语句。而第三个参数则是判断是否是主键的标志。</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableStatements</span> </span>{<br><br>    ...<br><br>    <span class="hljs-keyword">public</span> DatabaseStatement getInsertStatement() {<br>        <span class="hljs-keyword">if</span> (insertStatement == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">String</span> sql = SqlUtils.createSqlInsert(<span class="hljs-string">"INSERT INTO "</span>, tablename, allColumns);<br>            DatabaseStatement <span class="hljs-keyword">new</span><span class="hljs-type">InsertStatement</span> = db.compileStatement(sql);<br>            ...<br>        }<br>        <span class="hljs-keyword">return</span> insertStatement;<br>    }<br><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在TableStatements的getInsertStatement方法中，主要做了两件事：</p>
<ol>
<li><p><strong>使用SqlUtils创建了插入的sql语句</strong>。</p>
</li>
<li><p><strong>根据不同的数据库类型（标准数据库或加密数据库）将sql语句编译成当前数据库对应的语句</strong>。</p>
</li>
</ol>
<p>我们继续往下分析executeInsert的执行流程。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> long execute<span class="hljs-constructor">Insert(T <span class="hljs-params">entity</span>, DatabaseStatement <span class="hljs-params">stmt</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">setKeyAndAttach</span>)</span> {<br>    long rowId;<br>    <span class="hljs-keyword">if</span> (db.is<span class="hljs-constructor">DbLockedByCurrentThread()</span>) {<br>        rowId = insert<span class="hljs-constructor">InsideTx(<span class="hljs-params">entity</span>, <span class="hljs-params">stmt</span>)</span>;<br>    } <span class="hljs-keyword">else</span> {<br>        db.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Transaction()</span>;<br>        <span class="hljs-keyword">try</span> {<br>            rowId = insert<span class="hljs-constructor">InsideTx(<span class="hljs-params">entity</span>, <span class="hljs-params">stmt</span>)</span>;<br>            db.set<span class="hljs-constructor">TransactionSuccessful()</span>;<br>        } finally {<br>            db.<span class="hljs-keyword">end</span><span class="hljs-constructor">Transaction()</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (setKeyAndAttach) {<br>        update<span class="hljs-constructor">KeyAfterInsertAndAttach(<span class="hljs-params">entity</span>, <span class="hljs-params">rowId</span>, <span class="hljs-params">true</span>)</span>;<br>    }<br>    return rowId;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里首先是判断数据库是否被当前线程锁定，如果是，则直接插入数据，否则为了避免死锁，则开启一个数据库事务，再进行插入数据的操作。最后如果设置了主键，则在插入数据之后更新主键的值并将对应的实体缓存到相应的identityScope中，这一块的代码流程如下所示：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected void update<span class="hljs-constructor">KeyAfterInsertAndAttach(T <span class="hljs-params">entity</span>, <span class="hljs-params">long</span> <span class="hljs-params">rowId</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> {<br>    <span class="hljs-keyword">if</span> (rowId != -<span class="hljs-number">1</span>) {<br>        K key = update<span class="hljs-constructor">KeyAfterInsert(<span class="hljs-params">entity</span>, <span class="hljs-params">rowId</span>)</span>;<br>        attach<span class="hljs-constructor">Entity(<span class="hljs-params">key</span>, <span class="hljs-params">entity</span>, <span class="hljs-params">lock</span>)</span>;<br>    } <span class="hljs-keyword">else</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">       ...</span><br><span class="hljs-operator">    </span>}<br>}<br><br>protected final void attach<span class="hljs-constructor">Entity(K <span class="hljs-params">key</span>, T <span class="hljs-params">entity</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> {<br>    attach<span class="hljs-constructor">Entity(<span class="hljs-params">entity</span>)</span>;<br>    <span class="hljs-keyword">if</span> (identityScope != null<span class="hljs-operator"> &amp;&amp; </span>key != null) {<br>        <span class="hljs-keyword">if</span> (lock) {<br>            identityScope.put(key, entity);<br>        } <span class="hljs-keyword">else</span> {<br>            identityScope.put<span class="hljs-constructor">NoLock(<span class="hljs-params">key</span>, <span class="hljs-params">entity</span>)</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接着，我们还是继续追踪主线流程，在executeInsert这个方法中调用了insertInsideTx进行数据的插入。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> long insert<span class="hljs-constructor">InsideTx(T <span class="hljs-params">entity</span>, DatabaseStatement <span class="hljs-params">stmt</span>)</span> {<br>    synchronized (stmt) {<br>        <span class="hljs-keyword">if</span> (isStandardSQLite) {<br>            SQLiteStatement rawStmt = (SQLiteStatement) stmt.get<span class="hljs-constructor">RawStatement()</span>;<br>            bind<span class="hljs-constructor">Values(<span class="hljs-params">rawStmt</span>, <span class="hljs-params">entity</span>)</span>;<br>            return rawStmt.execute<span class="hljs-constructor">Insert()</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            bind<span class="hljs-constructor">Values(<span class="hljs-params">stmt</span>, <span class="hljs-params">entity</span>)</span>;<br>            return stmt.execute<span class="hljs-constructor">Insert()</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>为了防止并发，这里使用了悲观锁保证了数据的一致性，在AbstractDao这个类中，大量使用了这种锁保证了它的线程安全性。接着，如果当前是标准数据库，则直接获取stmt这个DatabaseStatement类对应的原始语句进行实体字段属性的绑定和最后的执行插入操作。如果是加密数据库，则直接使用当前的加密数据库所属的插入语句进行实体字段属性的绑定和执行最后的插入操作。其中bindValues这个方法对应的实现类就是我们的HistoryDataDao类。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>@Override<br>    protected final void bind<span class="hljs-constructor">Values(DatabaseStatement <span class="hljs-params">stmt</span>, HistoryData     <span class="hljs-params">entity</span>)</span> {<br>        stmt.clear<span class="hljs-constructor">Bindings()</span>;<br><br>        Long id = entity.get<span class="hljs-constructor">Id()</span>;<br>        <span class="hljs-keyword">if</span> (id != null) {<br>            stmt.bind<span class="hljs-constructor">Long(1, <span class="hljs-params">id</span>)</span>;<br>        }<br>        stmt.bind<span class="hljs-constructor">Long(2, <span class="hljs-params">entity</span>.<span class="hljs-params">getDate</span>()</span>);<br><br>        String data = entity.get<span class="hljs-constructor">Data()</span>;<br>        <span class="hljs-keyword">if</span> (data != null) {<br>            stmt.bind<span class="hljs-constructor">String(3, <span class="hljs-params">data</span>)</span>;<br>        }<br>    }<br>    <br>    @Override<br>    protected final void bind<span class="hljs-constructor">Values(SQLiteStatement <span class="hljs-params">stmt</span>, HistoryData     <span class="hljs-params">entity</span>)</span> {<br>        stmt.clear<span class="hljs-constructor">Bindings()</span>;<br><br>        Long id = entity.get<span class="hljs-constructor">Id()</span>;<br>        <span class="hljs-keyword">if</span> (id != null) {<br>            stmt.bind<span class="hljs-constructor">Long(1, <span class="hljs-params">id</span>)</span>;<br>        }<br>        stmt.bind<span class="hljs-constructor">Long(2, <span class="hljs-params">entity</span>.<span class="hljs-params">getDate</span>()</span>);<br><br>        String data = entity.get<span class="hljs-constructor">Data()</span>;<br>        <span class="hljs-keyword">if</span> (data != null) {<br>            stmt.bind<span class="hljs-constructor">String(3, <span class="hljs-params">data</span>)</span>;<br>        }<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里对HistoryData的所有字段使用对应的数据库语句进行了绑定操作。这里最后再提及一下，*<br>*如果当前数据库是加密型时，则会使用最开始提及的DatabaseStatement的加密实现类EncryptedDatabaseStatement应用代理模式去使用sqlcipher这个加密型数据库的insert方法<br>**。</p>
<h3 id="查询源码分析"><a href="#查询源码分析" class="headerlink" title="查询源码分析"></a>查询源码分析</h3><p>经过对插入源码的分析，相信大家对GreenDao内部的机制已经有了一些自己的理解，由于删除和更新内部的流程比较简单，且与插入源码有异曲同工之妙，这里就不再赘述了。最后再分析下查询的源码，查询的流程调用链较长，所以将它的核心流程源码直接给出。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;HistoryData&gt; historyDataList = historyDataDao.load<span class="hljs-constructor">All()</span>;<br><br>public List&lt;T&gt; load<span class="hljs-constructor">All()</span> {<br>    Cursor cursor = db.raw<span class="hljs-constructor">Query(<span class="hljs-params">statements</span>.<span class="hljs-params">getSelectAll</span>()</span>, null);<br>    return load<span class="hljs-constructor">AllAndCloseCursor(<span class="hljs-params">cursor</span>)</span>;<br>}<br><br>protected List&lt;T&gt; load<span class="hljs-constructor">AllAndCloseCursor(Cursor <span class="hljs-params">cursor</span>)</span> {<br>    <span class="hljs-keyword">try</span> {<br>        return load<span class="hljs-constructor">AllFromCursor(<span class="hljs-params">cursor</span>)</span>;<br>    } finally {<br>        cursor.close<span class="hljs-literal">()</span>;<br>    }<br>}<br><br>protected List&lt;T&gt; load<span class="hljs-constructor">AllFromCursor(Cursor <span class="hljs-params">cursor</span>)</span> {<br>    <span class="hljs-built_in">int</span> count = cursor.get<span class="hljs-constructor">Count()</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>boolean useFastCursor = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (cursor instanceof CrossProcessCursor) {<br>        window = ((CrossProcessCursor) cursor).get<span class="hljs-constructor">Window()</span>;<br>        <span class="hljs-keyword">if</span> (window != null) {  <br>            <span class="hljs-keyword">if</span> (window.get<span class="hljs-constructor">NumRows()</span><span class="hljs-operator"> == </span>count) {<br>                cursor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FastCursor(<span class="hljs-params">window</span>)</span>;<br>                useFastCursor = <span class="hljs-literal">true</span>;<br>            } <span class="hljs-keyword">else</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">              ...</span><br><span class="hljs-operator">            </span>}<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (cursor.move<span class="hljs-constructor">ToFirst()</span>) {<span class="hljs-operator"></span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span><span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">if</span> (!useFastCursor<span class="hljs-operator"> &amp;&amp; </span>window != null<span class="hljs-operator"> &amp;&amp; </span>identityScope != null) {<br>                load<span class="hljs-constructor">AllUnlockOnWindowBounds(<span class="hljs-params">cursor</span>, <span class="hljs-params">window</span>, <span class="hljs-params">list</span>)</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">do</span> {<br>                    <span class="hljs-built_in">list</span>.add(load<span class="hljs-constructor">Current(<span class="hljs-params">cursor</span>, 0, <span class="hljs-params">false</span>)</span>);<br>                } <span class="hljs-keyword">while</span> (cursor.move<span class="hljs-constructor">ToNext()</span>);<br>            }<br>        } finally {<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">        </span>}<br>    }<br>    return <span class="hljs-built_in">list</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最终，loadAll方法将会调用到loadAllFromCursor这个方法，首先，如果<strong>当前的游标cursor是跨进程的cursor</strong><br>，并且cursor的行数没有偏差的话，则使用一个加快版的<strong>FastCursor</strong><br>对象进行游标遍历。接着，不管是执行loadAllUnlockOnWindowBounds这个方法还是直接加载当前的数据列表list.add(loadCurrent(<br>cursor, 0, false))，最后都会调用到这行list.add(loadCurrent(cursor, 0, false))代码，很明显，loadCurrent方法就是加载数据的方法。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">final protected T load<span class="hljs-constructor">Current(Cursor <span class="hljs-params">cursor</span>, <span class="hljs-params">int</span> <span class="hljs-params">offset</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> {<br>    <span class="hljs-keyword">if</span> (identityScopeLong != null) {<span class="hljs-operator"></span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span>T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2<span class="hljs-constructor">NoLock(<span class="hljs-params">key</span>)</span>;<br>        <span class="hljs-keyword">if</span> (entity != null) {<br>            return entity;<br>        } <span class="hljs-keyword">else</span> {<br>            entity = read<span class="hljs-constructor">Entity(<span class="hljs-params">cursor</span>, <span class="hljs-params">offset</span>)</span>;<br>            attach<span class="hljs-constructor">Entity(<span class="hljs-params">entity</span>)</span>;<br>            <span class="hljs-keyword">if</span> (lock) {<br>                identityScopeLong.put2(key, entity);<br>            } <span class="hljs-keyword">else</span> {<br>                identityScopeLong.put2<span class="hljs-constructor">NoLock(<span class="hljs-params">key</span>, <span class="hljs-params">entity</span>)</span>;<br>            }<br>            return entity;<br>        }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (identityScope != null) {<span class="hljs-operator"></span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span>T entity = lock ? identityScope.get(key) : identityScope.get<span class="hljs-constructor">NoLock(<span class="hljs-params">key</span>)</span>;<br>        <span class="hljs-keyword">if</span> (entity != null) {<br>            return entity;<br>        } <span class="hljs-keyword">else</span> {<br>            entity = read<span class="hljs-constructor">Entity(<span class="hljs-params">cursor</span>, <span class="hljs-params">offset</span>)</span>;<br>            attach<span class="hljs-constructor">Entity(<span class="hljs-params">key</span>, <span class="hljs-params">entity</span>, <span class="hljs-params">lock</span>)</span>;<br>            return entity;<br>        }<br>    } <span class="hljs-keyword">else</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span>T entity = read<span class="hljs-constructor">Entity(<span class="hljs-params">cursor</span>, <span class="hljs-params">offset</span>)</span>;<br>        attach<span class="hljs-constructor">Entity(<span class="hljs-params">entity</span>)</span>;<br>        return entity;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="loadCurrent方法内部的执行策略"><a href="#loadCurrent方法内部的执行策略" class="headerlink" title="loadCurrent方法内部的执行策略"></a>loadCurrent方法内部的执行策略</h4><ul>
<li></li>
<li><p>首先，如果有实体数据缓存identityScopeLong/identityScope，则先从缓存中取，如果缓存中没有，会使用该实体对应的Dao对象，这里的是HistoryDataDao，它在内部根据游标取出的数据新建了一个新的HistoryData实体对象返回。<br>**</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> HistoryData readEntity(<span class="hljs-keyword">Cursor</span> <span class="hljs-keyword">cursor</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span>) {<br>    HistoryData entity = <span class="hljs-built_in">new</span> HistoryData( //<br>        <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">isNull</span>(<span class="hljs-keyword">offset</span> + <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">cursor</span>.getLong(<span class="hljs-keyword">offset</span> + <span class="hljs-number">0</span>), // id<br>        <span class="hljs-keyword">cursor</span>.getLong(<span class="hljs-keyword">offset</span> + <span class="hljs-number">1</span>), // <span class="hljs-type">date</span><br>        <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">isNull</span>(<span class="hljs-keyword">offset</span> + <span class="hljs-number">2</span>) ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">cursor</span>.getString(<span class="hljs-keyword">offset</span> + <span class="hljs-number">2</span>) // data<br>    );<br>    <span class="hljs-keyword">return</span> entity;<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li></li>
</ul>
<p>*最后，如果是非identityScopeLong缓存类型，即是属于identityScope的情况下，则还会在identityScope中将上面获得的数据进行缓存。如果没有实体数据缓存的话，则直接调用readEntity组装数据返回即可。<br>**</p>
<p>注意：对于GreenDao缓存的特性，可能会出现没有拿到最新数据的bug，因此，如果遇到这种情况，可以使用DaoSession的clear方法删除缓存。</p>
<h2 id="GreenDao是如何与ReactiveX结合？"><a href="#GreenDao是如何与ReactiveX结合？" class="headerlink" title="GreenDao是如何与ReactiveX结合？"></a>GreenDao是如何与ReactiveX结合？</h2><p>首先，看下与rx结合的使用流程：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">RxDao</span>&lt;<span class="hljs-title class_">HistoryData</span>, <span class="hljs-title class_">Long</span>&gt; xxDao = daoSession.<span class="hljs-title function_">getHistoryDataDao</span>().<span class="hljs-title function_">rx</span>();<br>xxDao.<span class="hljs-title function_">insert</span>(historyData)<br>        .<span class="hljs-title function_">observerOn</span>(<span class="hljs-title class_">AndroidSchedulers</span>.<span class="hljs-title function_">mainThread</span>())<br>        .<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Action1</span>&lt;<span class="hljs-title class_">HistoryData</span>&gt;() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">HistoryData entity</span>) {<br>                <span class="hljs-comment">// insert success</span><br>            }<br>        });<br></code></pre></td></tr></tbody></table></figure>

<p>在AbstractDao对象的.rx()方法中，创建了一个默认执行在io线程的rxDao对象。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Experimental</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">RxDao</span>&lt;T, K&gt; <span class="hljs-title function_">rx</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">if</span> (rxDao == <span class="hljs-literal">null</span>) {<br>        rxDao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RxDao</span>&lt;&gt;(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Schedulers</span>.<span class="hljs-title function_">io</span>());<br>    }<br>    <span class="hljs-keyword">return</span> rxDao;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接着分析rxDao的insert方法。</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Experimental</span><br><span class="hljs-keyword">public</span> Observable&lt;T&gt; insert(<span class="hljs-keyword">final</span> T entity) {<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Callable&lt;T&gt;()</span> </span>{<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function">T <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>            dao.insert(entity);<br>            <span class="hljs-keyword">return</span> entity;<br>        }<br>    });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>起实质作用的就是这个wrap方法了，在这个方法里面主要是调用了RxUtils.fromCallable(callable)这个方法。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Internal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RxBase</span> {<br><br>    ...<br><br>    <span class="hljs-keyword">protected</span> &lt;R&gt; Observable&lt;R&gt; wrap(Callable&lt;R&gt; callable) {<br>        <span class="hljs-keyword">return</span> wrap(RxUtils.fromCallable(callable));<br>    }<br><br>    <span class="hljs-keyword">protected</span> &lt;R&gt; Observable&lt;R&gt; wrap(Observable&lt;R&gt; observable) {<br>        <span class="hljs-keyword">if</span> (scheduler != <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span> observable.subscribeOn(scheduler);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span> observable;<br>        }<br>    }<br><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在RxUtils的fromCallable这个方法内部，其实就是**使用defer这个延迟操作符来进行被观察者事件的发送，主要目的就是为了确保Observable被订阅后才执行<br>**。最后，如果调度器scheduler存在的话，将通过外部的wrap方法将执行环境调度到io线程。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@Internal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RxUtils</span> {<br><br>    <span class="hljs-meta">@Internal</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt; fromCallable(<span class="hljs-keyword">final</span> <span class="hljs-type">Callable</span>&lt;<span class="hljs-type">T</span>&gt; callable) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.defer(new <span class="hljs-type">Func0</span>&lt;<span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt;&gt;() {<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt; call() {<br>                <span class="hljs-type">T</span> result;<br>                <span class="hljs-keyword">try</span> {<br>                    result <span class="hljs-operator">=</span> callable.call();<br>                } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) {<br>                    <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.error(e);<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.just(result);<br>            }<br>        });<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在分析完GreenDao的核心源码之后发现，GreenDao作为最好的数据库框架之一，是有一定道理的。</p>
<p><strong>首先，它通过使用自身的插件配套相应的freemarker模板生成所需的静态代码，避免了反射等消耗性能的操作。</strong></p>
<p>**其次，它内部提供了实体数据的映射缓存机制，能够进一步加快查询速度。对于不同数据库对应的SQL语句，也使用了不同的DataBaseStatement实现类结合代理模式进行了封装，屏蔽了数据库操作等繁琐的细节。<br>**</p>
<p>**最后，它使用了sqlcipher提供了加密数据库的功能，在一定程度确保了安全性，同时，结合RxJava，我们便能更简洁地实现异步的数据库操作<br>**。</p>
</blockquote>
<h1 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h1><h2 id="RxJava到底是什么？"><a href="#RxJava到底是什么？" class="headerlink" title="RxJava到底是什么？"></a>RxJava到底是什么？</h2><p>RxJava是基于Java虚拟机上的响应式扩展库，它通过<strong>使用可观察的序列将异步和基于事件的程序组合起来</strong>。 与此同时，它*<br><em>扩展了观察者模式来支持数据/事件序列<strong>，并且添加了操作符，这些</strong>操作符允许你声明性地组合序列*</em><br>，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。</p>
<p>从RxJava的官方定义来看，我们如果要想真正地理解RxJava，就必须对它以下两个部分进行深入的分析：</p>
<ol>
<li><p><strong>订阅流程</strong></p>
</li>
<li><p><strong>线程切换</strong></p>
</li>
</ol>
<p>当然，RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂。</p>
<h2 id="RxJava的订阅流程"><a href="#RxJava的订阅流程" class="headerlink" title="RxJava的订阅流程"></a>RxJava的订阅流程</h2><p>首先给出RxJava消息订阅的例子：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">create</span>(newObservableOnSubscribe&lt;<span class="hljs-title class_">String</span>&gt;() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-title class_">ObservableEmitter</span>&lt;<span class="hljs-title class_">String</span>&gt;emitter) throws <span class="hljs-title class_">Exception</span> {<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"1"</span>);<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"2"</span>);<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"3"</span>);<br>        emitter.<span class="hljs-title function_">onComplete</span>();<br>    }<br>}).<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-title class_">String</span>&gt;() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSubscribe</span>(<span class="hljs-params">Disposable d</span>) {<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onSubscribe"</span>);<br>    }<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) {<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onNext : "</span> + s);<br>    }<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) {<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onError : "</span> + e.<span class="hljs-title function_">toString</span>());<br>    }<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onComplete</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onComplete"</span>);<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里首先创建了一个被观察者，然后创建一个观察者订阅了这个被观察者，因此下面分两个部分对RxJava的订阅流程进行分析：</p>
<ol>
<li><p><strong>创建被观察者过程</strong></p>
</li>
<li><p><strong>订阅过程</strong></p>
</li>
</ol>
<h3 id="创建被观察者过程"><a href="#创建被观察者过程" class="headerlink" title="创建被观察者过程"></a>创建被观察者过程</h3><p>首先，上面使用了Observable类的create()方法创建了一个被观察者，看看里面做了什么。</p>
<h4 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable#create()"></a>Observable#create()</h4><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 省略一些检测性的注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; <span class="hljs-keyword">source</span>) {<br>    ObjectHelper.requireNonNull(<span class="hljs-keyword">source</span>, <span class="hljs-string">"source is null"</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableCreate&lt;T&gt;(<span class="hljs-keyword">source</span>));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在Observable的create()<br>里面实际上是创建了一个新的ObservableCreate对象，同时，把我们定义好的ObservableOnSubscribe对象传入了ObservableCreate对象中，最后调用了RxJavaPlugins.onAssembly()<br>方法。接下来看看这个ObservableCreate是干什么的。</p>
<h4 id="ObservableCreate"><a href="#ObservableCreate" class="headerlink" title="ObservableCreate"></a>ObservableCreate</h4><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableCreate&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable&lt;T&gt;</span> </span>{<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt; source;<br><br>    public <span class="hljs-type">ObservableCreate</span>(<span class="hljs-type">ObservableOnSubscribe</span>&lt;<span class="hljs-type">T</span>&gt; source) {<br>        <span class="hljs-keyword">this</span>.source = source;<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里仅仅是把ObservableOnSubscribe这个对象保存在ObservableCreate中了。然后看看RxJavaPlugins.onAssembly()这个方法的处理。</p>
<h4 id="RxJavaPlugins-onAssembly"><a href="#RxJavaPlugins-onAssembly" class="headerlink" title="RxJavaPlugins#onAssembly()"></a>RxJavaPlugins#onAssembly()</h4><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt; onAssembly(<span class="hljs-meta">@NonNull</span> <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt; source) {<br><br>    <span class="hljs-comment">// 应用hook函数的一些处理，一般用到不到</span><br>    <span class="hljs-operator">...</span><br>    <span class="hljs-keyword">return</span> source;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>最终仅仅是把我们的ObservableCreate给返回了。</p>
<h4 id="创建被观察者过程小结"><a href="#创建被观察者过程小结" class="headerlink" title="创建被观察者过程小结"></a>创建被观察者过程小结</h4><p>从以上分析可知，Observable.create()方法仅仅是**先将我们自定义的ObservableOnSubscribe对象重新包装成了一个ObservableCreate对象<br>**。</p>
<h3 id="订阅过程"><a href="#订阅过程" class="headerlink" title="订阅过程"></a>订阅过程</h3><p>接着，看看Observable.subscribe()的订阅过程是如何实现的。</p>
<h4 id="Observable-subscribe"><a href="#Observable-subscribe" class="headerlink" title="Observable#subscribe()"></a>Observable#subscribe()</h4><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>{<br>    ...<br>    <br>    <span class="hljs-comment">// 1</span><br>    observer = RxJavaPlugins.onSubscribe(<span class="hljs-keyword">this</span>,observer);<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 2</span><br>    subscribeActual(observer);<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，在Observable的subscribe()方法内部首先调用了RxJavaPlugins的onSubscribe()方法。</p>
<h4 id="RxJavaPlugins-onSubscribe"><a href="#RxJavaPlugins-onSubscribe" class="headerlink" title="RxJavaPlugins#onSubscribe()"></a>RxJavaPlugins#onSubscribe()</h4><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Observer</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; onSubscribe(<span class="hljs-meta">@NonNull</span> <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">T</span>&gt; source, <span class="hljs-meta">@NonNull</span> <span class="hljs-type">Observer</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; observer) {<br><br>    <span class="hljs-comment">// 应用hook函数的一些处理，一般用到不到</span><br>    <span class="hljs-operator">...</span><br>    <br>    <span class="hljs-keyword">return</span> observer;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>除去hook应用的逻辑，这里仅仅是将observer返回了。接着来分析下注释2处的subscribeActual()方法，</p>
<h4 id="Observable-subscribeActual"><a href="#Observable-subscribeActual" class="headerlink" title="Observable#subscribeActual()"></a>Observable#subscribeActual()</h4><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span></span>;<br></code></pre></td></tr></tbody></table></figure>

<p>这是一个抽象的方法，很明显，它对应的具体实现类就是我们在第一步创建的ObservableCreate类，接下来看到ObservableCreate的subscribeActual()<br>方法。</p>
<h4 id="ObservableCreate-subscribeActual"><a href="#ObservableCreate-subscribeActual" class="headerlink" title="ObservableCreate#subscribeActual()"></a>ObservableCreate#subscribeActual()</h4><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void subscribe<span class="hljs-constructor">Actual(Observer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">observer</span>)</span> {<br>    <span class="hljs-comment">// 1</span><br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    <span class="hljs-comment">// 2</span><br>    observer.on<span class="hljs-constructor">Subscribe(<span class="hljs-params">parent</span>)</span>;<br><br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 3</span><br>        source.subscribe(parent);<br>    } catch (Throwable ex) {<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Exceptions</span>.</span></span>throw<span class="hljs-constructor">IfFatal(<span class="hljs-params">ex</span>)</span>;<br>        parent.on<span class="hljs-constructor">Error(<span class="hljs-params">ex</span>)</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，首先新创建了一个CreateEmitter对象，同时传入了我们自定义的observer对象进去。</p>
<h5 id="CreateEmitter"><a href="#CreateEmitter" class="headerlink" title="CreateEmitter"></a>CreateEmitter</h5><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CreateEmitter</span>&lt;<span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">extends</span> <span class="hljs-symbol">AtomicReference</span>&lt;<span class="hljs-symbol">Disposable</span>&gt;<br><span class="hljs-symbol">implements</span> <span class="hljs-symbol">ObservableEmitter</span>&lt;<span class="hljs-symbol">T</span>&gt;, <span class="hljs-symbol">Disposable</span> {<br><br>    ...<br>    <br>    <span class="hljs-keyword">final</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer;<br><br>    CreateEmitter(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) {<br>        <span class="hljs-keyword">this</span>.observer = observer;<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从上面可以看出，<strong>CreateEmitter通过继承了Java并发包中的原子引用类AtomicReference保证了事件流切断状态Dispose的一致性</strong><br>（这里不理解的话，看到后面讲解Dispose的时候就明白了），并<strong>实现了ObservableEmitter接口和Disposable接口</strong><br>，接着我们分析下注释2处的observer.onSubscribe(parent)，这个onSubscribe回调的含义其实就是**告诉观察者已经成功订阅了被观察者<br>**。再看到注释3处的source.subscribe(parent)<br>这行代码，这里的source其实是ObservableOnSubscribe对象，我们看到ObservableOnSubscribe的subscribe()方法。</p>
<h5 id="ObservableOnSubscribe-subscribe"><a href="#ObservableOnSubscribe-subscribe" class="headerlink" title="ObservableOnSubscribe#subscribe()"></a>ObservableOnSubscribe#subscribe()</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Observable</span> <span class="hljs-variable">observable</span> <span class="hljs-operator">=</span> Observable.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObservableOnSubscribe</span>&lt;String&gt;() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">voidsubscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception {<br>        emitter.onNext(<span class="hljs-string">"1"</span>);<br>        emitter.onNext(<span class="hljs-string">"2"</span>);<br>        emitter.onNext(<span class="hljs-string">"3"</span>);<br>        emitter.onComplete();<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>

<p>这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()<br>方法完成了订阅过程。ObservableEmitter是一个抽象类，实现类就是我们传入的CreateEmitter对象，接下来我们看看CreateEmitter的onNext()<br>方法和onComplete()方法的处理。</p>
<h5 id="CreateEmitter-onNext-CreateEmitter-onComplete"><a href="#CreateEmitter-onNext-CreateEmitter-onComplete" class="headerlink" title="CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()"></a>CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()</h5><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CreateEmitter</span>&lt;<span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">extends</span> <span class="hljs-symbol">AtomicReference</span>&lt;<span class="hljs-symbol">Disposable</span>&gt;<br><span class="hljs-symbol">implements</span> <span class="hljs-symbol">ObservableEmitter</span>&lt;<span class="hljs-symbol">T</span>&gt;, <span class="hljs-symbol">Disposable</span> {<br><br>...<br><br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> onNext(T t) {<br>    ...<br>    <br>    <span class="hljs-keyword">if</span> (!isDisposed()) {<br>        <span class="hljs-comment">//调用观察者的onNext()</span><br>        observer.onNext(t);<br>    }<br>}<br><br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> onComplete() {<br>    <span class="hljs-keyword">if</span> (!isDisposed()) {<br>        <span class="hljs-keyword">try</span> {<br>            observer.onComplete();<br>        } finally {<br>            dispose();<br>        }<br>    }<br>}<br><br><br>...<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在CreateEmitter的onNext和onComplete方法中首先都要经过一个<strong>isDisposed</strong>的判断，作用就是看**当前的事件流是否被切断（废弃）掉了<br>**，默认是不切断的，如果想要切断，可以调用Disposable的dispose()方法将此状态设置为切断（废弃）状态。继续看看这个isDisposed内部的处理。</p>
<h5 id="ObservableEmitter-isDisposed"><a href="#ObservableEmitter-isDisposed" class="headerlink" title="ObservableEmitter#isDisposed()"></a>ObservableEmitter#isDisposed()</h5><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isDisposed</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">DisposableHelper</span>.<span class="hljs-title function_">isDisposed</span>(<span class="hljs-title function_">get</span>());<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意到这里通过get()<br>方法首先从ObservableEmitter的AtomicReference中拿到了保存的Disposable状态。然后交给了DisposableHelper进行判断处理。接下来看看DisposableHelper的处理。</p>
<h5 id="DisposableHelper-isDisposed-DisposableHelper-set"><a href="#DisposableHelper-isDisposed-DisposableHelper-set" class="headerlink" title="DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()"></a>DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DisposableHelper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Disposable</span> {<br><br>    DISPOSED;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDisposed</span><span class="hljs-params">(Disposable d)</span> {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">return</span> d == DISPOSED;<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">set</span><span class="hljs-params">(AtomicReference&lt;Disposable&gt; field, Disposable d)</span> {<br>        <span class="hljs-keyword">for</span> (;;) {<br>            <span class="hljs-type">Disposable</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> field.get();<br>            <span class="hljs-keyword">if</span> (current == DISPOSED) {<br>                <span class="hljs-keyword">if</span> (d != <span class="hljs-literal">null</span>) {<br>                    d.dispose();<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-comment">// 2</span><br>            <span class="hljs-keyword">if</span> (field.compareAndSet(current, d)) {<br>                <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) {<br>                    current.dispose();<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>        }<br>    }<br>    <br>    ...<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispose</span><span class="hljs-params">(AtomicReference&lt;Disposable&gt; field)</span> {<br>        <span class="hljs-type">Disposable</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> field.get();<br>        <span class="hljs-type">Disposable</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> DISPOSED;<br>        <span class="hljs-keyword">if</span> (current != d) {<br>            <span class="hljs-comment">// ...</span><br>            current = field.getAndSet(d);<br>            <span class="hljs-keyword">if</span> (current != d) {<br>                <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) {<br>                    current.dispose();<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来<strong>标记事件流被切断（废弃）状态的</strong><br>。先看到注释2和注释3处的代码**field.compareAndSet(current, d)和field.getAndSet(d)<strong>，这里使用了*<br>*原子引用AtomicReference内部包装的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab2c8fce878b">CAS</a>方法处理了标志Disposable的并发读写问题</strong><br>。最后看到注释3处，将我们传入的CreateEmitter这个原子引用类保存的Dispable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。为了更进一步理解Disposed的作用，再来看看CreateEmitter中剩余的关键方法。</p>
<h5 id="CreateEmitter-1"><a href="#CreateEmitter-1" class="headerlink" title="CreateEmitter"></a>CreateEmitter</h5><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params">T t</span>) {<br>    ...<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isDisposed</span>()) {<br>        observer.<span class="hljs-title function_">onNext</span>(t);<br>    }<br>}<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable t</span>) {<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">tryOnError</span>(t)) {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-title class_">RxJavaPlugins</span>.<span class="hljs-title function_">onError</span>(t);<br>    }<br>}<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryOnError</span>(<span class="hljs-params">Throwable t</span>) {<br>    ...<br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isDisposed</span>()) {<br>        <span class="hljs-keyword">try</span> {<br>            observer.<span class="hljs-title function_">onError</span>(t);<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 4</span><br>            <span class="hljs-title function_">dispose</span>();<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onComplete</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isDisposed</span>()) {<br>        <span class="hljs-keyword">try</span> {<br>            observer.<span class="hljs-title function_">onComplete</span>();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 6</span><br>            <span class="hljs-title function_">dispose</span>();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1、3、5处，onNext()和onError()、onComplete()方法首先都会判断事件流是否被切断，如果事件流此时被切断了，那么onNext()<br>和onComplete()则会退出方法体，不做处理，**onError()则会执行到RxJavaPlugins.onError(t)这句代码，内部会直接抛出异常，导致崩溃<br>**。如果事件流没有被切断，那么在onError()和onComplete()内部最终会调用到注释4、6处的这句dispose()代码，将事件流进行切断，由此可知，<br><strong>onError()和onComplete()只能调用一个，如果先执行的是onComplete()，再调用onError()的话就会导致异常崩溃</strong>。</p>
<h2 id="RxJava的线程切换"><a href="#RxJava的线程切换" class="headerlink" title="RxJava的线程切换"></a>RxJava的线程切换</h2><p>首先给出RxJava线程切换的例子：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObservableOnSubscribe</span>&lt;<span class="hljs-title class_">String</span>&gt;() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">voidsubscribe</span>(<span class="hljs-title class_">ObservableEmitter</span>&lt;<span class="hljs-title class_">String</span>&gt;emitter) throws <span class="hljs-title class_">Exception</span> {<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"1"</span>);<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"2"</span>);<br>        emitter.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">"3"</span>);<br>        emitter.<span class="hljs-title function_">onComplete</span>();<br>    }<br>}) <br>    .<span class="hljs-title function_">subscribeOn</span>(<span class="hljs-title class_">Schedulers</span>.<span class="hljs-title function_">io</span>())<br>    .<span class="hljs-title function_">observeOn</span>(<span class="hljs-title class_">AndroidSchedulers</span>.<span class="hljs-title function_">mainThread</span>())<br>    .<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-title class_">String</span>&gt;() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSubscribe</span>(<span class="hljs-params">Disposable d</span>) {<br>            <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onSubscribe"</span>);<br>        }<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) {<br>            <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onNext : "</span> + s);<br>        }<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) {<br>            <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onError : "</span> +e.<span class="hljs-title function_">toString</span>());<br>        }<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onComplete</span>(<span class="hljs-params"></span>) {<br>            <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"onComplete"</span>);<br>        }<br>});<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，RxJava的线程切换主要<strong>分为subscribeOn()和observeOn()方法</strong>，首先，来分析下subscribeOn()方法。</p>
<h3 id="subscribeOn-Schedulers-io"><a href="#subscribeOn-Schedulers-io" class="headerlink" title="subscribeOn(Schedulers.io())"></a>subscribeOn(Schedulers.io())</h3><p>在Schedulers.io()<br>方法中，我们需要先传入一个Scheduler调度类，这里是传入了一个调度到io子线程的调度类，我们看看这个Schedulers.io()<br>方法内部是怎么构造这个调度器的。</p>
<h3 id="Schedulers-io"><a href="#Schedulers-io" class="headerlink" title="Schedulers#io()"></a>Schedulers#io()</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Scheduler</span> IO;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-built_in">Scheduler</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> RxJavaPlugins.<span class="hljs-built_in">onIoScheduler</span>(IO);<br>}<br><br><span class="hljs-type">static</span> {<br>    ...<br><br>    <span class="hljs-comment">// 2</span><br>    IO = RxJavaPlugins.<span class="hljs-built_in">initIoScheduler</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">IOTask</span>());<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOTask</span> implements Callable&lt;<span class="hljs-built_in">Scheduler</span>&gt; {<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Scheduler</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> throws Exception </span>{<br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-keyword">return</span> IoHolder.<span class="hljs-literal">DEFAULT</span>;<br>    }<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IoHolder</span> {<br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Scheduler</span> <span class="hljs-literal">DEFAULT</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">IoScheduler</span>();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>Schedulers这个类的代码很多，这里我只拿出有关Schedulers.io这个方法涉及的逻辑代码进行讲解。首先，在注释1处，同前面分析的订阅流程的处理一样，只是一个处理hook的逻辑，最终返回的还是传入的这个IO对象。再看到注释2处，<br><strong>在Schedulers的静态代码块中将IO对象进行了初始化，其实质就是新建了一个IOTask的静态内部类</strong><br>，在IOTask的call方法中，也就是注释3处，可以了解到使用了静态内部类的方式把创建的IOScheduler对象给返回出去了。绕了这么大圈子，*<br>*Schedulers.io方法其实质就是返回了一个IOScheduler对象**。</p>
<h3 id="Observable-subscribeOn"><a href="#Observable-subscribeOn" class="headerlink" title="Observable#subscribeOn()"></a>Observable#subscribeOn()</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(<span class="hljs-built_in">Scheduler</span> scheduler)</span> </span>{<br>    ...<br>    <br>    <span class="hljs-keyword">return</span> RxJavaPlugins.<span class="hljs-built_in">onAssembly</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ObservableSubscribeOn</span>&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在subscribeOn()方法里面，又将ObservableCreate包装成了一个ObservableSubscribeOn对象。我们关注到ObservableSubscribeOn类。</p>
<h3 id="ObservableSubscribeOn"><a href="#ObservableSubscribeOn" class="headerlink" title="ObservableSubscribeOn"></a>ObservableSubscribeOn</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableSubscribeOn&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractObservableWithUpstream&lt;T</span>, <span class="hljs-title">T&gt;</span> </span>{<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Scheduler</span> scheduler;<br><br>    public <span class="hljs-type">ObservableSubscribeOn</span>(<span class="hljs-type">ObservableSource</span>&lt;<span class="hljs-type">T</span>&gt; source, <span class="hljs-type">Scheduler</span> scheduler) {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">super</span>(source);<br>        <span class="hljs-keyword">this</span>.scheduler = scheduler;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    public void subscribeActual(<span class="hljs-keyword">final</span> <span class="hljs-type">Observer</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; observer) {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SubscribeOnObserver</span>&lt;<span class="hljs-type">T</span>&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-type">SubscribeOnObserver</span>&lt;<span class="hljs-type">T</span>&gt;(observer);<br>        <br>        <span class="hljs-comment">// 3</span><br>        observer.onSubscribe(parent);<br>        <br>        <span class="hljs-comment">// 4</span><br>        parent.setDisposable(scheduler.scheduleDirect(<span class="hljs-keyword">new</span> <span class="hljs-type">SubscribeTask</span>(parent)));<br>    }<br><br>...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，将传进来的source和scheduler保存起来。接着，等到实际订阅的时候，就会执行到这个subscribeActual方法，在注释2处，将我们自定义的Observer包装成了一个SubscribeOnObserver对象。在注释3处，通知观察者订阅了被观察者。在注释4处，内部先创建了一个SubscribeTask对象，来看看它的实现。</p>
<h3 id="ObservableSubscribeOn-SubscribeTask"><a href="#ObservableSubscribeOn-SubscribeTask" class="headerlink" title="ObservableSubscribeOn#SubscribeTask"></a>ObservableSubscribeOn#SubscribeTask</h3><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">SubscribeTask</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;<br><br>    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    }<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() {<br>        source.subscribe(parent);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)<br>的订阅方法，<strong>这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象</strong><br>。接下来看看scheduler.scheduleDirect()内部的处理。</p>
<h3 id="Scheduler-scheduleDirect"><a href="#Scheduler-scheduleDirect" class="headerlink" title="Scheduler#scheduleDirect()"></a>Scheduler#scheduleDirect()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Disposable schedule<span class="hljs-constructor">Direct(@NonNull Runnable <span class="hljs-params">run</span>)</span> {<br>    return schedule<span class="hljs-constructor">Direct(<span class="hljs-params">run</span>, 0L, TimeUnit.NANOSECONDS)</span>;<br>}<br><br>public Disposable schedule<span class="hljs-constructor">Direct(@NonNull Runnable <span class="hljs-params">run</span>, <span class="hljs-params">long</span> <span class="hljs-params">delay</span>, @NonNull TimeUnit <span class="hljs-params">unit</span>)</span> {<br><br>    <span class="hljs-comment">// 1</span><br>    final Worker w = create<span class="hljs-constructor">Worker()</span>;<br><br>    <span class="hljs-comment">// 2</span><br>    final Runnable decoratedRun = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RxJavaPlugins</span>.</span></span>on<span class="hljs-constructor">Schedule(<span class="hljs-params">run</span>)</span>;<br><br>    <span class="hljs-comment">// 3</span><br>    DisposeTask task = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DisposeTask(<span class="hljs-params">decoratedRun</span>, <span class="hljs-params">w</span>)</span>;<br><br>    <span class="hljs-comment">// 4</span><br>    w.schedule(task, delay, <span class="hljs-built_in">unit</span>);<br><br>    return task;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里最后会执行到上面这个scheduleDirect()重载方法。首先，在注释1处，会调用createWorker()<br>方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面看看IoScheduler类的createWorker()方法。</p>
<h4 id="IOScheduler-createWorker"><a href="#IOScheduler-createWorker" class="headerlink" title="IOScheduler#createWorker()"></a>IOScheduler#createWorker()</h4><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">final</span> <span class="hljs-type">AtomicReference</span>&lt;<span class="hljs-type">CachedWorkerPool</span>&gt; pool;<br><br>...<br><br>public <span class="hljs-type">IoScheduler</span>(<span class="hljs-type">ThreadFactory</span> threadFactory) {<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.pool = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicReference</span>&lt;<span class="hljs-type">CachedWorkerPool</span>&gt;(<span class="hljs-type">NONE</span>);<br>    start();<br>}<br><br>...<br><br><span class="hljs-meta">@Override</span><br>public <span class="hljs-type">Worker</span> createWorker() {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">EventLoopWorker</span>(pool.get());<br>}<br><br>static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span>.<span class="hljs-title">Worker</span> </span>{<br>    ...<br><br>    <span class="hljs-type">EventLoopWorker</span>(<span class="hljs-type">CachedWorkerPool</span> pool) {<br>        <span class="hljs-keyword">this</span>.pool = pool;<br>        <span class="hljs-keyword">this</span>.tasks = <span class="hljs-keyword">new</span> <span class="hljs-type">CompositeDisposable</span>();<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">this</span>.threadWorker = pool.get();<br>    }<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处调用了pool.get()这个方法，<strong>pool是一个CachedWorkerPool类型的原子引用对象</strong>，它的作用就是**用于缓存工作者对象Worker的<br>**。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里将CachedWorkerPool缓存的threadWorker对象保存起来了。</p>
<p>下面继续分析3.6处代码段的注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个切断任务DisposeTask将decoratedRun和w对象包装了起来。最后在注释4处调用了工作者的schedule()<br>方法。下面来分析下它内部的处理。</p>
<h4 id="IoScheduler-schedule"><a href="#IoScheduler-schedule" class="headerlink" title="IoScheduler#schedule()"></a>IoScheduler#schedule()</h4><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public Disposable <span class="hljs-built_in">schedule</span>(<span class="hljs-variable">@NonNull</span> Runnableaction, long delayTime, <span class="hljs-variable">@NonNull</span> TimeUnit unit){<br>    ...<br>    <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">threadWorker</span><span class="hljs-selector-class">.scheduleActual</span>(action,delayTime, unit, tasks);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()<br>方法，继续看看NewThreadWorker的scheduleActual()方法中做的事情。</p>
<h4 id="NewThreadWorker-scheduleActual"><a href="#NewThreadWorker-scheduleActual" class="headerlink" title="NewThreadWorker#scheduleActual()"></a>NewThreadWorker#scheduleActual()</h4><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">NewThreadWorker(ThreadFactory <span class="hljs-params">threadFactory</span>)</span> {<br>    executor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SchedulerPoolFactory</span>.</span></span>create(threadFactory);<br>}<br><br><br>@NonNull<br>public ScheduledRunnable schedule<span class="hljs-constructor">Actual(<span class="hljs-params">final</span> Runnable <span class="hljs-params">run</span>, <span class="hljs-params">long</span> <span class="hljs-params">delayTime</span>, @NonNull TimeUnit <span class="hljs-params">unit</span>, @Nullable DisposableContainer <span class="hljs-params">parent</span>)</span> {<br>    Runnable decoratedRun = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RxJavaPlugins</span>.</span></span>on<span class="hljs-constructor">Schedule(<span class="hljs-params">run</span>)</span>;<br><br>    <span class="hljs-comment">// 1</span><br>    ScheduledRunnable sr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ScheduledRunnable(<span class="hljs-params">decoratedRun</span>, <span class="hljs-params">parent</span>)</span>;<br>    <br>   <br>    <span class="hljs-keyword">if</span> (parent != null) {<br>        <span class="hljs-keyword">if</span> (!parent.add(sr)) {<br>            return sr;<br>        }<br>    }<br><br>    Future&lt;?&gt; f;<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">if</span> (delayTime &lt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 3</span><br>            f = executor.submit((Callable&lt;Object&gt;)sr);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 4</span><br>            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, <span class="hljs-built_in">unit</span>);<br>        }<br>        sr.set<span class="hljs-constructor">Future(<span class="hljs-params">f</span>)</span>;<br>    } catch (RejectedExecutionException ex) {<br>        <span class="hljs-keyword">if</span> (parent != null) {<br>            parent.remove(sr);<br>        }<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RxJavaPlugins</span>.</span></span>on<span class="hljs-constructor">Error(<span class="hljs-params">ex</span>)</span>;<br>    }<br><br>    return sr;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，</p>
<ul>
<li></li>
<li><p>这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，它是一个保存所有事件流是否被切断状态的容器，其内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类进行存储<br>**。最后注释2处，判断是否设置了延迟时间，如果设置了，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()<br>方法进行延时执行线程切换。</p>
</li>
</ul>
<h3 id="为什么多次执行subscribeOn-，只有第一次有效？"><a href="#为什么多次执行subscribeOn-，只有第一次有效？" class="headerlink" title="为什么多次执行subscribeOn()，只有第一次有效？"></a>为什么多次执行subscribeOn()，只有第一次有效？</h3><p>从上面的分析，可以很容易了解到**被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe）<br>**，当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()<br>方法，这样肯定会覆盖前面的线程切换。</p>
<h3 id="observeOn-AndroidSchedulers-mainThread"><a href="#observeOn-AndroidSchedulers-mainThread" class="headerlink" title="observeOn(AndroidSchedulers.mainThread())"></a>observeOn(AndroidSchedulers.mainThread())</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final Observable&lt;T&gt; observe<span class="hljs-constructor">On(Scheduler <span class="hljs-params">scheduler</span>)</span> {<br>    return observe<span class="hljs-constructor">On(<span class="hljs-params">scheduler</span>, <span class="hljs-params">false</span>, <span class="hljs-params">bufferSize</span>()</span>);<br>}<br><br>public final Observable&lt;T&gt; observe<span class="hljs-constructor">On(Scheduler <span class="hljs-params">scheduler</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">delayError</span>, <span class="hljs-params">int</span> <span class="hljs-params">bufferSize</span>)</span> {<br>    ....<br>    <br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RxJavaPlugins</span>.</span></span>on<span class="hljs-constructor">Assembly(<span class="hljs-params">new</span> ObservableObserveOn&lt;T&gt;(<span class="hljs-params">this</span>, <span class="hljs-params">scheduler</span>, <span class="hljs-params">delayError</span>, <span class="hljs-params">bufferSize</span>)</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，直接来看看ObservableObserveOn的subscribeActual()<br>方法。</p>
<h3 id="ObservableObserveOn-subscribeActual"><a href="#ObservableObserveOn-subscribeActual" class="headerlink" title="ObservableObserveOn#subscribeActual()"></a>ObservableObserveOn#subscribeActual()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer)</span> {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> TrampolineScheduler) {<br>        <span class="hljs-comment">// 2</span><br>        source.subscribe(observer);<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// 3</span><br>        Scheduler.<span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> scheduler.createWorker();<br>        <span class="hljs-comment">// 4</span><br>        source.subscribe(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserveOnObserver</span>&lt;T&gt;(observer, w, delayError, bufferSize));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，立即执行当前代码的调度器。如果是，则会直接调用ObservableSubscribeOn的subscribe()<br>方法，如果不是，则会在注释3处创建一个工作者对象。然后，在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()<br>方法进行订阅。接下来看看ObserveOnObserver类的重点方法。</p>
<h3 id="ObserveOnObserver"><a href="#ObserveOnObserver" class="headerlink" title="ObserveOnObserver"></a>ObserveOnObserver</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public void <span class="hljs-built_in">onNext</span>(T t) {<br>    ...<br>    <span class="hljs-selector-tag">if</span> (sourceMode != QueueDisposable.ASYNC) {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-selector-tag">queue</span><span class="hljs-selector-class">.offer</span>(t);<br>    }<br>    <span class="hljs-selector-tag">schedule</span>();<br>}<br><br>@<span class="hljs-selector-tag">Override</span><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable t) {<br>    ...<br>    <span class="hljs-selector-tag">schedule</span>();<br>}<br><br><span class="hljs-variable">@Override</span><br>public void <span class="hljs-built_in">onComplete</span>() {<br>    ...<br>    <span class="hljs-selector-tag">schedule</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure>

<p>去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()<br>方法。接着看schedule()方法，其中<strong>onNext()还会把消息存放到队列中</strong>。</p>
<h3 id="ObserveOnObserver-schedule"><a href="#ObserveOnObserver-schedule" class="headerlink" title="ObserveOnObserver#schedule()"></a>ObserveOnObserver#schedule()</h3><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span>()</span> {<br>    <span class="hljs-keyword">if</span> (getAndIncrement() == <span class="hljs-number">0</span>) {<br>        worker.schedule(<span class="hljs-keyword">this</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是<br><strong>使用Handler进行线程切换的</strong>，此处不再赘述了。接着看ObserveOnObserver的run()方法。</p>
<h3 id="ObserveOnObserver-run"><a href="#ObserveOnObserver-run" class="headerlink" title="ObserveOnObserver#run()"></a>ObserveOnObserver#run()</h3><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Override</span><br>public void run() {<br>    <span class="hljs-comment">// 1</span><br>    if (outputFused) {<br>        <span class="hljs-built_in">drainFused</span>();<br>    } else {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-built_in">drainNormal</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处会<strong>先判断outputFused这个标志位，它表示事件流是否被融化掉，默认是false，所以，最后会执行到drainNormal()方法</strong><br>。接着看看drainNormal()方法内部的处理。</p>
<h3 id="ObserveOnObserver-drainNormal"><a href="#ObserveOnObserver-drainNormal" class="headerlink" title="ObserveOnObserver#drainNormal()"></a>ObserveOnObserver#drainNormal()</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drainNormal</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> missed = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">final</span> SimpleQueue&lt;T&gt; q = queue;<br>    <br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">final</span> Observer&lt;? super T&gt; a = downstream;<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 2</span><br>    v = q.<span class="hljs-built_in">poll</span>();<br>    <br>    ...<br>    <span class="hljs-comment">// 3</span><br>    a.<span class="hljs-built_in">onNext</span>(v);<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。<br><strong>最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()<br>方法下面的链式代码都会执行到它所指定的线程中，噢，原来如此</strong>。</p>
<blockquote>
<p>很多人使用RxJava也已经挺长时间了，但是一直没有去深入去了解过它的内部实现原理，<strong>如今细细品尝，的确是酣畅淋漓</strong>。</p>
</blockquote>
<h1 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h1><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>查看Leakcanary官方的github仓库，最重要的便是对<strong>Leakcanary是如何起作用的</strong>（即原理）这一问题进行了阐述，把它翻译成了易于理解的文字，主要分为如下7个步骤：</p>
<ol>
<li><p>RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。</p>
</li>
<li><p>然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。</p>
</li>
<li><p>如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。</p>
</li>
<li><p>HeapAnalyzerService被开启在一个独立的进程中，并且HeapAnalyzer使用了HAHA开源库解析了指定时刻的堆栈快照文件heap dump。</p>
</li>
<li><p>从heap dump中，HeapAnalyzer根据一个独特的引用key找到了KeyedWeakReference，并且定位了泄露的引用。</p>
</li>
<li><p>HeapAnalyzer为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。</p>
</li>
<li><p>这个结果被传回到app进程中的DisplayLeakService，然后一个泄露通知便展现出来了。</p>
</li>
</ol>
<p>官方的原理简单来解释就是这样的：**在一个Activity执行完onDestroy()<br>之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有没有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。<br>**</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>下面这段是Leakcanary官方仓库的示例代码：</p>
<p>首先在你项目app下的build.gradle中配置:</p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">dependencies {<br>  debugImplementation <span class="hljs-string">'com.squareup.leakcanary:leakcanary-android:1.6.2'</span><br>  releaseImplementation   <span class="hljs-string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.2'</span><br>  <span class="hljs-regexp">//</span> 可选，如果你使用支持库的fragments的话<br>  debugImplementation   <span class="hljs-string">'com.squareup.leakcanary:leakcanary-support-fragment:1.6.2'</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>然后在你的Application中配置:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WanAndroidApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RefWatcher</span> refWatcher;<br>    <br>    public static <span class="hljs-type">RefWatcher</span> getRefWatcher(<span class="hljs-type">Context</span> context) {<br>        <span class="hljs-type">WanAndroidApp</span> application = (<span class="hljs-type">WanAndroidApp</span>)     context.getApplicationContext();<br>        <span class="hljs-keyword">return</span> application.refWatcher;<br>    }<br><br>    <span class="hljs-meta">@Override</span> public void onCreate() {<br>      <span class="hljs-keyword">super</span>.onCreate();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-type">LeakCanary</span>.isInAnalyzerProcess(<span class="hljs-keyword">this</span>)) {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">return</span>;<br>      }<br>      <span class="hljs-comment">// 2</span><br>      refWatcher = <span class="hljs-type">LeakCanary</span>.install(<span class="hljs-keyword">this</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，会首先判断当前进程是否是Leakcanary专门用于分析heap内存的而创建的那个进程，即HeapAnalyzerService所在的进程，如果是的话，则不进行Application中的初始化功能。如果是当前应用所处的主进程的话，则会执行注释2处的LeakCanary.install(<br>this)<br>进行LeakCanary的安装。只需这样简单的几行代码，我们就可以在应用中检测是否产生了内存泄露了。当然，这样使用只会检测Activity和标准Fragment是否发生内存泄漏，如果要检测V4包的Fragment在执行完onDestroy()<br>之后是否发生内存泄露的话，则需要在Fragment的onDestroy()方法中加上如下两行代码去监视当前的Fragment：</p>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">RefWatcher refWatcher <span class="hljs-operator">=</span> WanAndroidApp.getRefWatcher(_mActivity)<span class="hljs-comment">;</span><br>refWatcher.watch(this)<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure>

<p>上面的<strong>RefWatcher其实就是一个引用观察者对象，是用于监测当前实例对象的引用状态的</strong><br>。从以上的分析可以了解到，核心代码就是LeakCanary.install(this)这行代码，接下来，就从这里出发将LeakCanary一步一步进行拆解。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="LeakCanary-install"><a href="#LeakCanary-install" class="headerlink" title="LeakCanary#install()"></a>LeakCanary#install()</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> @<span class="hljs-selector-tag">NonNull</span> <span class="hljs-selector-tag">RefWatcher</span> <span class="hljs-selector-tag">install</span>(<span class="hljs-variable">@NonNull</span> Application application) {<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">refWatcher</span>(application)<span class="hljs-selector-class">.listenerServiceClass</span>(DisplayLeakService.class)<br>      <span class="hljs-selector-class">.excludedRefs</span>(AndroidExcludedRefs.<span class="hljs-built_in">createAppDefaults</span>().<span class="hljs-built_in">build</span>())<br>      <span class="hljs-selector-class">.buildAndInstall</span>();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在install()方法中的处理，可以分解为如下四步：</p>
<ol>
<li><p><strong>refWatcher(application)</strong></p>
</li>
<li><p><strong>链式调用listenerServiceClass(DisplayLeakService.class)</strong></p>
</li>
<li><p><strong>链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</strong></p>
</li>
<li><p><strong>链式调用buildAndInstall()</strong></p>
</li>
</ol>
<p>首先，我们来看下第一步，这里调用了LeakCanary类的refWatcher方法，如下所示：</p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> @<span class="hljs-selector-tag">NonNull</span> <span class="hljs-selector-tag">AndroidRefWatcherBuilder</span> <span class="hljs-selector-tag">refWatcher</span>(<span class="hljs-variable">@NonNull</span> Context context) {<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">AndroidRefWatcherBuilder</span>(context);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>然后新建了一个AndroidRefWatcherBuilder对象，再看看AndroidRefWatcherBuilder这个类。</p>
<h3 id="AndroidRefWatcherBuilder"><a href="#AndroidRefWatcherBuilder" class="headerlink" title="AndroidRefWatcherBuilder"></a>AndroidRefWatcherBuilder</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/** A {@link RefWatcherBuilder} with appropriate Android defaults. */</span><br>public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidRefWatcherBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RefWatcherBuilder&lt;AndroidRefWatcherBuilder&gt;</span> </span>{<br><br>...<br><br>    <span class="hljs-type">AndroidRefWatcherBuilder</span>(<span class="hljs-meta">@NonNull</span> <span class="hljs-type">Context</span> context) {<br>        <span class="hljs-keyword">this</span>.context = context.getApplicationContext();<br>    }<br><br>...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在AndroidRefWatcherBuilder的构造方法中仅仅是将外部传入的applicationContext对象保存起来了。*<br>*AndroidRefWatcherBuilder是一个适配Android平台的引用观察者构造器对象，它继承了RefWatcherBuilder，RefWatcherBuilder是一个负责建立引用观察者RefWatcher实例的基类构造器<br>**。继续看看RefWatcherBuilder这个类。</p>
<h3 id="RefWatcherBuilder"><a href="#RefWatcherBuilder" class="headerlink" title="RefWatcherBuilder"></a>RefWatcherBuilder</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefWatcherBuilder&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RefWatcherBuilder&lt;T&gt;&gt;</span> </span>{<br><br>    ...<br>    <br>    public <span class="hljs-type">RefWatcherBuilder</span>() {<br>        heapDumpBuilder = <span class="hljs-keyword">new</span> <span class="hljs-type">HeapDump</span>.<span class="hljs-type">Builder</span>();<br>    }<br><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在RefWatcher的基类构造器RefWatcherBuilder的构造方法中新建了一个HeapDump的构造器对象。其中<strong>HeapDump就是一个保存heap<br>dump信息的数据结构</strong>。</p>
<p>接着来分析下install()方法中的链式调用的listenerServiceClass(DisplayLeakService.class)这部分逻辑。</p>
<h3 id="AndroidRefWatcherBuilder-listenerServiceClass"><a href="#AndroidRefWatcherBuilder-listenerServiceClass" class="headerlink" title="AndroidRefWatcherBuilder#listenerServiceClass()"></a>AndroidRefWatcherBuilder#listenerServiceClass()</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> @<span class="hljs-selector-tag">NonNull</span> <span class="hljs-selector-tag">AndroidRefWatcherBuilder</span> <span class="hljs-selector-tag">listenerServiceClass</span>(<br>  <span class="hljs-variable">@NonNull</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">heapDumpListener</span>(new <span class="hljs-built_in">ServiceHeapDumpListener</span>(context, listenerServiceClass));<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在这里，传入了一个DisplayLeakService的Class对象，它的作用是展示泄露分析的结果日志，然后会展示一个用于跳转到显示泄露界面DisplayLeakActivity的通知。在listenerServiceClass()<br>这个方法中新建了一个ServiceHeapDumpListener对象，下面看看它内部的操作。</p>
<h3 id="ServiceHeapDumpListener"><a href="#ServiceHeapDumpListener" class="headerlink" title="ServiceHeapDumpListener"></a>ServiceHeapDumpListener</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceHeapDumpListener</span> <span class="hljs-title">implements</span> <span class="hljs-title">HeapDump</span>.<span class="hljs-title">Listener</span> {<br><br>    ...<br>    <br>    <span class="hljs-keyword">public</span> ServiceHeapDumpListener(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Context context,<br>        <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {<br>      <span class="hljs-keyword">this</span>.listenerServiceClass = checkNotNull(listenerServiceClass, <span class="hljs-string">"listenerServiceClass"</span>);<br>      <span class="hljs-keyword">this</span>.context = checkNotNull(context, <span class="hljs-string">"context"</span>).getApplicationContext();<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到这里仅仅是在ServiceHeapDumpListener中保存了DisplayLeakService的Class对象和application对象。它的作用就是接收一个heap<br>dump去分析。</p>
<p>然后我们继续看install()方法链式调用.excludedRefs(AndroidExcludedRefs.createAppDefaults().build())<br>的这部分代码。先看AndroidExcludedRefs.createAppDefaults()。</p>
<h3 id="AndroidExcludedRefs-createAppDefaults"><a href="#AndroidExcludedRefs-createAppDefaults" class="headerlink" title="AndroidExcludedRefs#createAppDefaults()"></a>AndroidExcludedRefs#createAppDefaults()</h3><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> AndroidExcludedRefs {<br><br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> @NonNull ExcludedRefs.<span class="hljs-function">Builder <span class="hljs-title">createAppDefaults</span>()</span> {<br>      <span class="hljs-keyword">return</span> createBuilder(EnumSet.allOf(AndroidExcludedRefs.<span class="hljs-keyword">class</span>));<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> @NonNull ExcludedRefs.<span class="hljs-function">Builder <span class="hljs-title">createBuilder</span>(<span class="hljs-params">EnumSet&lt;AndroidExcludedRefs&gt; refs</span>)</span> {<br>      ExcludedRefs.Builder excluded = ExcludedRefs.builder();<br>      <span class="hljs-keyword">for</span> (AndroidExcludedRefs <span class="hljs-keyword">ref</span> : refs) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ref</span>.applies) {<br>          <span class="hljs-keyword">ref</span>.<span class="hljs-keyword">add</span>(excluded);<br>          ((ExcludedRefs.BuilderWithParams) excluded).named(<span class="hljs-keyword">ref</span>.name());<br>        }<br>      }<br>      <span class="hljs-keyword">return</span> excluded;<br>    }<br>    <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>先来说下<strong>AndroidExcludedRefs</strong>这个类，它是一个enum类，它<strong>声明了Android SDK和厂商定制的SDK中存在的内存泄露的case</strong><br>，根据AndroidExcludedRefs这个类的类名就可看出这些case<strong>都会被Leakcanary的监测过滤掉</strong>。目前这个版本是有<strong>46种</strong>这样的*<br><em>case**被包含在内，后续可能会一直增加。然后EnumSet.allOf(AndroidExcludedRefs.class)<br>这个方法将会返回一个包含AndroidExcludedRefs元素类型的EnumSet。Enum是一个抽象类，在这里具体的实现类是</em><br><em>通用正规型的RegularEnumSet，如果Enum里面的元素个数大于64，则会使用存储大数据量的JumboEnumSet</em>*<br>。最后，在createBuilder这个方法里面构建了一个排除引用的建造器excluded，将各式各样的case分门别类地保存起来再返回出去。</p>
<p>最后看到链式调用的最后一步buildAndInstall()。</p>
<h3 id="AndroidRefWatcherBuilder-buildAndInstall"><a href="#AndroidRefWatcherBuilder-buildAndInstall" class="headerlink" title="AndroidRefWatcherBuilder#buildAndInstall()"></a>AndroidRefWatcherBuilder#buildAndInstall()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> boolean watchActivities = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">private</span> boolean watchFragments = <span class="hljs-literal">true</span>;<br><br>public @NonNull RefWatcher build<span class="hljs-constructor">AndInstall()</span> {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LeakCanaryInternals</span>.</span></span>installedRefWatcher != null) {<br>      throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">UnsupportedOperationException(<span class="hljs-string">"buildAndInstall() should only be called once."</span>)</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 2</span><br>    RefWatcher refWatcher = build<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (refWatcher != DISABLED) {<br>      <span class="hljs-comment">// 3</span><br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LeakCanaryInternals</span>.</span></span>set<span class="hljs-constructor">EnabledAsync(<span class="hljs-params">context</span>, DisplayLeakActivity.<span class="hljs-params">class</span>, <span class="hljs-params">true</span>)</span>;<br>      <span class="hljs-keyword">if</span> (watchActivities) {<br>        <span class="hljs-comment">// 4</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ActivityRefWatcher</span>.</span></span>install(context, refWatcher);<br>      }<br>      <span class="hljs-keyword">if</span> (watchFragments) {<br>        <span class="hljs-comment">// 5</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FragmentRefWatcher</span>.</span><span class="hljs-module"><span class="hljs-identifier">Helper</span>.</span></span>install(context, refWatcher);<br>      }<br>    }<br>    <span class="hljs-comment">// 6</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LeakCanaryInternals</span>.</span></span>installedRefWatcher = refWatcher;<br>    return refWatcher;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，会判断LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告<br>buildAndInstall()<br>这个方法应该仅仅只调用一次，在此方法结束时，即在注释6处，该LeakCanaryInternals.installedRefWatcher才会被赋值。再来看注释2处，调用了AndroidRefWatcherBuilder其基类RefWatcherBuilder的build()<br>方法，看看它是如何建造的。</p>
<h3 id="RefWatcherBuilder-build"><a href="#RefWatcherBuilder-build" class="headerlink" title="RefWatcherBuilder#build()"></a>RefWatcherBuilder#build()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> RefWatcher <span class="hljs-title function_">build</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">if</span> (isDisabled()) {<br>      <span class="hljs-keyword">return</span> RefWatcher.DISABLED;<br>    }<br><br>    <span class="hljs-keyword">if</span> (heapDumpBuilder.excludedRefs == <span class="hljs-literal">null</span>) {<br>      heapDumpBuilder.excludedRefs(defaultExcludedRefs());<br>    }<br><br>    HeapDump.<span class="hljs-type">Listener</span> <span class="hljs-variable">heapDumpListener</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.heapDumpListener;<br>    <span class="hljs-keyword">if</span> (heapDumpListener == <span class="hljs-literal">null</span>) {<br>      heapDumpListener = defaultHeapDumpListener();<br>    }<br><br>    <span class="hljs-type">DebuggerControl</span> <span class="hljs-variable">debuggerControl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.debuggerControl;<br>    <span class="hljs-keyword">if</span> (debuggerControl == <span class="hljs-literal">null</span>) {<br>      debuggerControl = defaultDebuggerControl();<br>    }<br><br>    <span class="hljs-type">HeapDumper</span> <span class="hljs-variable">heapDumper</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.heapDumper;<br>    <span class="hljs-keyword">if</span> (heapDumper == <span class="hljs-literal">null</span>) {<br>      heapDumper = defaultHeapDumper();<br>    }<br><br>    <span class="hljs-type">WatchExecutor</span> <span class="hljs-variable">watchExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.watchExecutor;<br>    <span class="hljs-keyword">if</span> (watchExecutor == <span class="hljs-literal">null</span>) {<br>      watchExecutor = defaultWatchExecutor();<br>    }<br><br>    <span class="hljs-type">GcTrigger</span> <span class="hljs-variable">gcTrigger</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.gcTrigger;<br>    <span class="hljs-keyword">if</span> (gcTrigger == <span class="hljs-literal">null</span>) {<br>      gcTrigger = defaultGcTrigger();<br>    }<br><br>    <span class="hljs-keyword">if</span> (heapDumpBuilder.reachabilityInspectorClasses == <span class="hljs-literal">null</span>) {<br>      heapDumpBuilder.reachabilityInspectorClasses(defa  <span class="hljs-title function_">ultReachabilityInspectorClasses</span><span class="hljs-params">()</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefWatcher</span>(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,<br>        heapDumpBuilder);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，<strong>RefWatcherBuilder包含了以下7个组成部分：</strong></p>
<ol>
<li><p><strong>excludedRefs : 记录可以被忽略的泄漏路径</strong>。</p>
</li>
<li><p>**heapDumpListener : 转储堆信息到hprof文件，并在解析完 hprof 文件后进行回调，最后通知 DisplayLeakService 弹出泄漏提醒<br>**。</p>
</li>
<li><p>debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。为什么呢？因为**在调试过程中可能会保留上一个引用从而导致错误信息上报<br>**。</p>
</li>
<li><p><strong>heapDumper : 堆信息转储者，负责dump 内存泄漏处的 heap 信息到 hprof 文件</strong>。</p>
</li>
<li><p><strong>watchExecutor : 线程控制器，在 onDestroy() 之后并且在主线程空闲时执行内存泄漏检测</strong>。</p>
</li>
<li><p><strong>gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC<br>之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据heapDump信息生成相应的泄漏引用链</strong>。</p>
</li>
<li><p><strong>reachabilityInspectorClasses : 用于要进行可达性检测的类列表。</strong></p>
</li>
</ol>
<p>最后，会使用建造者模式将这些组成部分构建成一个新的RefWatcher并将其返回。</p>
<p>继续看回到AndroidRefWatcherBuilder的注释3处的 LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class,<br>true)这行代码。</p>
<h3 id="LeakCanaryInternals-setEnabledAsync"><a href="#LeakCanaryInternals-setEnabledAsync" class="headerlink" title="LeakCanaryInternals#setEnabledAsync()"></a>LeakCanaryInternals#setEnabledAsync()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnabledAsync</span><span class="hljs-params">(Context context, <span class="hljs-keyword">final</span> Class&lt;?&gt; componentClass,</span><br><span class="hljs-params"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> enabled)</span> {<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Context</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> context.getApplicationContext();<br>  AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>      setEnabledBlocking(appContext, componentClass, enabled);<br>    }<br>  });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在这里直接使用了<strong>AsyncTask内部自带的THREAD_POOL_EXECUTOR线程池</strong>进行阻塞式地显示DisplayLeakActivity。</p>
<p>然后再继续看AndroidRefWatcherBuilder的注释4处的代码。</p>
<h3 id="ActivityRefWatcher-install"><a href="#ActivityRefWatcher-install" class="headerlink" title="ActivityRefWatcher#install()"></a>ActivityRefWatcher#install()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">install</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> RefWatcher refWatcher)</span> {<br>    <span class="hljs-type">Application</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> (Application) context.getApplicationContext();<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">ActivityRefWatcher</span> <span class="hljs-variable">activityRefWatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityRefWatcher</span>(application, refWatcher);<br>    <br>    <span class="hljs-comment">// 2</span><br>    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，在注释1处创建一个自己的activityRefWatcher实例，并在注释2处调用了application的registerActivityLifecycleCallbacks()<br>方法，这样就能够监听activity对应的生命周期事件了。继续看看activityRefWatcher.lifecycleCallbacks里面的操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Application.<span class="hljs-type">ActivityLifecycleCallbacks</span> <span class="hljs-variable">lifecycleCallbacks</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityLifecycleCallbacksAdapter</span>() {<br>      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityDestroyed</span><span class="hljs-params">(Activity activity)</span> {<br>          refWatcher.watch(activity);<br>      }<br>};<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityLifecycleCallbacksAdapter</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Application</span>.ActivityLifecycleCallbacks {<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>很明显，这里<strong>实现并重写了Application的ActivityLifecycleCallbacks的onActivityDestroyed()<br>方法，这样便能在所有Activity执行完onDestroyed()方法之后调用 refWatcher.watch(activity)这行代码进行内存泄漏的检测了</strong>。</p>
<p>再看到注释5处的FragmentRefWatcher.Helper.install(context, refWatcher)这行代码，</p>
<h3 id="FragmentRefWatcher-Helper-install"><a href="#FragmentRefWatcher-Helper-install" class="headerlink" title="FragmentRefWatcher.Helper#install()"></a>FragmentRefWatcher.Helper#install()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentRefWatcher</span> {<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchFragments</span><span class="hljs-params">(Activity activity)</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Helper</span> {<br>    <br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME</span> <span class="hljs-operator">=</span><br>          <span class="hljs-string">"com.squareup.leakcanary.internal.SupportFragmentRefWatcher"</span>;<br>    <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">install</span><span class="hljs-params">(Context context, RefWatcher refWatcher)</span> {<br>        List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) {<br>          fragmentRefWatchers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AndroidOFragmentRefWatcher</span>(refWatcher));<br>        }<br>    <br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">try</span> {<br>          Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);<br>          Constructor&lt;?&gt; constructor =<br>              fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);<br>          <span class="hljs-type">FragmentRefWatcher</span> <span class="hljs-variable">supportFragmentRefWatcher</span>   <span class="hljs-operator">=</span><br>              (FragmentRefWatcher) constructor.newInstance(refWatcher);<br>          fragmentRefWatchers.add(supportFragmentRefWatcher);<br>        } <span class="hljs-keyword">catch</span> (Exception ignored) {<br>        }<br>    <br>        <span class="hljs-keyword">if</span> (fragmentRefWatchers.size() == <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">return</span>;<br>        }<br>    <br>        <span class="hljs-type">Helper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Helper</span>(fragmentRefWatchers);<br>    <br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-type">Application</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> (Application) context.getApplicationContext();<br>        application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);<br>      }<br>      <br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里面的逻辑很简单，首先在注释1处将Android标准的Fragment的RefWatcher类，即AndroidOfFragmentRefWatcher添加到新创建的fragmentRefWatchers中。在注释2处</p>
<ul>
<li></li>
<li><p>使用反射将leakcanary-support-fragment包下面的SupportFragmentRefWatcher添加进来，如果你在app的build.gradle下没有添加下面这行引用的话，则会拿不到此类，即LeakCanary只会检测Activity和标准Fragment这两种情况<br>**。</p>
</li>
</ul>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">debugImplementation</span>   'com.squareup.leakcanary:leakcanary-support-fragment:<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>'<br></code></pre></td></tr></tbody></table></figure>

<p>继续看到注释3处helper.activityLifecycleCallbacks里面的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Application.<span class="hljs-type">ActivityLifecycleCallbacks</span> <span class="hljs-variable">activityLifecycleCallbacks</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityLifecycleCallbacksAdapter</span>() {<br>      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> {<br>        <span class="hljs-keyword">for</span> (FragmentRefWatcher watcher : fragmentRefWatchers) {<br>            watcher.watchFragments(activity);<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，在Activity执行完onActivityCreated()方法之后，会调用指定watcher的watchFragments()<br>方法，注意，这里的watcher可能有两种，但不管是哪一种，都会使用当前传入的activity获取到对应的FragmentManager/SupportFragmentManager对象，调用它的registerFragmentLifecycleCallbacks()<br>方法，在对应的onDestroyView()和onDestoryed()方法执行完后，分别使用refWatcher.watch(view)和refWatcher.watch(fragment)<br>进行内存泄漏的检测，代码如下所示。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onFragmentViewDestroyed</span>(<span class="hljs-params">FragmentManager fm, Fragment fragment</span>) {<br>    <span class="hljs-title class_">View</span> view = fragment.<span class="hljs-title function_">getView</span>();<br>    <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) {<br>        refWatcher.<span class="hljs-title function_">watch</span>(view);<br>    }<br>}<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onFragmentDestroyed</span>(<span class="hljs-params">FragmentManagerfm, Fragment fragment</span>) {<br>    refWatcher.<span class="hljs-title function_">watch</span>(fragment);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意，下面到真正关键的地方了，接下来分析refWatcher.watch()这行代码。</p>
<h3 id="RefWatcher-watch"><a href="#RefWatcher-watch" class="headerlink" title="RefWatcher#watch()"></a>RefWatcher#watch()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void watch(Object watchedReference, String referenceName) {<br>    <span class="hljs-keyword">if</span> (this<span class="hljs-operator"> == </span>DISABLED) {<br>      return;<br>    }<br>    check<span class="hljs-constructor">NotNull(<span class="hljs-params">watchedReference</span>, <span class="hljs-string">"watchedReference"</span>)</span>;<br>    check<span class="hljs-constructor">NotNull(<span class="hljs-params">referenceName</span>, <span class="hljs-string">"referenceName"</span>)</span>;<br>    final long watchStartNanoTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>    <span class="hljs-comment">// 1</span><br>    String key = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    <span class="hljs-comment">// 2</span><br>    retainedKeys.add(key);<br>    <span class="hljs-comment">// 3</span><br>    final KeyedWeakReference reference =<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">KeyedWeakReference(<span class="hljs-params">watchedReference</span>, <span class="hljs-params">key</span>, <span class="hljs-params">referenceName</span>, <span class="hljs-params">queue</span>)</span>;<br><br>    <span class="hljs-comment">// 4</span><br>    ensure<span class="hljs-constructor">GoneAsync(<span class="hljs-params">watchStartNanoTime</span>, <span class="hljs-params">reference</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意到在注释1处<strong>使用随机的UUID保证了每个检测对象对应 key 的唯一性</strong><br>。在注释2处将生成的key添加到类型为CopyOnWriteArraySet的Set集合中。在注释3处新建了一个自定义的弱引用KeyedWeakReference，看看它内部的实现。</p>
<h3 id="KeyedWeakReference"><a href="#KeyedWeakReference" class="headerlink" title="KeyedWeakReference"></a>KeyedWeakReference</h3><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyedWeakReference</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">WeakReference</span>&lt;<span class="hljs-built_in">Object</span>&gt; {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br>    <br>    <span class="hljs-title function_">KeyedWeakReference</span>(<span class="hljs-built_in">Object</span> referent, <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> name,<br>        ReferenceQueue&lt;<span class="hljs-built_in">Object</span>&gt; referenceQueue) {<br>      <span class="hljs-comment">// 1</span><br>      <span class="hljs-title function_">super</span>(<span class="hljs-title function_">checkNotNull</span>(referent, <span class="hljs-string">"referent"</span>), <span class="hljs-title function_">checkNotNull</span>(referenceQueue, <span class="hljs-string">"referenceQueue"</span>));<br>      <span class="hljs-variable">this</span>.<span class="hljs-property">key</span> = <span class="hljs-title function_">checkNotNull</span>(<span class="hljs-built_in">key</span>, <span class="hljs-string">"key"</span>);<br>      <span class="hljs-variable">this</span>.<span class="hljs-property">name</span> = <span class="hljs-title function_">checkNotNull</span>(name, <span class="hljs-string">"name"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，<strong>在KeyedWeakReference内部，使用了key和name标识了一个被检测的WeakReference对象</strong>。在注释1处，<strong>将弱引用和引用队列<br>ReferenceQueue 关联起来，如果弱引用reference持有的对象被GC回收，JVM就会把这个弱引用加入到与之关联的引用队列referenceQueue中。即<br>KeyedWeakReference 持有的 Activity 对象如果被GC回收，该对象就会加入到引用队列 referenceQueue 中</strong>。</p>
<p>接着回到RefWatcher.watch()里注释4处的ensureGoneAsync()方法。</p>
<h3 id="RefWatcher-ensureGoneAsync"><a href="#RefWatcher-ensureGoneAsync" class="headerlink" title="RefWatcher#ensureGoneAsync()"></a>RefWatcher#ensureGoneAsync()</h3><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ensureGoneAsync</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> watchStartNanoTime, <span class="hljs-keyword">final</span> KeyedWeakReference reference)</span> </span>{<br>    <span class="hljs-comment">// 1</span><br>    watchExecutor.execute(<span class="hljs-keyword">new</span> Retryable() {<br>        <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Retryable.<span class="hljs-function">Result <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-comment">// 2</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">ensureGone</span><span class="hljs-params">(reference watchStartNanoTime)</span></span>;<br>        }<br>    });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在ensureGoneAsync()方法中，在注释1处使用 watchExecutor 执行了注释2处的 ensureGone 方法，watchExecutor 是<br>AndroidWatchExecutor 的实例。</p>
<p>下面看看watchExecutor内部的逻辑。</p>
<h3 id="AndroidWatchExecutor"><a href="#AndroidWatchExecutor" class="headerlink" title="AndroidWatchExecutor"></a>AndroidWatchExecutor</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-keyword">class</span> AndroidWatchExecutor implements WatchExecutor {<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span>public <span class="hljs-constructor">AndroidWatchExecutor(<span class="hljs-params">long</span> <span class="hljs-params">initialDelayMillis</span>)</span>     {<br>      mainHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Handler(Looper.<span class="hljs-params">getMainLooper</span>()</span>);<br>      HandlerThread handlerThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HandlerThread(LEAK_CANARY_THREAD_NAME)</span>;<br>      handlerThread.start<span class="hljs-literal">()</span>;<br>      <span class="hljs-comment">// 1</span><br>      backgroundHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Handler(<span class="hljs-params">handlerThread</span>.<span class="hljs-params">getLooper</span>()</span>);<br>      this.initialDelayMillis = initialDelayMillis;<br>      maxBackoffFactor = Long.MAX_VALUE<span class="hljs-operator"> / </span>initialDelayMillis;<br>    }<br>    <br>    @Override public void execute(@NonNull Retryable retryable) {<br>      <span class="hljs-comment">// 2</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>get<span class="hljs-constructor">MainLooper()</span>.get<span class="hljs-constructor">Thread()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>) {<br>        wait<span class="hljs-constructor">ForIdle(<span class="hljs-params">retryable</span>, 0)</span>;<br>      } <span class="hljs-keyword">else</span> {<br>        post<span class="hljs-constructor">WaitForIdle(<span class="hljs-params">retryable</span>, 0)</span>;<br>      }<br>    }<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处<strong>AndroidWatchExecutor的构造方法</strong>中，注意到这里<strong>使用HandlerThread的looper新建了一个backgroundHandler</strong><br>，后面会用到。在注释2处，会判断当前线程是否是主线程，如果是，则直接调用waitForIdle()方法，如果不是，则调用postWaitForIdle()<br>，来看看这个方法。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void post<span class="hljs-constructor">WaitForIdle(<span class="hljs-params">final</span> Retryable <span class="hljs-params">retryable</span>, <span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">failedAttempts</span>)</span> {<br>  mainHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> {<br>    @Override public void run<span class="hljs-literal">()</span> {<br>      wait<span class="hljs-constructor">ForIdle(<span class="hljs-params">retryable</span>, <span class="hljs-params">failedAttempts</span>)</span>;<br>    }<br>  });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>很清晰，这里使用了在构造方法中用主线程looper构造的mainHandler进行post，那么waitForIdle()<br>最终也会在主线程执行。接着看看waitForIdle()的实现。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void wait<span class="hljs-constructor">ForIdle(<span class="hljs-params">final</span> Retryable <span class="hljs-params">retryable</span>,     <span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">failedAttempts</span>)</span> {<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>my<span class="hljs-constructor">Queue()</span>.add<span class="hljs-constructor">IdleHandler(<span class="hljs-params">new</span> MessageQueue.IdleHandler()</span> {<br>    @Override public boolean queue<span class="hljs-constructor">Idle()</span> {<br>      post<span class="hljs-constructor">ToBackgroundWithDelay(<span class="hljs-params">retryable</span>, <span class="hljs-params">failedAttempts</span>)</span>;<br>      return <span class="hljs-literal">false</span>;<br>    }<br>  });<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里**MessageQueue.IdleHandler()回调方法的作用是当 looper 空闲的时候，会回调 queueIdle 方法，利用这个机制我们可以实现第三方库的延迟初始化<br>**，然后执行内部的postToBackgroundWithDelay()方法。接下来看看它的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postToBackgroundWithDelay</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Retryable retryable, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> failedAttempts)</span> {<br>  <span class="hljs-type">long</span> <span class="hljs-variable">exponentialBackoffFactor</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) Math.min(Math.pow(<span class="hljs-number">2</span>, failedAttempts),     maxBackoffFactor);<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">delayMillis</span> <span class="hljs-operator">=</span> initialDelayMillis * exponentialBackoffFactor;<br>  <span class="hljs-comment">// 2</span><br>  backgroundHandler.postDelayed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">// 3</span><br>      Retryable.<span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> retryable.run();<br>      <span class="hljs-comment">// 4</span><br>      <span class="hljs-keyword">if</span> (result == RETRY) {<br>        postWaitForIdle(retryable, failedAttempts +   <span class="hljs-number">1</span>);<br>      }<br>    }<br>  }, delayMillis);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>先看到注释4处，可以明白，postToBackgroundWithDelay()是一个递归方法，如果result<br>一直等于RETRY的话，则会一直执行postWaitForIdle()方法。在回到注释1处，这里initialDelayMillis 的默认值是<br>5s，因此delayMillis就是5s。在注释2处，使用了在构造方法中用HandlerThread的looper新建的backgroundHandler进行异步延时执行retryable的run()<br>方法。这个run()方法里执行的就是RefWatcher的ensureGoneAsync()方法中注释2处的ensureGone()这行代码，继续看它内部的逻辑。</p>
<h3 id="RefWatcher-ensureGone"><a href="#RefWatcher-ensureGone" class="headerlink" title="RefWatcher#ensureGone()"></a>RefWatcher#ensureGone()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Retryable.Result ensure<span class="hljs-constructor">Gone(<span class="hljs-params">final</span> KeyedWeakReference <span class="hljs-params">reference</span>, <span class="hljs-params">final</span> <span class="hljs-params">long</span> <span class="hljs-params">watchStartNanoTime</span>)</span> {<br>    long gcStartNanoTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>    long watchDurationMs = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NANOSECONDS</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Millis(<span class="hljs-params">gcStartNanoTime</span> -     <span class="hljs-params">watchStartNanoTime</span>)</span>;<br><br>    <span class="hljs-comment">// 1</span><br>    remove<span class="hljs-constructor">WeaklyReachableReferences()</span>;<br><br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">if</span> (debuggerControl.is<span class="hljs-constructor">DebuggerAttached()</span>) {<br>      <span class="hljs-comment">// The debugger can create false leaks.</span><br>      return RETRY;<br>    }<br>    <br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">if</span> (gone(reference)) {<br>      return DONE;<br>    }<br>    <br>    <span class="hljs-comment">// 4</span><br>    gcTrigger.run<span class="hljs-constructor">Gc()</span>;<br>    remove<span class="hljs-constructor">WeaklyReachableReferences()</span>;<br>    <br>    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">if</span> (!gone(reference)) {<br>      long startDumpHeap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>      long gcDurationMs = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NANOSECONDS</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Millis(<span class="hljs-params">startDumpHeap</span> - <span class="hljs-params">gcStartNanoTime</span>)</span>;<br><br>      File heapDumpFile = heapDumper.dump<span class="hljs-constructor">Heap()</span>;<br>      <span class="hljs-keyword">if</span> (heapDumpFile<span class="hljs-operator"> == </span>RETRY_LATER) {<br>        <span class="hljs-comment">// Could not dump the heap.</span><br>        return RETRY;<br>      }<br>      <br>      long heapDumpDurationMs = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NANOSECONDS</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Millis(System.<span class="hljs-params">nanoTime</span>()</span> - startDumpHeap);<br><br>      HeapDump heapDump = heapDumpBuilder.heap<span class="hljs-constructor">DumpFile(<span class="hljs-params">heapDumpFile</span>)</span>.reference<span class="hljs-constructor">Key(<span class="hljs-params">reference</span>.<span class="hljs-params">key</span>)</span><br>          .reference<span class="hljs-constructor">Name(<span class="hljs-params">reference</span>.<span class="hljs-params">name</span>)</span><br>          .watch<span class="hljs-constructor">DurationMs(<span class="hljs-params">watchDurationMs</span>)</span><br>          .gc<span class="hljs-constructor">DurationMs(<span class="hljs-params">gcDurationMs</span>)</span><br>          .heap<span class="hljs-constructor">DumpDurationMs(<span class="hljs-params">heapDumpDurationMs</span>)</span><br>          .build<span class="hljs-literal">()</span>;<br><br>      heapdumpListener.analyze(heapDump);<br>    }<br>    return DONE;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，执行了removeWeaklyReachableReferences()这个方法，接下来分析下它的含义。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeWeaklyReachableReferences</span>()</span> {<br>    KeyedWeakReference <span class="hljs-keyword">ref</span>;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">ref</span> = (KeyedWeakReference) queue.poll()) != <span class="hljs-literal">null</span>) {<br>        retainedKeys.<span class="hljs-keyword">remove</span>(<span class="hljs-keyword">ref</span>.key);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里使用了while循环遍历 ReferenceQueue ，并从 retainedKeys中移除对应的Reference。</p>
<p>再看到注释2处，<strong>当Android设备处于debug状态时，会直接返回RETRY进行延时重试检测的操作</strong>。在注释3处，看看gone(reference)<br>这个方法的逻辑。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span>ean gone(KeyedWeakReference <span class="hljs-built_in">ref</span>erence) {<br>    <span class="hljs-keyword">return</span> !retainedKeys.contains(<span class="hljs-built_in">ref</span>erence.key);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里会**判断 retainedKeys 集合中是否还含有 reference，若没有，证明已经被回收了，若含有，可能已经发生内存泄露（或Gc还没有执行回收）<br>**。前面的分析中我们知道了 <strong>reference 被回收的时候，会被加进 referenceQueue<br>里面，然后我们会调用removeWeaklyReachableReferences()遍历 referenceQueue 移除掉 retainedKeys 里面的 refrence</strong>。</p>
<p>接着看到注释4处，执行了gcTrigger的runGc()方法进行垃圾回收，然后使用了removeWeaklyReachableReferences()<br>方法移除已经被回收的引用。这里再深入地分析下runGc()的实现。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">GcTrigger DEFAULT = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GcTrigger()</span> {<br>    @Override public void run<span class="hljs-constructor">Gc()</span> {<br>      <span class="hljs-comment">// Code taken from AOSP FinalizationTest:</span><br>      <span class="hljs-comment">// https://android.googlesource.com/platform/libc  ore/+/master/support/src/test/java/libcore/</span><br>      <span class="hljs-comment">// java/lang/ref/FinalizationTester.java</span><br>      <span class="hljs-comment">// System.gc() does not garbage collect every   time. Runtime.gc() is</span><br>      <span class="hljs-comment">// more likely to perform a gc.</span><br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.gc<span class="hljs-literal">()</span>;<br>      enqueue<span class="hljs-constructor">References()</span>;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>run<span class="hljs-constructor">Finalization()</span>;<br>    }<br><br>    <span class="hljs-keyword">private</span> void enqueue<span class="hljs-constructor">References()</span> {<br>      <span class="hljs-comment">// Hack. We don't have a programmatic way to wait   for the reference queue daemon to move</span><br>      <span class="hljs-comment">// references to the appropriate queues.</span><br>      <span class="hljs-keyword">try</span> {<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>      } catch (InterruptedException e) {<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">AssertionError()</span>;<br>      }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>这里并没有使用System.gc()方法进行回收，因为<strong>system.gc()并不会每次都执行</strong>。而是*<br>*从AOSP中拷贝一段GC回收的代码，从而相比System.gc()更能够保证垃圾回收的工作**。</p>
<p>最后分析下注释5处的代码处理。首先会判断activity是否被回收，如果还没有被回收，则证明发生内存泄露，进行if判断里面的操作。在里面先调用堆信息转储者heapDumper的dumpHeap()<br>生成相应的 hprof<br>文件。这里的heapDumper是一个HeapDumper接口，具体的实现是AndroidHeapDumper。我们分析下AndroidHeapDumper的dumpHeap()<br>方法是如何生成hprof文件的。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> File dumpHeap() {<br>    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();<br><br>    <span class="hljs-keyword">if</span> (heapDumpFile == RETRY_LATER) {<br>        <span class="hljs-keyword">return</span> RETRY_LATER;<br>    }<br><br>    ...<br>    <br>    <span class="hljs-keyword">try</span> {<br>      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());<br>      ...<br>      <br>      <span class="hljs-keyword">return</span> heapDumpFile;<br>    } <span class="hljs-keyword">catch</span> (Exception e) {<br>      ...<br>      <span class="hljs-comment">// Abort heap dump</span><br>      <span class="hljs-keyword">return</span> RETRY_LATER;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里的核心操作就是<strong>调用了Android SDK的API Debug.dumpHprofData() 来生成 hprof 文件</strong>。</p>
<p>如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作。如果不等于的话，则表示生成成功，最后会*<br><em>执行heapdumpListener的analyze()对新创建的HeapDump对象进行泄漏分析</em>*<br>。由前面对AndroidRefWatcherBuilder的listenerServiceClass()的分析可知，heapdumpListener的实现<br>就是ServiceHeapDumpListener，接着看到ServiceHeapDumpListener的analyze方法。</p>
<h3 id="ServiceHeapDumpListener-analyze"><a href="#ServiceHeapDumpListener-analyze" class="headerlink" title="ServiceHeapDumpListener#analyze()"></a>ServiceHeapDumpListener#analyze()</h3><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span> public void <span class="hljs-built_in">analyze</span>(<span class="hljs-variable">@NonNull</span> HeapDump heapDump) {<br>    <span class="hljs-selector-tag">checkNotNull</span>(heapDump, <span class="hljs-string">"heapDump"</span>);<br>    <span class="hljs-selector-tag">HeapAnalyzerService</span><span class="hljs-selector-class">.runAnalysis</span>(context, heapDump, listenerServiceClass);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里**执行了HeapAnalyzerService的runAnalysis()方法，为了避免降低app进程的性能或占用内存，这里将HeapAnalyzerService设置在了一个独立的进程中<br>**。接着继续分析runAnalysis()方法里面的处理。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapAnalyzerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ForegroundService</span></span><br>implements <span class="hljs-type">AnalyzerProgressListener</span> {<br><br>    ...<br><br>    public static void runAnalysis(<span class="hljs-type">Context</span> context, <span class="hljs-type">HeapDump</span> heapDump,<br>    <span class="hljs-type">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">AbstractAnalysisResultService</span>&gt; listenerServiceClass) {<br>        ...<br>        <br>        <span class="hljs-type">ContextCompat</span>.startForegroundService(context, intent);<br>    }<br><br>    ...<br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> void onHandleIntentInForeground(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Intent</span> intent) {<br>        ...<br><br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-type">HeapAnalyzer</span> heapAnalyzer =<br>            <span class="hljs-keyword">new</span> <span class="hljs-type">HeapAnalyzer</span>(heapDump.excludedRefs, <span class="hljs-keyword">this</span>, heapDump.reachabilityInspectorClasses);<br><br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-type">AnalysisResult</span> result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,<br>        heapDump.computeRetainedHeapSize);<br>        <br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-type">AbstractAnalysisResultService</span>.sendResultToListener(<span class="hljs-keyword">this</span>, listenerClassName, heapDump, result);<br>    }<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里的HeapAnalyzerService实质是一个类型为IntentService的ForegroundService，执行startForegroundService()<br>之后，会回调onHandleIntentInForeground()方法。注释1处，首先会新建一个<strong>HeapAnalyzer</strong>对象，顾名思义，它就是*<br>*根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的<strong>。在注释2处，然后会</strong>调用它的checkForLeak()方法去使用haha库解析<br>hprof文件**，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> AnalysisResult <span class="hljs-title function_">checkForLeak</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> File heapDumpFile,</span><br><span class="hljs-params">  <span class="hljs-meta">@NonNull</span> String referenceKey,</span><br><span class="hljs-params">  <span class="hljs-type">boolean</span> computeRetainedSize)</span> {<br>    ...<br>    <br>    <span class="hljs-keyword">try</span> {<br>    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">HprofBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryMappedFileBuffer</span>(heapDumpFile);<br>  <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-type">HprofParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HprofParser</span>(buffer);<br>    listener.onProgressUpdate(PARSING_HEAP_DUMP);<br>    <span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> parser.parse();<br>  <br>    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);<br>    <span class="hljs-comment">// 3</span><br>    deduplicateGcRoots(snapshot);<br>    listener.onProgressUpdate(FINDING_LEAKING_REF);<br>  <br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-type">Instance</span> <span class="hljs-variable">leakingRef</span> <span class="hljs-operator">=</span> findLeakingReference(referenceKey, snapshot);<br><br>    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">if</span> (leakingRef == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> noLeak(since(analysisStartNanoTime));<br>    }<br>  <br>    <span class="hljs-comment">// 6</span><br>    <span class="hljs-keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);<br>    } <span class="hljs-keyword">catch</span> (Throwable e) {<br>    <span class="hljs-keyword">return</span> failure(e, since(analysisStartNanoTime));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，会新建一个<strong>内存映射缓存文件buffer</strong>。在注释2处，会<strong>使用buffer新建一个HprofParser解析器去解析出对应的引用内存快照文件snapshot<br><strong>。在注释3处，</strong>为了减少在Android 6.0版本中重复GCRoots带来的内存压力的影响，使用deduplicateGcRoots()<br>删除了gcRoots中重复的根对象RootObj</strong>。在注释4处，<strong>调用了findLeakingReference()<br>方法将传入的referenceKey和snapshot对象里面所有类实例的字段值对应的keyCandidate进行比较，如果没有相等的，则表示没有发生内存泄漏<br><strong>，直接调用注释5处的代码返回一个没有泄漏的分析结果AnalysisResult对象。</strong>如果找到了相等的，则表示发生了内存泄漏</strong><br>，执行注释6处的代码findLeakTrace()方法返回一个有泄漏分析结果的AnalysisResult对象。</p>
<p>最后，来分析下HeapAnalyzerService中注释3处的AbstractAnalysisResultService.sendResultToListener()<br>方法，很明显，这里AbstractAnalysisResultService的实现类就是我们刚开始分析的用于展示泄漏路径信息的DisplayLeakService对象。在里面直接<br><strong>创建一个由PendingIntent构建的泄漏通知用于供用户点击去展示详细的泄漏界面DisplayLeakActivity</strong>。核心代码如下所示：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> DisplayLeakService extends AbstractAnalysisResultService {<br><br>    @Override<br>    protected final void on<span class="hljs-constructor">HeapAnalyzed(@NonNull AnalyzedHeap <span class="hljs-params">analyzedHeap</span>)</span> {<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">        </span>boolean resultSaved = <span class="hljs-literal">false</span>;<br>        boolean shouldSaveResult = result.leakFound<span class="hljs-operator"> || </span>result.failure != null;<br>        <span class="hljs-keyword">if</span> (shouldSaveResult) {<br>            heapDump = rename<span class="hljs-constructor">Heapdump(<span class="hljs-params">heapDump</span>)</span>;<br>            <span class="hljs-comment">// 1</span><br>            resultSaved = save<span class="hljs-constructor">Result(<span class="hljs-params">heapDump</span>, <span class="hljs-params">result</span>)</span>;<br>        }<br>        <br>        <span class="hljs-keyword">if</span> (!shouldSaveResult) {<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span>show<span class="hljs-constructor">Notification(<span class="hljs-params">null</span>, <span class="hljs-params">contentTitle</span>, <span class="hljs-params">contentText</span>)</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resultSaved) {<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span><span class="hljs-comment">// 2</span><br>            PendingIntent pendingIntent =<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DisplayLeakActivity</span>.</span></span>create<span class="hljs-constructor">PendingIntent(<span class="hljs-params">this</span>, <span class="hljs-params">heapDump</span>.<span class="hljs-params">referenceKey</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span><br><span class="hljs-operator">            </span>show<span class="hljs-constructor">Notification(<span class="hljs-params">pendingIntent</span>, <span class="hljs-params">contentTitle</span>, <span class="hljs-params">contentText</span>)</span>;<br>        } <span class="hljs-keyword">else</span> {<br>             on<span class="hljs-constructor">AnalysisResultFailure(<span class="hljs-params">getString</span>(R.<span class="hljs-params">string</span>.<span class="hljs-params">leak_canary_could_not_save_text</span>)</span>);<br>        }<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>}<br><br>@Override protected final void on<span class="hljs-constructor">AnalysisResultFailure(String <span class="hljs-params">failureMessage</span>)</span> {<br>    super.on<span class="hljs-constructor">AnalysisResultFailure(<span class="hljs-params">failureMessage</span>)</span>;<br>    String failureTitle = get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">leak_canary_result_failure_title</span>)</span>;<br>    show<span class="hljs-constructor">Notification(<span class="hljs-params">null</span>, <span class="hljs-params">failureTitle</span>, <span class="hljs-params">failureMessage</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，只要当分析的堆信息文件保存成功之后，即在注释1处返回的resultSaved为true时，才会执行注释2处的逻辑，即创建一个供用户点击跳转到DisplayLeakActivity的延时通知。</p>
<h2 id="LeakCanary运作流程"><a href="#LeakCanary运作流程" class="headerlink" title="LeakCanary运作流程"></a>LeakCanary运作流程</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0363331db824e7ab342e4bd74702a93~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="image"></p>
<blockquote>
<p>性能优化一直是Android中进阶和深入的方向之一，而内存泄漏一直是性能优化中比较重要的一部分，Android<br>Studio自身提供了MAT等工具去分析内存泄漏，但是分析起来比较耗时耗力，因而才诞生了LeakCanary，它的使用非常简单，但是经过对它的深入分析之后，才发现，<br><strong>简单的API后面往往藏着许多复杂的逻辑处理，尝试去领悟它们，你可能会发现不一样的世界</strong>。</p>
</blockquote>
<h1 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h1><h2 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h2><p>首先看一下ButterKnife的基本使用，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseRootFragment</span>&lt;CollectPresenter&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CollectContract</span>.View {<br><br>    <span class="hljs-meta">@BindView(R.id.normal_view)</span><br>    SmartRefreshLayout mRefreshLayout;<br>    <span class="hljs-meta">@BindView(R.id.collect_recycler_view)</span><br>    RecyclerView mRecyclerView;<br>    <span class="hljs-meta">@BindView(R.id.collect_floating_action_btn)</span><br>    FloatingActionButton mFloatingActionButton;<br>    <br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> {<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(getLayoutId(), container, <span class="hljs-literal">false</span>);<br>        unBinder = ButterKnife.bind(<span class="hljs-built_in">this</span>, view);<br>        initView();<br>        <span class="hljs-keyword">return</span> view;<br>    }<br>    <br>    <span class="hljs-meta">@OnClick({R.id.collect_floating_action_btn})</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> {<br>        <span class="hljs-keyword">switch</span> (view.getId()) {<br>            <span class="hljs-keyword">case</span> R.id.collect_floating_action_btn:<br>                mRecyclerView.smoothScrollToPosition(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroyView</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">super</span>.onDestroyView();<br>        <span class="hljs-keyword">if</span> (unBinder != <span class="hljs-literal">null</span> &amp;&amp; unBinder != Unbinder.EMPTY) {<br>            unBinder.unbind();<br>            unBinder = <span class="hljs-literal">null</span>;<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，我们使用了@BindView()替代了findViewById()方法，然后使用了@OnClick替代了setOnClickListener()<br>方法。ButterKnife的初期版本是通过使用注解+反射这样的运行时解析的方式实现上述功能的，后面，为了改善性能，便使用了*<br>*注解+APT编译时解析技术并从中生成配套模板代码的方式**来实现。</p>
<p>在开始分析之前，可能有同学对APT不是很了解，这里普及一下，APT是Annotation Processing Tool的缩写，即注解处理工具。它的使用步骤通常为如下三个步骤：</p>
<ol>
<li><p>**首先，声明注解的生命周期为CLASS，即@Retention(CLASS)**。</p>
</li>
<li><p><strong>然后，通过继承AbstractProcessor自定义一个注解处理器</strong>。</p>
</li>
<li><p><strong>最后，在编译的时候，编译器会扫描所有带有你要处理的注解的类，最后再调用AbstractProcessor的process方法，对注解进行处理</strong>。</p>
</li>
</ol>
<p>下面，正式来解剖一下ButterKnife的心脏。</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="模板代码解析"><a href="#模板代码解析" class="headerlink" title="模板代码解析"></a>模板代码解析</h3><p>首先，在编写好上述的示例代码之后，调用 gradle build<br>命令，在app/build/generated/source/apt下将可以找到APT为我们生产的配套模板代码CollectFragment_ViewBinding，如下所示：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> CollectFragment_ViewBinding implements Unbinder {<br>    <span class="hljs-keyword">private</span> CollectFragment target;<br>    <br>    <span class="hljs-keyword">private</span> View view2131230812;<br>    <br>    @UiThread<br>    public <span class="hljs-constructor">CollectFragment_ViewBinding(<span class="hljs-params">final</span> CollectFragment <span class="hljs-params">target</span>, View <span class="hljs-params">source</span>)</span> {<br>      this.target = target;<br>    <br>      View view;<br>      <span class="hljs-comment">// 1</span><br>      target.mRefreshLayout = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>find<span class="hljs-constructor">RequiredViewAsType(<span class="hljs-params">source</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">normal_view</span>, <span class="hljs-string">"field 'mRefreshLayout'"</span>, SmartRefreshLayout.<span class="hljs-params">class</span>)</span>;<br>      target.mRecyclerView = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>find<span class="hljs-constructor">RequiredViewAsType(<span class="hljs-params">source</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">collect_recycler_view</span>, <span class="hljs-string">"field 'mRecyclerView'"</span>, RecyclerView.<span class="hljs-params">class</span>)</span>;<br>      view = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>find<span class="hljs-constructor">RequiredView(<span class="hljs-params">source</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">collect_floating_action_btn</span>, <span class="hljs-string">"field 'mFloatingActionButton' and method 'onClick'"</span>)</span>;<br>      target.mFloatingActionButton = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>cast<span class="hljs-constructor">View(<span class="hljs-params">view</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">collect_floating_action_btn</span>, <span class="hljs-string">"field 'mFloatingActionButton'"</span>, FloatingActionButton.<span class="hljs-params">class</span>)</span>;<br>      view2131230812 = view;<br>      <span class="hljs-comment">// 2</span><br>      view.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> DebouncingOnClickListener()</span> {<br>        @Override<br>        public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Click(View <span class="hljs-params">p0</span>)</span> {<br>          target.on<span class="hljs-constructor">Click(<span class="hljs-params">p0</span>)</span>;<br>        }<br>      });<br>    }<br>    <br>    @Override<br>    @CallSuper<br>    public void unbind<span class="hljs-literal">()</span> {<br>      CollectFragment target = this.target;<br>      <span class="hljs-keyword">if</span> (target<span class="hljs-operator"> == </span>null) throw <span class="hljs-keyword">new</span><span class="hljs-constructor">IllegalStateException(<span class="hljs-string">"Bindings already     cleared."</span>)</span>;<br>      this.target = null;<br>    <br>      target.mRefreshLayout = null;<br>      target.mRecyclerView = null;<br>      target.mFloatingActionButton = null;<br>    <br>      view2131230812.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">null</span>)</span>;<br>      view2131230812 = null;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>生成的配套模板CollectFragment_ViewBinding中，在注释1处，使用了ButterKnife内部的工具类Utils的findRequiredViewAsType()<br>方法来寻找控件。在注释2处，使用了view的setOnClickListener()<br>方法来添加了一个去抖动的DebouncingOnClickListener，这样便可以防止重复点击，在重写的doClick()<br>方法内部，直接调用了CollectFragment的onClick方法。最后，再深入看下Utils的findRequiredViewAsType()方法内部的实现。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">findRequiredViewAsType</span>(<span class="hljs-params">View source, <span class="hljs-meta">@IdRes</span> int id, <span class="hljs-built_in">String</span> who,</span><br><span class="hljs-params">  Class&lt;T&gt; cls</span>) {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-title class_">View</span> view = <span class="hljs-title function_">findRequiredView</span>(source, id, who);<br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">castView</span>(view, id, who, cls);<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">View</span> <span class="hljs-title function_">findRequiredView</span>(<span class="hljs-params">View source, <span class="hljs-meta">@IdRes</span> int id, <span class="hljs-built_in">String</span> who</span>) {<br>    <span class="hljs-title class_">View</span> view = source.<span class="hljs-title function_">findViewById</span>(id);<br>    <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> view;<br>    }<br>    <br>    ...<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">castView</span>(<span class="hljs-params">View view, <span class="hljs-meta">@IdRes</span> int id, <span class="hljs-built_in">String</span> who, Class&lt;T&gt; cls</span>) {<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-keyword">return</span> cls.<span class="hljs-title function_">cast</span>(view);<br>    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassCastException</span> e) {<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，<strong>最终也是通过View的findViewById()方法找到相应的控件</strong>，在注释2处，**通过相应Class对象的cast方法强转成对应的控件类型<br>**。</p>
<h3 id="ButterKnife-是怎样实现代码注入的"><a href="#ButterKnife-是怎样实现代码注入的" class="headerlink" title="ButterKnife 是怎样实现代码注入的"></a>ButterKnife 是怎样实现代码注入的</h3><p>接下来，为了使用这套模板代码，我们必须调用ButterKnife的bind()<br>方法实现代码注入，即自动帮我们执行重复繁琐的findViewById和setOnClicklistener操作。下面我们来分析下bind()方法是如何实现注入的。</p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@NonNull</span> <span class="hljs-variable">@UiThread</span><br>public static Unbinder <span class="hljs-built_in">bind</span>(<span class="hljs-variable">@NonNull</span> Object target, <span class="hljs-variable">@NonNull</span> View source) {<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">createBinding</span>(target, source);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在bind()方法中调用了createBinding()，</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@UiThread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Unbinder <span class="hljs-title">bind</span><span class="hljs-params">(@NonNull Object <span class="hljs-keyword">target</span>, @NonNull View source)</span> </span>{<br>    Class&lt;?&gt; targetClass = <span class="hljs-keyword">target</span>.getClass();<br>    <span class="hljs-comment">// 1</span><br>    Constructor&lt;? <span class="hljs-keyword">extends</span> Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);<br><br>    <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">return</span> Unbinder.EMPTY;<br>    }<br><br>    <br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> constructor.<span class="hljs-title">newInstance</span><span class="hljs-params">(<span class="hljs-keyword">target</span>, source)</span></span>;<br>    <span class="hljs-comment">// 3</span><br>    } <span class="hljs-keyword">catch</span> (IllegalAccessException e) {<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，通过 findBindingConstructorForClass() 方法从 Class 中查找<br>constructor，这里constructor即上文生成的CollectFragment_ViewBinding类。然后，在注释2处，<strong>利用反射来新建 constructor 对象</strong><br>。最后，如果新建 constructor 对象失败，则会在注释3后面捕获一系列对应的异常进行自定义异常抛出处理。</p>
<p>下面，来详细分析下 findBindingConstructorForClass() 方法的实现逻辑。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@VisibleForTesting<br>static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;<br><br>@Nullable @CheckResult @UiThread<br><span class="hljs-keyword">private</span> static Constructor&lt;? extends Unbinder&gt; find<span class="hljs-constructor">BindingConstructorForClass(Class&lt;?&gt; <span class="hljs-params">cls</span>)</span> {<br>    <span class="hljs-comment">// 1</span><br>    Constructor&lt;? extends Unbinder&gt; bindingCtor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BINDINGS</span>.</span></span>get(cls);<br>    <span class="hljs-keyword">if</span> (bindingCtor != null<span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BINDINGS</span>.</span></span>contains<span class="hljs-constructor">Key(<span class="hljs-params">cls</span>)</span>) {<br>        return bindingCtor;<br>    }<br>    <br>    <span class="hljs-comment">// 2</span><br>    String clsName = cls.get<span class="hljs-constructor">Name()</span>;<br>    <span class="hljs-keyword">if</span> (clsName.starts<span class="hljs-constructor">With(<span class="hljs-string">"android."</span>)</span><span class="hljs-operator"> || </span>clsName.starts<span class="hljs-constructor">With(<span class="hljs-string">"java."</span>)</span><span class="hljs-operator"></span><br><span class="hljs-operator">    || </span>clsName.starts<span class="hljs-constructor">With(<span class="hljs-string">"androidx."</span>)</span>) {<br>        return null;<br>    }<br>    <br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 3</span><br>        Class&lt;?&gt; bindingClass = cls.get<span class="hljs-constructor">ClassLoader()</span>.load<span class="hljs-constructor">Class(<span class="hljs-params">clsName</span> + <span class="hljs-string">"_ViewBinding"</span>)</span>;<br>        bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.get<span class="hljs-constructor">Constructor(<span class="hljs-params">cls</span>, View.<span class="hljs-params">class</span>)</span>;<br>    } catch (ClassNotFoundException e) {<br>        <span class="hljs-comment">// 4</span><br>        bindingCtor = find<span class="hljs-constructor">BindingConstructorForClass(<span class="hljs-params">cls</span>.<span class="hljs-params">getSuperclass</span>()</span>);<br>    } catch (NoSuchMethodException e) {<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-string">"Unable to find binding constructor for "</span> + <span class="hljs-params">clsName</span>, <span class="hljs-params">e</span>)</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 5</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BINDINGS</span>.</span></span>put(cls, bindingCtor);<br>    return bindingCtor;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里，我把多余的log代码删除并把代码格式优化了一下，可以看到，findBindingConstructorForClass() 这个方法中的逻辑瞬间清晰不少，这里<br><strong>建议以后大家自己在分析源码的时候可以进行这样的优化重整</strong>，会带来不少好处。</p>
<p>重新看到 findBindingConstructorForClass()<br>方法，在注释1处，我们首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，这里的BINDINGS是一个LinkedHashMap对象，它保存了上述两者的映射关系。在注释2处，如果是<br>android，androidx，java 原生的文件，不进行处理。在注释3处，先*<br>*通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象**，再通过自身的getConstructor()<br>方法获得相应的构造对象。如果在步骤3中加载不出对应的模板类对象，则会在注释4处使用类似递归的方法重新执行findBindingConstructorForClass()<br>方法。最后，如果找到了bindingCtor模板构造对象，则将它保存在BINDINGS这个LinkedHashMap对象中。</p>
<p><strong>这里总结一下findBindingConstructorForClass()方法的处理：</strong></p>
<ol>
<li><p>**首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，获取不到，则继续执行下面的操作<br>**。</p>
</li>
<li><p><strong>如果不是android，androidx，java 原生的文件，再进行后面的处理</strong>。</p>
</li>
<li><ul>
<li>*通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()<br>方法获得相应的构造对象，如果获取不到，会抛出异常，在异常的处理中，我们会从当前 class<br>文件的父类中再去查找。如果找到了，最后会将bindingCtor对象缓存进在BINDINGS对象中**。</li>
</ul>
</li>
</ol>
<h3 id="ButterKnife是如何在编译时生成代码的？"><a href="#ButterKnife是如何在编译时生成代码的？" class="headerlink" title="ButterKnife是如何在编译时生成代码的？"></a>ButterKnife是如何在编译时生成代码的？</h3><p>在编译的时候，ButterKnife会通过自定义的注解处理器ButterKnifeProcessor的process方法，对编译器扫描到的要处理的类中的注解进行处理，然后，<br><strong>通过javapoet这个库来动态生成绑定事件或者控件的模板代码</strong>，最后在运行的时候，直接调用bind方法完成绑定即可。</p>
<p>首先，先来分析下ButterKnifeProcessor的重写的入口方法init()。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">ProcessingEnvironment env</span>) {<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">init</span>(env);<br><br>    <span class="hljs-title class_">String</span> sdk = env.<span class="hljs-title function_">getOptions</span>().<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">OPTION_SDK_INT</span>);<br>    <span class="hljs-keyword">if</span> (sdk != <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sdk</span> = <span class="hljs-title class_">Integer</span>.<span class="hljs-built_in">parseInt</span>(sdk);<br>        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NumberFormatException</span> e) {<br>           ...<br>        }<br>    }<br><br>    typeUtils = env.<span class="hljs-title function_">getTypeUtils</span>();<br>    filer = env.<span class="hljs-title function_">getFiler</span>();<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，**ProcessingEnviroment对象提供了两大工具类 typeUtils和filer。typeUtils的作用是用来处理TypeMirror，而Filer则是用来创建生成辅助文件<br>**。</p>
<p>接着，再来看看被重写的getSupportedAnnotationTypes()方法，这个方法的作用主要是用于指定ButterknifeProcessor注册了哪些注解的。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotation : <span class="hljs-title function_">getSupportedAnnotations</span>()) {<br>    types.<span class="hljs-title function_">add</span>(annotation.<span class="hljs-title function_">getCanonicalName</span>());<br>    }<br>    <span class="hljs-keyword">return</span> types;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里面首先创建了一个LinkedHashSet对象，然后将getSupportedAnnotations()方法返回的支持注解集合进行遍历一一并添加到types中返回。</p>
<p>接着看下getSupportedAnnotations()方法，</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() {<br>    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;();<br><br>    annotations.<span class="hljs-built_in">add</span>(BindAnim.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindArray.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindBitmap.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindBool.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindColor.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindDimen.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindDrawable.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindFloat.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindFont.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindInt.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindString.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindView.class);<br>    annotations.<span class="hljs-built_in">add</span>(BindViews.class);<br>    annotations.addAll(LISTENERS);<br><br>    return annotations;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里注册了一系列的Bindxxx注解类和监听列表LISTENERS，接着看一下LISTENERS中包含的监听方法：</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;<span class="hljs-keyword">Class</span>&lt;? <span class="hljs-keyword">extends</span> Annotation&gt;&gt; LISTENERS = Arrays.<span class="hljs-keyword">asList</span>(<br>    OnCheckedChanged.<span class="hljs-keyword">class</span>, <br>    OnClick.<span class="hljs-keyword">class</span>, <br>    OnEditorAction.<span class="hljs-keyword">class</span>, <br>    OnFocusChange.<span class="hljs-keyword">class</span>, <br>    OnItemClick.<span class="hljs-keyword">class</span>, <br>    OnItemLongClick.<span class="hljs-keyword">class</span>, <br>    OnItemSelected.<span class="hljs-keyword">class</span>, <br>    OnLongClick.<span class="hljs-keyword">class</span>, <br>    OnPageChange.<span class="hljs-keyword">class</span>, <br>    OnTextChanged.<span class="hljs-keyword">class</span>, <br>    OnTouch.<span class="hljs-keyword">class</span> <br>);<br></code></pre></td></tr></tbody></table></figure>

<p>最后，来分析下整个ButterKnifeProcessor中最关键的方法process()。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; elements, RoundEnvironment env</span>) {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">TypeElement</span>, <span class="hljs-title class_">BindingSet</span>&gt; bindingMap = <span class="hljs-title function_">findAndParseTargets</span>(env);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">TypeElement</span>, <span class="hljs-title class_">BindingSet</span>&gt; entry : bindingMap.<span class="hljs-title function_">entrySet</span>()) {<br>        <span class="hljs-title class_">TypeElement</span> typeElement = entry.<span class="hljs-title function_">getKey</span>();<br>        <span class="hljs-title class_">BindingSet</span> binding = entry.<span class="hljs-title function_">getValue</span>();<br><br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-title class_">JavaFile</span> javaFile = binding.<span class="hljs-title function_">brewJava</span>(sdk, debuggable);<br>        <span class="hljs-keyword">try</span> {<br>            javaFile.<span class="hljs-title function_">writeTo</span>(filer);<br>        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) {<br>           ...<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处通过<strong>findAndParseTargets()方法</strong>，知名见义，它应该就是<strong>找到并解析注解目标的关键方法</strong>了，继续看看它内部的处理：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class="hljs-constructor">AndParseTargets(RoundEnvironment <span class="hljs-params">env</span>)</span> {<br>    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    Set&lt;TypeElement&gt; erasedTargetNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 1、一系列处理每一个@Bindxxx元素的for循环代码块</span><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span><span class="hljs-comment">// Process each @BindView element.</span><br>    <span class="hljs-keyword">for</span> (Element element : env.get<span class="hljs-constructor">ElementsAnnotatedWith(BindView.<span class="hljs-params">class</span>)</span>) {<br>        <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 2</span><br>        parse<span class="hljs-constructor">BindView(<span class="hljs-params">element</span>, <span class="hljs-params">builderMap</span>, <span class="hljs-params">erasedTargetNames</span>)</span>;<br>        } catch (Exception e) {<br>            log<span class="hljs-constructor">ParsingError(<span class="hljs-params">element</span>, BindView.<span class="hljs-params">class</span>, <span class="hljs-params">e</span>)</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">// Process each @BindViews element.</span><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span><span class="hljs-comment">// Process each annotation that corresponds to a listener.</span><br>    <span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) {<br>        find<span class="hljs-constructor">AndParseListener(<span class="hljs-params">env</span>, <span class="hljs-params">listener</span>, <span class="hljs-params">builderMap</span>, <span class="hljs-params">erasedTargetNames</span>)</span>;<br>    }<br><br>    <span class="hljs-comment">// 2</span><br>    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =<br>        <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entry<span class="hljs-constructor">Set()</span>);<br>    Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">while</span> (!entries.is<span class="hljs-constructor">Empty()</span>) {<br>        Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.remove<span class="hljs-constructor">First()</span>;<br><br>        TypeElement <span class="hljs-keyword">type</span> = entry.get<span class="hljs-constructor">Key()</span>;<br>        BindingSet.Builder builder = entry.get<span class="hljs-constructor">Value()</span>;<br><br>        TypeElement parentType = find<span class="hljs-constructor">ParentType(<span class="hljs-params">type</span>, <span class="hljs-params">erasedTargetNames</span>)</span>;<br>        <span class="hljs-keyword">if</span> (parentType<span class="hljs-operator"> == </span>null) {<br>            bindingMap.put(<span class="hljs-keyword">type</span>, builder.build<span class="hljs-literal">()</span>);<br>        } <span class="hljs-keyword">else</span> {<br>            BindingSet parentBinding = bindingMap.get(parentType);<br>            <span class="hljs-keyword">if</span> (parentBinding != null) {<br>                builder.set<span class="hljs-constructor">Parent(<span class="hljs-params">parentBinding</span>)</span>;<br>                bindingMap.put(<span class="hljs-keyword">type</span>, builder.build<span class="hljs-literal">()</span>);<br>            } <span class="hljs-keyword">else</span> {<br>            entries.add<span class="hljs-constructor">Last(<span class="hljs-params">entry</span>)</span>;<br>            }<br>        }<br>    }<br>    return bindingMap;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>findAndParseTargets()方法的代码非常多，这里尽可能做了精简。首先，在注释1处，*<br><em>扫描并处理所有具有@Bindxxx注解和符合LISTENERS监听方法集合的代码，然后在每一个@Bindxxx对应的for循环代码中的parseBindxxx()<br>或findAndParseListener()方法中将解析出的信息放入builderMap这个LinkedHashMap对象中</em>*<br>，其中builderMap是一个key为TypeElement，value为BindingSet.Builder的映射集合，这个 BindSet 是指**的一个类型请求的所有绑定的集合<br>**<br>。在注释3处，首先使用上面的builderMap对象去构建了一个entries对象，它是一个双向队列，能实现两端存取的操作。接着，又新建了一个key为TypeElement，value为BindingSet的LinkedHashMap对象，最后使用了一个while循环从entries的第一个元素开始，这里会判断当前元素类型是否有父类，如果没有，直接构建builder放入bindingMap中，如果有，则将parentBinding添加到BindingSet.Builder这个建造者对象中，然后再创建BindingSet再添加到bindingMap中。</p>
<p>接着，分析下注释2处parseBindView是如何对每一个@BindView注解的元素进行处理。</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart">private <span class="hljs-keyword">void</span> parseBindView(<span class="hljs-built_in">Element</span> element, <span class="hljs-built_in">Map</span>&lt;TypeElement, BindingSet.Builder&gt; builderMap,<br>  <span class="hljs-built_in">Set</span>&lt;TypeElement&gt; erasedTargetNames) {<br>    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();<br><br>    <span class="hljs-comment">// 1、首先验证生成的常见代码限制</span><br>    ...<br><br>    <span class="hljs-comment">// 2、验证目标类型是否继承自View。</span><br>    ...<br>    <br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-built_in">int</span> id = element.getAnnotation(BindView.<span class="hljs-keyword">class</span>).value();<br>    BindingSet.Builder builder = builderMap.<span class="hljs-keyword">get</span>(enclosingElement);<br>    Id resourceId = elementToId(element, BindView.<span class="hljs-keyword">class</span>, id);<br>    <span class="hljs-keyword">if</span> (builder != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-built_in">String</span> existingBindingName = builder.findExistingBindingName(resourceId);<br>        <span class="hljs-keyword">if</span> (existingBindingName != <span class="hljs-keyword">null</span>) {<br>            ...<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// 4</span><br>        builder = getOrCreateBindingBuilder(builderMap, enclosingElement);<br>    }<br><br>    <span class="hljs-built_in">String</span> name = simpleName.toString();<br>    TypeName type = TypeName.<span class="hljs-keyword">get</span>(elementType);<br>    boolean <span class="hljs-keyword">required</span> = isFieldRequired(element);<br><br>    <span class="hljs-comment">// 5</span><br>    builder.addField(resourceId, <span class="hljs-keyword">new</span>     FieldViewBinding(name, type, <span class="hljs-keyword">required</span>));<br><br>    <span class="hljs-comment">// Add the type-erased version to the valid binding targets set.</span><br>    erasedTargetNames.add(enclosingElement);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1、2处均是一些验证处理操作，如果不符合则会return。然后，看到注释3处，这里获取了BindView要绑定的View的id，然后先从builderMap中获取BindingSet.Builder对象，如果存在，直接return。如果不存在，则会在注释4处的<br>getOrCreateBindingBuilder()方法生成一个。看一下getOrCreateBindingBuilder()方法:</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">private <span class="hljs-keyword">BindingSet.Builder </span>getOrCreateBindingBuilder(<br>  Map&lt;TypeElement, <span class="hljs-keyword">BindingSet.Builder&gt; </span><span class="hljs-keyword">builderMap, </span>TypeElement enclosingElement) {<br>    <span class="hljs-keyword">BindingSet.Builder </span><span class="hljs-keyword">builder </span>= <span class="hljs-keyword">builderMap.get(enclosingElement);</span><br><span class="hljs-keyword"></span>    if (<span class="hljs-keyword">builder </span>== null) {<br>        <span class="hljs-keyword">builder </span>= <span class="hljs-keyword">BindingSet.newBuilder(enclosingElement);</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">builderMap.put(enclosingElement, </span><span class="hljs-keyword">builder);</span><br><span class="hljs-keyword"></span>    }<br>    return <span class="hljs-keyword">builder;</span><br><span class="hljs-keyword"></span>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里会再次从buildMap中获取BindingSet.Builder对象，如果没有则直接调用BindingSet的newBuilder()<br>方法新建一个BindingSet.Builder对象并保存在builderMap中，然后，再将新建的builder对象返回。</p>
<p>回到parseBindView()方法的注释5处，这里根据view的信息生成一个FieldViewBinding，最后添加到上边生成的builder对象中。</p>
<p>最后，再回到我们的process()方法中，现在*<br>*所有的绑定的集合数据都放在了bindingMap对象中，这里使用for循环取出每一个BindingSet对象，调用它的brewJava()方法**，看看它内部的处理：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">JavaFile brew<span class="hljs-constructor">Java(<span class="hljs-params">int</span> <span class="hljs-params">sdk</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">debuggable</span>)</span> {<br>    TypeSpec bindingConfiguration = create<span class="hljs-constructor">Type(<span class="hljs-params">sdk</span>, <span class="hljs-params">debuggable</span>)</span>;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JavaFile</span>.</span></span>builder(bindingClassName.package<span class="hljs-constructor">Name()</span>, bindingConfiguration)<br>    .add<span class="hljs-constructor">FileComment(<span class="hljs-string">"Generated code from Butter Knife. Do not modify!"</span>)</span><br>    .build<span class="hljs-literal">()</span>;<br>}<br><br><span class="hljs-keyword">private</span> TypeSpec create<span class="hljs-constructor">Type(<span class="hljs-params">int</span> <span class="hljs-params">sdk</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">debuggable</span>)</span> {<br>    TypeSpec.Builder result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TypeSpec</span>.</span></span><span class="hljs-keyword">class</span><span class="hljs-constructor">Builder(<span class="hljs-params">bindingClassName</span>.<span class="hljs-params">simpleName</span>()</span>)<br>    .add<span class="hljs-constructor">Modifiers(PUBLIC)</span>;<br>    <span class="hljs-keyword">if</span> (isFinal) {<br>        result.add<span class="hljs-constructor">Modifiers(FINAL)</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (parentBinding != null) {<br>        result.superclass(parentBinding.bindingClassName);<br>    } <span class="hljs-keyword">else</span> {<br>        result.add<span class="hljs-constructor">Superinterface(UNBINDER)</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (has<span class="hljs-constructor">TargetField()</span>) {<br>        result.add<span class="hljs-constructor">Field(<span class="hljs-params">targetTypeName</span>, <span class="hljs-string">"target"</span>, PRIVATE)</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (isView) {<br>        result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForView</span>()</span>);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isActivity) {<br>        result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForActivity</span>()</span>);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDialog) {<br>        result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForDialog</span>()</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (!constructor<span class="hljs-constructor">NeedsView()</span>) {<br>        <span class="hljs-comment">// Add a delegating constructor with a target type + view signature for reflective use.</span><br>        result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingViewDelegateConstructor</span>()</span>);<br>    }<br>    result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructor</span>(<span class="hljs-params">sdk</span>, <span class="hljs-params">debuggable</span>)</span>);<br><br>    <span class="hljs-keyword">if</span> (has<span class="hljs-constructor">ViewBindings()</span><span class="hljs-operator"> || </span>parentBinding<span class="hljs-operator"> == </span>null) {<br>        result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingUnbindMethod</span>(<span class="hljs-params">result</span>)</span>);<br>    }<br><br>    return result.build<span class="hljs-literal">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在createType()方法里面使用了java中的javapoet技术生成了一个bindingConfiguration对象，很显然，它里面*<br>*保存了所有的绑定配置信息。然后，通过javapoet的builder构造器将上面得到的bindingConfiguration对象构建生成一个JavaFile对象，最终，通过javaFile.writeTo(<br>filer)生成了java源文件**。</p>
<blockquote>
<p>从上面的源码分析来看，ButterKnife的执行流程总体可以分为如下两步：</p>
</blockquote>
<ol>
<li><p><strong>在编译的时候扫描注解，并通过自定义的ButterKnifeProcessor做相应的处理解析得到bindingMap对象，最后，调用 javapoet<br>库生成java模板代码</strong>。</p>
</li>
<li><p><strong>当我们调用 ButterKnife的bind()方法的时候，它会根据类的全限定类型，找到相应的模板代码，并在其中完成 findViewById 和<br>setOnClick ，setOnLongClick 等操作</strong>。</p>
</li>
</ol>
<h1 id="Dagger-2"><a href="#Dagger-2" class="headerlink" title="Dagger 2"></a>Dagger 2</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p>告诉dagger这个字段或类需要依赖注入，然后在需要依赖的地方使用这个注解，dagger会自动生成这个构造器的实例。</p>
<h4 id="获取所需依赖："><a href="#获取所需依赖：" class="headerlink" title="获取所需依赖："></a>获取所需依赖：</h4><ul>
<li>全局变量注入</li>
<li>方法注入</li>
</ul>
<h4 id="提供所需实例："><a href="#提供所需实例：" class="headerlink" title="提供所需实例："></a>提供所需实例：</h4><ul>
<li>构造器注入（如果有多个构造函数，只能注解一个，否则编译报错）</li>
</ul>
<h3 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h3><p>类注解，表示此类的方法是提供依赖的，它告诉dagger在哪可以找到依赖。用于不能用@Inject提供依赖的地方，如第三方库提供的类，基本数据类型等不能修改源码的情况。</p>
<p>注意：<strong>Dagger2会优先在@Module注解的类上查找依赖，没有的情况才会去查询类的@Inject构造方法</strong></p>
<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h3><p>声明这是一个单例，<strong>在确保只有一个Component并且不再重新build()之后，对象只会被初始化一次，之后的每次都会被注入相同的对象</strong><br>，它就是一个内置的作用域。</p>
<p>对于@Singleton，大家可能会产生一些误解，这里详细阐述下：</p>
<ul>
<li>Singleton容易给人造成一种误解就是用Singleton注解后在整个Java代码中都是单例，但**实际上他和Scope一样，只是在同一个Component是单例<br>**。也就是说，如果重新调用了component的build（）方法，即使使用了Singleton注解了，但仍然获取的是不同的对象。</li>
<li>它表明了**@Singleton注解只是声明了这是一个单例，为的只是提高代码可读性，其实真正控制对象生命周期的还是Component**<br>。同理，自定义的@ActivityScope 、@ApplicationScope也仅仅是一个声明的作用，<strong>真正控制对象生命周期的还是Component</strong>。</li>
</ul>
<h3 id="Providers"><a href="#Providers" class="headerlink" title="@Providers"></a>@Providers</h3><p>只在@Module中使用，用于提供构造好的实例。一般与@Singleton搭配，用单例方法的形式对外提供依赖,是一种替代@Inject注解构造方法的方式。</p>
<p>注意：</p>
<ul>
<li>使用了@Providers的方法应使用provide作为前缀，使用了@Module的类应使用Module作为后缀。</li>
<li>**如果@Providers方法或@Inject构造方法有参数，要保证它能够被dagger获取到，比如通过其它@Providers方法或者@Inject注解构造器的形式得到<br>**。</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>**@Component作为Dagger2的容器总管，它拥有着@Inject与@Module的所有依赖。同时，它也是一枚注射器，用于获取所需依赖和提供所需依赖的桥梁<br>**。这里的桥梁即指@Inject和@Module（或@Inject构造方法）之间的桥梁。定义时需要列出响应的Module组成，此外，还可以使用dependencies继承父Component。</p>
<h4 id="Component与Module的区别："><a href="#Component与Module的区别：" class="headerlink" title="Component与Module的区别："></a>Component与Module的区别：</h4><p>Component既是注射器也是一个容器总管，而module则是作为容器总管Component的子容器，实质是一个用于提供依赖的模块。</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>注解作用域，通过自定义注解<strong>限定对象作用范围，增强可读性</strong>。</p>
<p>@Scope有两种常用的使用场景：</p>
<ul>
<li><strong>模拟Singleton代表全局单例，与Component生命周期关联</strong>。</li>
<li><strong>模拟局部单例，如登录到退出登录期间</strong>。</li>
</ul>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>限定符，利用它<strong>定义注解类以用于区分类的不同实例</strong>。例如：2个方法返回不同的Person对象，比如说小明和小华，为了区分，使用@Qualifier定义的注解类。</p>
<h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>使用它表示ChildComponent依赖于FatherComponent，如下所示：</p>
<figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">@Component</span>(modules = ChildModule.<span class="hljs-keyword">class</span>, dependencies = FatherComponent.<span class="hljs-keyword">class</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> ChildComponent {<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="SubComponent"><a href="#SubComponent" class="headerlink" title="@SubComponent"></a>@SubComponent</h3><p>表示是一个子@Component，它能<strong>将应用的不同部分封装起来，用来替代@Dependencies</strong>。</p>
<h2 id="简单示例-2"><a href="#简单示例-2" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="首先，创建一个BaseActivityComponent的Subcomponent："><a href="#首先，创建一个BaseActivityComponent的Subcomponent：" class="headerlink" title="首先，创建一个BaseActivityComponent的Subcomponent："></a>首先，创建一个BaseActivityComponent的Subcomponent：</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Subcomponent</span>(modules = {<span class="hljs-type">AndroidInjectionModule</span>.<span class="hljs-keyword">class</span>})<br>public interface <span class="hljs-type">BaseActivityComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">AndroidInjector</span>&lt;<span class="hljs-type">BaseActivity</span>&gt; {<br><br>    <span class="hljs-meta">@Subcomponent</span>.<span class="hljs-type">Builder</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AndroidInjector</span>.<span class="hljs-title">Builder&lt;BaseActivity&gt;</span></span>{<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里必须要注解成@Subcomponent.Builder表示是顶级@Subcomponent的内部类。AndroidInjector.Builder的泛型指定了BaseActivity，即表示每一个继承于BaseActivity的Activity都继承于同一个子组件（BaseActivityComponent）。</p>
<h3 id="然后，创建一个将会导入Subcomponent的公有Module。"><a href="#然后，创建一个将会导入Subcomponent的公有Module。" class="headerlink" title="然后，创建一个将会导入Subcomponent的公有Module。"></a>然后，创建一个将会导入Subcomponent的公有Module。</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1</span><br><span class="hljs-meta">@Module(subcomponents = {BaseActivityComponent.class})</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAllActivityModule</span> {<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = MainActivityModule.class)</span><br>    <span class="hljs-keyword">abstract</span> MainActivity <span class="hljs-title function_">contributesMainActivityInjector</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = SplashActivityModule.class)</span><br>    <span class="hljs-keyword">abstract</span> SplashActivity <span class="hljs-title function_">contributesSplashActivityInjector</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">// 一系列的对应Activity的contributesxxxActivityInjector</span><br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处用subcomponents来表示开放全部依赖给AbstractAllActivityModule，使用Subcomponent的重要原因是它将应用的不同部分封装起来了。<br><strong>@AppComponent负责维护共享的数据和对象，而不同处则由各自的@Subcomponent维护</strong>。</p>
<h3 id="接着，配置项目的Application。"><a href="#接着，配置项目的Application。" class="headerlink" title="接着，配置项目的Application。"></a>接着，配置项目的Application。</h3><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WanAndroidApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> <span class="hljs-title">implements</span> <span class="hljs-title">HasActivityInjector</span> </span>{<br><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-type">DispatchingAndroidInjector</span>&lt;<span class="hljs-type">Activity</span>&gt; mAndroidInjector;<br><br>    <span class="hljs-keyword">private</span> static volatile <span class="hljs-type">AppComponent</span> appComponent;<br>    <br>    <span class="hljs-meta">@Override</span><br>    public void onCreate() {<br>        <span class="hljs-keyword">super</span>.onCreate();<br>        <br>        ...<br>        <span class="hljs-comment">// 1</span><br>        appComponent = <span class="hljs-type">DaggerAppComponent</span>.builder()<br>            .build();<br>        <span class="hljs-comment">// 2</span><br>        appComponent.inject(<span class="hljs-keyword">this</span>);<br>        <br>        ...<br>        <br>    }<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">AndroidInjector</span>&lt;<span class="hljs-type">Activity</span>&gt; activityInjector() {<br>        <span class="hljs-keyword">return</span> mAndroidInjector;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，使用AppModule模块和httpModule模块构建出AppComponent的实现类DaggerAppComponent。这里看一下AppComponent的配置代码：</p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Singleton</span><br><span class="hljs-variable">@Component</span>(modules = {AndroidInjectionModule.class,<br>        AndroidSupportInjectionModule.class,<br>        AbstractAllActivityModule.class,<br>        AbstractAllFragmentModule.class,<br>        AbstractAllDialogFragmentModule.class}<br>    )<br>public interface AppComponent {<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注入WanAndroidApp实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param wanAndroidApp WanAndroidApp</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">inject</span>(WanAndroidApp wanAndroidApp);<br>    <br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，AppComponent依赖了AndroidInjectionModule模块，它包含了一些基础配置的绑定设置，如activityInjectorFactories、fragmentInjectorFactories等等，而AndroidSupportInjectionModule模块显然就是多了一个supportFragmentInjectorFactories的绑定设置，activityInjectorFactories的内容如所示：</p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Beta</span><br><span class="hljs-variable">@Module</span><br>public abstract class AndroidInjectionModule {<br>    <span class="hljs-variable">@Multibinds</span><br>    abstract Map&lt;Class&lt;? extends Activity&gt;, AndroidInjector.Factory&lt;? extends Activity&gt;&gt;<br>        <span class="hljs-built_in">activityInjectorFactories</span>();<br>    <br>    <span class="hljs-variable">@Multibinds</span><br>    abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;<br>        <span class="hljs-built_in">fragmentInjectorFactories</span>();<br>    <br>    ...<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接着，下面依赖的AbstractAllActivityModule、<br>AbstractAllFragmentModule、AbstractAllDialogFragmentModule则是为项目的所有Activity、Fragment、DialogFragment提供的统一基类抽象Module，这里看下AbstractAllActivityModule的配置：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module(subcomponents = {BaseActivityComponent.class})</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAllActivityModule</span> {<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = MainActivityModule.class)</span><br>    <span class="hljs-keyword">abstract</span> MainActivity <span class="hljs-title function_">contributesMainActivityInjector</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = SplashActivityModule.class)</span><br>    <span class="hljs-keyword">abstract</span> SplashActivity <span class="hljs-title function_">contributesSplashActivityInjector</span><span class="hljs-params">()</span>;<br>    <br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，项目下的所有xxxActiviity都有对应的contributesxxxActivityInjector()<br>方法提供实例注入。并且，注意到AbstractAllActivityModule这个模块依赖的<br>subcomponents为BaseActivityComponent，前面说过了，每一个继承于BaseActivity的Activity都继承于BaseActivityComponent这一个subcomponents。同理，AbstractAllFragmentModule与AbstractAllDialogFragmentModule也是类似的实现模式，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1</span><br><span class="hljs-meta">@Module(c = BaseFragmentComponent.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAllFragmentModule</span> {<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = CollectFragmentModule.class)</span><br>    <span class="hljs-keyword">abstract</span> CollectFragment <span class="hljs-title function_">contributesCollectFragmentInject</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = KnowledgeFragmentModule.class)</span><br>    <span class="hljs-keyword">abstract</span> KnowledgeHierarchyFragment <span class="hljs-title function_">contributesKnowledgeHierarchyFragmentInject</span><span class="hljs-params">()</span>;<br>    <br>    ...<br>    <br>}<br><br><br><span class="hljs-comment">// 2</span><br><span class="hljs-meta">@Module(subcomponents = BaseDialogFragmentComponent.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAllDialogFragmentModule</span> {<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = SearchDialogFragmentModule.class)</span><br>    <span class="hljs-keyword">abstract</span> SearchDialogFragment <span class="hljs-title function_">contributesSearchDialogFragmentInject</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = UsageDialogFragmentModule.class)</span><br>    <span class="hljs-keyword">abstract</span> UsageDialogFragment <span class="hljs-title function_">contributesUsageDialogFragmentInject</span><span class="hljs-params">()</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注意到注释1和注释2处的代码，AbstractAllFragmentModule和AbstractAllDialogFragmentModule的subcomponents为BaseFragmentComponent、BaseDialogFragmentComponent，很显然，同AbstractAllActivityModule的子组件BaseActivityComponent一样，它们都是作为一个通用的子组件。</p>
<p>然后，回到我们配置项目下的Application下面的注释2处的代码，在这里使用了第一步Dagger为我们构建的DaggerAppComponent对象将当期的Application实例注入了进去，交给了Dagger这个依赖大管家去管理。最终，</p>
<ul>
<li></li>
</ul>
<p><em>Dagger2内部创建的mAndroidInjector对象会在注释3处的地方进行实例赋值。在注释4处，实现HasActivityInjector接口，重写activityInjector()<br>方法，将我们上面得到的mAndroidInjector对象返回</em>*<br>。这里的mAndroidInjector是一个类型为DispatchingAndroidInjector的对象，可以这样理解它：它能够执行Android框架下的核心成员如Activity、Fragment的成员注入，在我们项目下的Application中将DispatchingAndroidInjector的泛型指定为Activity就说明它承担起了所有Activity成员依赖的注入。那么，如何指定某一个Activity能被纳入DispatchingAndroidInjector这个所有Activity的依赖总管的口袋中呢？接着看使用步骤4。</p>
<h3 id="最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"><a href="#最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。" class="headerlink" title="最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"></a>最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。</h3><p>很简单，只需在目标Activity的onCreate()方法前的super.onCreate(savedInstanceState)前配置一行代码 AndroidInjection.inject(<br>this)，如下所示：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPresenter&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSimpleActivity</span> <span class="hljs-title">implements</span></span><br>    <span class="hljs-type">AbstractView</span> {<br><br>    ...<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">T</span> mPresenter;<br>    <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">Bundle</span> savedInstanceState) {<br>        <span class="hljs-type">AndroidInjection</span>.inject(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    }<br><br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里使用了@Inject表明了需要注入mPresenter实例，然后，我们需要在具体的Presenter类的构造方法上使用@Inject提供基于当前构造方法的mPresenter实例，如下所示：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPresenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasePresenter&lt;MainContract</span>.<span class="hljs-title">View&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">MainContract</span>.<span class="hljs-title">Presenter</span> </span>{<br><br>    ...<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-type">MainPresenter</span>(<span class="hljs-type">DataManager</span> dataManager) {<br>        <span class="hljs-keyword">super</span>(dataManager);<br>        <span class="hljs-keyword">this</span>.mDataManager = dataManager;<br>    }<br><br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从上面的使用流程中，有三个关键的核心实现是我们需要了解的，如下所示：</p>
<ul>
<li>1、appComponent = DaggerAppComponent.builder().build()这句代码如何构建出DaggerAPPComponent的？</li>
<li>2、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</li>
<li>3、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</li>
</ul>
<p>下面我们逐个地来探索其中的奥妙~</p>
<h2 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？"><a href="#DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？" class="headerlink" title="DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？"></a>DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？</h3><p>首先，看到DaggerAppComponent的builder()方法：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Builder <span class="hljs-title">builder</span>()</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>里面直接返回了一个新建的Builder静态内部类对象，看看它的构造方法中做了什么：</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> {<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>{}<br>    <br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>看来，Builder的默认构造方法什么也没有做，那么，真正的实现肯定在Builder对象的build()方法中，接着看到build()方法。</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> {<br><br>    ...<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AppComponent <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">DaggerAppComponent</span>(<span class="hljs-keyword">this</span>);<br>    }<br><br>    ...<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在Builder的build()方法中直接返回了新建的DaggerAppComponent对象。下面，看看DaggerAppComponent的构造方法:</p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">private <span class="hljs-built_in">DaggerAppComponent</span>(Builder builder) {<br>    <span class="hljs-built_in">initialize</span>(builder);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在DaggerAppComponent的构造方法中调用了initialize方法，顾名思义，它就是真正初始化项目全局依赖配置的地方了，下面，来看看它内部的实现：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">final Builder builder</span>) {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mainActivitySubcomponentBuilderProvider</span> =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Provider</span>&lt;<br>            <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector.<span class="hljs-property">MainActivitySubcomponent</span><br>                .<span class="hljs-property">Builder</span>&gt;() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector.<span class="hljs-property">MainActivitySubcomponent</span><br>                .<span class="hljs-property">Builder</span><br>            <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {<br>                <span class="hljs-comment">// 2</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainActivitySubcomponentBuilder</span>();<br>            }<br>        };<br><br>    <span class="hljs-comment">// 一系列xxxActivitySubcomponentBuilderProvider的创建赋值代码块</span><br>    ...<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，新建了一个mainActivit的子组件构造器实例提供者Provider。在注释2处，使用匿名内部类的方式重写了该Provider的get()<br>方法，返回一个新创建好的MainActivitySubcomponentBuilder对象。很显然，它就是负责创建管理MAinActivity中所需依赖的Subcomponent建造者。接下来重点来分析下MainActivitySubcomponentBuilder这个类的作用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivitySubcomponentBuilder</span><br>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAllActivityModule_ContributesMainActivityInjector</span>.MainActivitySubcomponent<br>      .Builder {<br>    <span class="hljs-keyword">private</span> MainActivity seedInstance;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent<br>        <span class="hljs-title function_">build</span><span class="hljs-params">()</span> {<br>      <span class="hljs-keyword">if</span> (seedInstance == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MainActivity.class.getCanonicalName() + <span class="hljs-string">" must be set"</span>);<br>      }<br>      <span class="hljs-comment">// 2</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainActivitySubcomponentImpl</span>(<span class="hljs-built_in">this</span>);<br>    }<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seedInstance</span><span class="hljs-params">(MainActivity arg0)</span> {<br>      <span class="hljs-comment">// 3</span><br>      <span class="hljs-built_in">this</span>.seedInstance = Preconditions.checkNotNull(arg0);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，MainActivitySubcomponentBuilder继承了AbstractAllActivityModule_ContributesMainActivityInjector内部的子组件MainActivitySubcomponent的内部的子组件建造者类Builder，如下所示：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Subcomponent</span>(modules = <span class="hljs-type">MainActivityModule</span>.<span class="hljs-keyword">class</span>)<br>public interface <span class="hljs-type">MainActivitySubcomponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">AndroidInjector</span>&lt;<span class="hljs-type">MainActivity</span>&gt; {<br>    <span class="hljs-meta">@Subcomponent</span>.<span class="hljs-type">Builder</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span></span><br>    <span class="hljs-type">AndroidInjector</span>.<span class="hljs-type">Builder</span>&lt;<span class="hljs-type">MainActivity</span>&gt; {}<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这个子组件建造者Builder又继承了AndroidInjector的抽象内部类Builder，那么，这个AndroidInjector到底是什么呢？</p>
<p>顾名思义，<strong>AndroidInjector</strong>是一个Android注射器，它**为每一个具体的子类型，即核心Android类型Activity和Fragment执行成员注入。<br>**</p>
<p>接下来分析下AndroidInjector的内部实现，源码如下所示：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AndroidInjector</span>&lt;<span class="hljs-title">T</span>&gt; {<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inject</span>(<span class="hljs-params">T instance</span>)</span>;<br>    <br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-title">T</span>&gt; {<br>        <span class="hljs-function">AndroidInjector&lt;T&gt; <span class="hljs-title">create</span>(<span class="hljs-params">T instance</span>)</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">AndroidInjector.Factory</span>&lt;<span class="hljs-title">T</span>&gt; {<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> final AndroidInjector&lt;T&gt; <span class="hljs-title">create</span>(<span class="hljs-params">T instance</span>)</span> {<br>            seedInstance(instance);<br>            <span class="hljs-keyword">return</span> build();<br>        }<br>    <br>        @BindsInstance<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seedInstance</span>(<span class="hljs-params">T instance</span>)</span>;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AndroidInjector&lt;T&gt; <span class="hljs-title">build</span>()</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，使用了抽象工厂模式，用来创建一个具体的Activity或Fragment类型的AndroidInjector实例。注释2处，Builder实现了AndroidInjector.Factory，它是一种Subcomponent.Builder的通用实现模式，在重写的create()<br>方法中，进行了实例保存seedInstance()和具体Android核心类型的构建。</p>
<p>接着，我们回到MainActivitySubcomponentBuilder类，可以看到，它实现了AndroidInjector.Builder的seedInstance()和build()<br>方法。在注释3处首先播种了MainActivity的实例，然后<br>在注释2处新建了一个MainActivitySubcomponentImpl对象返回。我们看看MainActivitySubcomponentImpl这个类是如何将mPresenter依赖注入的，相关源码如下：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivitySubcomponentImpl</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector<br>    .<span class="hljs-property">MainActivitySubcomponent</span> {<br>      <br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MainPresenter</span> <span class="hljs-title function_">getMainPresenter</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">MainPresenter</span>_Factory.<span class="hljs-title function_">newMainPresenter</span>(<br>        <span class="hljs-title class_">DaggerAppComponent</span>.<span class="hljs-property">this</span>.<span class="hljs-property">provideDataManagerProvider</span>.<span class="hljs-title function_">get</span>());<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">MainActivity arg0</span>) {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-title function_">injectMainActivity</span>(arg0);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-title function_">injectMainActivity</span>(<span class="hljs-params">MainActivity instance</span>) {<br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-title class_">BaseActivity</span>_MembersInjector<br>        .<span class="hljs-title function_">injectMPresenter</span>(instance, <span class="hljs-title function_">getMainPresenter</span>());<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，MainActivitySubcomponentImpl实现了AndroidInjector接口的inject()方法，<strong>在injectMainActivity()<br>首先调用getMainPresenter()方法从MainPresenter_Factory工厂类中新建了一个MainPresenter对象</strong><br>。我们看看MainPresenter的newMainPresenter()方法：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MainPresenter <span class="hljs-keyword">new</span><span class="hljs-type">MainPresenter</span>(DataManager dataManager) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MainPresenter</span>(dataManager);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里直接新建了一个MainPresenter。然后我们回到MainActivitySubcomponentImpl类的注释3处，继续调用了*<br><em>BaseActivity_MembersInjector的injectMPresenter()方法</em>*<br>，顾名思义，可以猜到，它是BaseActivity的成员注射器，继续看看injectMPresenter()内部：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPresenter</span>&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">injectMPresenter</span>(<span class="hljs-params"></span><br><span class="hljs-params">  BaseActivity&lt;T&gt; instance, T mPresenter</span>) {<br>    instance.<span class="hljs-property">mPresenter</span> = mPresenter;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里直接将需要的mPresenter实例赋值给了BaseActivity的mPresenter，当然，这里其实是指的BaseActivity的子类MainActivity，其它的xxxActivity的依赖管理机制都是如此。</p>
<h3 id="appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？"><a href="#appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？" class="headerlink" title="appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？"></a>appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</h3><p>我们继续查看appComponent的inject()方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">WanAndroidApp wanAndroidApp</span>) {<br>  <span class="hljs-title function_">injectWanAndroidApp</span>(wanAndroidApp);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在inject()方法里调用了injectWanAndroidApp()，继续查看injectWanAndroidApp()方法：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">private</span> <span class="hljs-type">WanAndroidApp</span> injectWanAndroidApp(<span class="hljs-type">WanAndroidApp</span> <span class="hljs-keyword">instance</span>) {<br>    <span class="hljs-type">WanAndroidApp_MembersInjector</span>.injectMAndroidInjector(<br><span class="hljs-class">        <span class="hljs-keyword">instance</span>,</span><br><span class="hljs-class">        getDispatchingAndroidInjectorOfActivity());</span><br><span class="hljs-class">    return <span class="hljs-keyword">instance</span>;</span><br><span class="hljs-class">}</span><br></code></pre></td></tr></tbody></table></figure>

<p>首先，执行getDispatchingAndroidInjectorOfActivity()<br>方法得到了一个Activity类型的DispatchingAndroidInjector对象，继续查看getDispatchingAndroidInjectorOfActivity()方法：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> DispatchingAndroidInjector&lt;Activity&gt; <span class="hljs-title">getDispatchingAndroidInjectorOfActivity</span>()</span> {<br>    <span class="hljs-keyword">return</span> DispatchingAndroidInjector_Factory.newDispatchingAndroidInjector(<br>    getMapOfClassOfAndProviderOfFactoryOf());<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在getDispatchingAndroidInjectorOfActivity()方法里面，首先调用了getMapOfClassOfAndProviderOfFactoryOf()方法，我们看到这个方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Map&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;<br>  get<span class="hljs-constructor">MapOfClassOfAndProviderOfFactoryOf()</span> {<br>    return MapBuilder<br>        .&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;<br>        <span class="hljs-keyword">new</span><span class="hljs-constructor">MapBuilder(8)</span><br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) mainActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SplashActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) splashActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArticleDetailActivity</span>.</span></span><span class="hljs-keyword">class</span>,<br>            (Provider) articleDetailActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KnowledgeHierarchyDetailActivity</span>.</span></span><span class="hljs-keyword">class</span>,<br>            (Provider) knowledgeHierarchyDetailActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoginActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) loginActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RegisterActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) registerActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AboutUsActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) aboutUsActivitySubcomponentBuilderProvider)<br>        .put(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SearchListActivity</span>.</span></span><span class="hljs-keyword">class</span>, (Provider) searchListActivitySubcomponentBuilderProvider)<br>        .build<span class="hljs-literal">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里新建了一个建造者模式实现的MapBuilder，并且同时制定了固定容量为8，将项目下使用了AndroidInjection.inject(<br>mActivity)方法的8个Activity对应的xxxActivitySubcomponentBuilderProvider保存起来。</p>
<p>我们再回到getDispatchingAndroidInjectorOfActivity()<br>方法，这里将上面得到的Map容器传入了DispatchingAndroidInjector_Factory的newDispatchingAndroidInjector()<br>方法中，这里应该就是新建DispatchingAndroidInjector的地方了。我们点进去看看：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">DispatchingAndroidInjector</span>&lt;<span class="hljs-type">T</span>&gt; newDispatchingAndroidInjector(<br>  <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Class</span>&lt;? extends <span class="hljs-type">T</span>&gt;, <span class="hljs-type">Provider</span>&lt;<span class="hljs-type">AndroidInjector</span>.<span class="hljs-type">Factory</span>&lt;? extends <span class="hljs-type">T</span>&gt;&gt;&gt; injectorFactories) {<br>    <span class="hljs-keyword">return</span> new <span class="hljs-type">DispatchingAndroidInjector</span>&lt;<span class="hljs-type">T</span>&gt;(injectorFactories);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在这里，果然新建了一个DispatchingAndroidInjector对象。继续看看DispatchingAndroidInjector的构造方法：</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Inject</span><br>DispatchingAndroidInjector(<br>  <span class="hljs-built_in">Map</span>&lt;Class&lt;? <span class="hljs-keyword">extends</span> T&gt;, Provider&lt;AndroidInjector.Factory&lt;? <span class="hljs-keyword">extends</span> T&gt;&gt;&gt; injectorFactories) {<br>    <span class="hljs-keyword">this</span>.injectorFactories = injectorFactories;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这里仅仅是将传进来的Map容器保存起来了。</p>
<p>我们再回到WanAndroidApp_MembersInjector的injectMAndroidInjector()<br>方法，将上面得到的DispatchingAndroidInjector实例传入，继续查看injectMAndroidInjector()这个方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">injectMAndroidInjector</span>(<span class="hljs-params"></span><br><span class="hljs-params">  WanAndroidApp instance, DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector</span>) {<br>    instance.<span class="hljs-property">mAndroidInjector</span> = mAndroidInjector;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，最后在WanAndroidApp_MembersInjector的injectMAndroidInjector()<br>方法中，直接将新建好的DispatchingAndroidInjector实例赋值给了WanAndroidApp的mAndroidInjector。</p>
<h3 id="在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"><a href="#在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？" class="headerlink" title="在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"></a>在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</h3><p>首先，我们看到AndroidInjection.inject(this)这个方法：</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">inject</span>(Activity activity) {<br>    checkNotNull(activity, <span class="hljs-string">"activity"</span>);<br>    <br>    <span class="hljs-comment">// 1</span><br>    Application application = activity.getApplication();<br>    <span class="hljs-keyword">if</span> (!(application <span class="hljs-keyword">instanceof</span> HasActivityInjector)) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>        String.format(<br>            <span class="hljs-string">"%s does not implement %s"</span>,<br>            application.getClass().getCanonicalName(), <br>            HasActivityInjector.<span class="hljs-keyword">class</span>.getCanonicalName()));<br>    }<br><br>    <span class="hljs-comment">// 2</span><br>    AndroidInjector&lt;Activity&gt; activityInjector =<br>        ((HasActivityInjector) application).activityInjector();<br>        <br>    checkNotNull(activityInjector, <span class="hljs-string">"%s.activityInjector() returned null"</span>, application.getClass());<br><br>    <span class="hljs-comment">// 3</span><br>    activityInjector.<span class="hljs-keyword">inject</span>(activity);<br></code></pre></td></tr></tbody></table></figure>

<p>}</p>
<p>在注释1处，会先判断当前的application是否实现了HasActivityInjector这个接口，如果没有，则抛出RuntimeException。如果有，会继续在注释2处调用application的activityInjector()<br>方法得到DispatchingAndroidInjector实例。最后，在注释3处，会将当前的activity实例传入activityInjector的inject()<br>方法中。我们继续查看inject()方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">T instance</span>) {<br>    <span class="hljs-built_in">boolean</span> wasInjected = <span class="hljs-title function_">maybeInject</span>(instance);<br>    <span class="hljs-keyword">if</span> (!wasInjected) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-title function_">errorMessageSuggestions</span>(instance));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><strong>DispatchingAndroidInjector的inject()方法，它的作用就是给传入的instance实例执行成员注入</strong><br>。具体在这个案例中，其实就是负责将创建好的Presenter实例赋值给BaseActivity对象 的mPresenter全局变量。在inject()<br>方法中，又调用了maybeInject()方法，我们继续查看它：</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@CanIgnoreReturnValue</span><br>public boolean maybeInject(T instance) {<br>    <span class="hljs-comment">// 1</span><br>    Provider&lt;AndroidInjector.Factory&lt;? <span class="hljs-keyword">extends</span> T&gt;&gt; factoryProvider =<br>    injectorFactories.<span class="hljs-keyword">get</span>(instance.getClass());<br>    <span class="hljs-keyword">if</span> (factoryProvider == <span class="hljs-keyword">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }<br><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<br>    <span class="hljs-comment">// 2</span><br>    AndroidInjector.Factory&lt;T&gt; <span class="hljs-keyword">factory</span> = (AndroidInjector.Factory&lt;T&gt;) factoryProvider.<span class="hljs-keyword">get</span>();<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 3</span><br>        AndroidInjector&lt;T&gt; injector =<br>            checkNotNull(<br>                <span class="hljs-keyword">factory</span>.create(instance), <span class="hljs-string">"%s.create(I) should not return null."</span>, <span class="hljs-keyword">factory</span>.getClass());<br>        <span class="hljs-comment">// 4</span><br>        injector.inject(instance);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    } <span class="hljs-keyword">catch</span> (ClassCastException e) {<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，我们从injectorFactories（前面得到的Map容器）中根据当前Activity实例拿到了factoryProvider对象，这里我们具体一点，看到MainActivity对应的factoryProvider，也就是我们研究的第一个问题中的mainActivitySubcomponentBuilderProvider：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">final Builder builder</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mainActivitySubcomponentBuilderProvider</span> =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Provider</span>&lt;<br>            <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector.<span class="hljs-property">MainActivitySubcomponent</span><br>            .<span class="hljs-property">Builder</span>&gt;() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector.<span class="hljs-property">MainActivitySubcomponent</span><br>                .<span class="hljs-property">Builder</span><br>            <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainActivitySubcomponentBuilder</span>();<br>            }<br>        };<br><br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在maybeInject()方法的注释2处，调用了mainActivitySubcomponentBuilderProvider的get()<br>方法得到了一个新建的MainActivitySubcomponentBuilder对象。在注释3处执行了它的create方法，create()<br>方法的具体实现在AndroidInjector的内部类Builder中：</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">AndroidInjector</span>.<span class="hljs-title">Factory</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AndroidInjector&lt;T&gt; create(T instance) {<br>        seedInstance(instance);<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>看到这里，我相信看过第一个问题的同学已经明白后面是怎么回事了。在create()<br>方法中，我们首先MainActivitySubcomponentBuilder的seedInstance()将MainActivity实例注入，然后再调用它的build()<br>方法新建了一个MainActivitySubcomponentImpl实例返回。</p>
<p>最后，在注释4处，执行了MainActivitySubcomponentImpl的inject()方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivitySubcomponentImpl</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractAllActivityModule</span>_ContributesMainActivityInjector<br>    .<span class="hljs-property">MainActivitySubcomponent</span> {<br>      <br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MainPresenter</span> <span class="hljs-title function_">getMainPresenter</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">MainPresenter</span>_Factory.<span class="hljs-title function_">newMainPresenter</span>(<br>        <span class="hljs-title class_">DaggerAppComponent</span>.<span class="hljs-property">this</span>.<span class="hljs-property">provideDataManagerProvider</span>.<span class="hljs-title function_">get</span>());<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">MainActivity arg0</span>) {<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-title function_">injectMainActivity</span>(arg0);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-title function_">injectMainActivity</span>(<span class="hljs-params">MainActivity instance</span>) {<br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-title class_">BaseActivity</span>_MembersInjector<br>        .<span class="hljs-title function_">injectMPresenter</span>(instance, <span class="hljs-title function_">getMainPresenter</span>());<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>这里的逻辑已经在问题一的最后部分详细讲解了，最后，会在注释3处调用BaseActivity_MembersInjector的injectMPresenter()方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPresenter</span>&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">injectMPresenter</span>(<span class="hljs-params"></span><br><span class="hljs-params">  BaseActivity&lt;T&gt; instance, T mPresenter</span>) {<br>    instance.<span class="hljs-property">mPresenter</span> = mPresenter;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这样，就将mPresenter对象赋值给了当前Activity对象的mPresenter全局变量中了。至此，Dagger.Android的核心源码分析就结束了。</p>
<blockquote>
<p>相比于ButterKnife，Dagger是一个<strong>锋利的全局依赖注入管理框架</strong>，它主要用来<strong>管理对象的依赖关系和生命周期</strong></p>
</blockquote>
<p>，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity或Fragment，有些是单例，而且它们的生命周期不一致，所以创建所需对象时需要处理的各个对象的依赖关系和生命周期时的任务会很繁重。因此，使用Dagger会大大减轻这方面的工作量。虽然它的学习成本比较高，而且需要写一定的模板类，但是，<br><strong>对于越大的项目来说，Dagger越值得被需要</strong>。</p>
<h1 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h1><h2 id="简单示例-3"><a href="#简单示例-3" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="首先，定义要传递的事件实体"><a href="#首先，定义要传递的事件实体" class="headerlink" title="首先，定义要传递的事件实体"></a>首先，定义要传递的事件实体</h3><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CollectEvent</span> { ... }<br></code></pre></td></tr></tbody></table></figure>

<h3 id="准备订阅者：声明并注解你的订阅方法"><a href="#准备订阅者：声明并注解你的订阅方法" class="headerlink" title="准备订阅者：声明并注解你的订阅方法"></a>准备订阅者：声明并注解你的订阅方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessageEvent</span><span class="hljs-params">(CollectEvent event)</span> {<br>    LogHelper.d(<span class="hljs-string">"OK"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"><a href="#在2中，也就是订阅中所在的类中，注册和解注册你的订阅者" class="headerlink" title="在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"></a>在2中，也就是订阅中所在的类中，注册和解注册你的订阅者</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onStart</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onStart</span>();<br>    <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">getDefault</span>().<span class="hljs-title function_">register</span>(<span class="hljs-variable language_">this</span>);<br>}<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onStop</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onStop</span>();<br>    <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">getDefault</span>().<span class="hljs-title function_">unregister</span>(<span class="hljs-variable language_">this</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">CollectEvent()</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>在正式讲解之前需要对一些基础性的概念进行详细的讲解。众所周知，EventBus没出现之前，那时候的开发者一般是使用Android四大组件中的广播进行组件间的消息传递，那么我们<br><strong>为什么要使用事件总线机制来替代广播呢</strong>？</p>
<p>主要是因为：</p>
<ul>
<li>广播：耗时、容易被捕获（不安全）。</li>
<li>事件总线：更节省资源、更高效，能将信息传递给原生以外的各种对象。</li>
</ul>
<p>那么，话又说回来了，<strong>事件总线又是什么呢？</strong></p>
<p>如下图所示，事件总线机制通过记录对象、使用观察者模式来通知对象各种事件。（当然，你也可以发送基本数据类型如 int，String<br>等作为一个事件）</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/6/170ada0907b50b75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="image"></p>
<p>对于<strong>事件总线EventBus</strong>而言，它的<strong>优缺点</strong>又是如何？这里简单总结下：</p>
<ul>
<li>优点：开销小，代码更优雅、简洁，解耦发送者和接收者，可动态设置事件处理线程和优先级。</li>
<li>缺点：每个事件必须自定义一个事件类，增加了维护成本。</li>
</ul>
<p>EventBus是基于观察者模式扩展而来的，我们先了解一下观察者模式是什么？</p>
<p>观察者模式又可称为<strong>发布 - 订阅模式</strong>，它定义了对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p>
<p>观察者模式有以下角色：</p>
<ul>
<li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li>
<li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li>
<li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li>
<li>具体观察者：实现抽象观察者的更新接口。</li>
</ul>
<p>这里给出一个简单的示例来让大家更深一步理解观察者模式的思想：</p>
<p>1、首先，创建抽象观察者</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">observer</span> {<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> update(String message);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>2、接着，创建具体观察者</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeXinUser</span> <span class="hljs-keyword">implements</span> observer {<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">WeXinUser</span>(<span class="hljs-title class_">String</span> name) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    }<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>3、然后，创建抽象被观察者</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> interface observable {<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">addWeXinUser</span><span class="hljs-params">(WeXinUser weXinUser)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">removeWeXinUser</span><span class="hljs-params">(WeXinUser weXinUser)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(<span class="hljs-type">String</span> message)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>4、最后，创建具体被观察者</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscription</span> <span class="hljs-keyword">implements</span> observable {<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">WeXinUser</span>&gt; mUserList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addWeXinUser</span>(<span class="hljs-params">WeXinUser weXinUser</span>) {<br>        mUserList.<span class="hljs-title function_">add</span>(weXinUser);<br>    }<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">removeWeXinUser</span>(<span class="hljs-params">WeXinUser weXinUser</span>) {<br>        mUserList.<span class="hljs-title function_">remove</span>(weXinUser);<br>    }<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">notify</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-title class_">WeXinUser</span> weXinUser : mUserList) {<br>            weXinUser.<span class="hljs-title function_">update</span>(message);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在具体使用时，我们便可以这样使用，如下所示：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Subscription subscription = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Subscription()</span>;<br><br>WeXinUser hongYang = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WeXinUser(<span class="hljs-string">"HongYang"</span>)</span>;<br>WeXinUser rengYuGang = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WeXinUser(<span class="hljs-string">"RengYuGang"</span>)</span>;<br>WeXinUser liuWangShu = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WeXinUser(<span class="hljs-string">"LiuWangShu"</span>)</span>;<br><br>subscription.add<span class="hljs-constructor">WeiXinUser(<span class="hljs-params">hongYang</span>)</span>;<br>subscription.add<span class="hljs-constructor">WeiXinUser(<span class="hljs-params">rengYuGang</span>)</span>;<br>subscription.add<span class="hljs-constructor">WeiXinUser(<span class="hljs-params">liuWangShu</span>)</span>;<br>subscription.notify(<span class="hljs-string">"New article coming"</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>在这里，hongYang、rengYuGang、liuWangShu等大神都订阅了我的微信公众号，每当我的公众号发表文章时（subscription.notify())<br>，他们就会接收到最新的文章信息（weXinUser.update()）。（ps：当然，这一切都是YY~）</p>
<p>当然，EventBus的观察者模式和一般的观察者模式不同，它使用了**扩展的观察者模式对事件进行订阅和分发，其实这里的扩展就是指的使用了EventBus来作为中介者，抽离了许多职责<br>**，如下是它的官方原理图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/6/170ada0907c082ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="image"></p>
<p>在得知了EventBus的原理之后，我们注意到，每次我们在register之后，都必须进行一次unregister，这是为什么呢？</p>
<p><strong>因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存</strong>。</p>
<p>有些同学可能之前使用的是EventBus2.x的版本，那么它又与EventBus3.x的版本有哪些区别呢？</p>
<ol>
<li><p>EventBus2.x使用的是**运行时注解，它采用了反射的方式对整个注册的类的所有方法进行扫描来完成注册，因而会对性能有一定影响<br>**。</p>
</li>
<li><p>EventBus3.x使用的是*</p>
<ul>
<li>编译时注解，Java文件会编译成.class文件，再对class文件进行打包等一系列处理。在编译成.class文件时，EventBus会使用EventBusAnnotationProcessor注解处理器读取@Subscribe()<br>注解并解析、处理其中的信息，然后生成Java类来保存所有订阅者的订阅信息。这样就创建出了对文件或类的索引关系，并将其编入到apk中<br>**。</li>
</ul>
</li>
<li><p>从EventBus3.0开始<strong>使用了对象池缓存减少了创建对象的开销</strong>。</p>
</li>
</ol>
<p>除了EventBus，其实现在比较流行的事件总线还有RxBus，那么，它与EventBus相比又如何呢？</p>
<ol>
<li><p><strong>RxJava的Observable有onError、onComplete等状态回调</strong>。</p>
</li>
<li><p><strong>Rxjava使用组合而非嵌套的方式，避免了回调地狱</strong>。</p>
</li>
<li><p><strong>Rxjava的线程调度设计的更加优秀，更简单易用</strong>。</p>
</li>
<li><p><strong>Rxjava可使用多种操作符来进行链式调用来实现复杂的逻辑</strong>。</p>
</li>
<li><p><strong>Rxjava的信息效率高于EventBus2.x，低于EventBus3.x</strong>。</p>
</li>
</ol>
<p>在了解了EventBus和RxBus的区别之后，那么，对待新项目的事件总线选型时，我们该如何考量？</p>
<p>很简单，<strong>如果项目中使用了RxJava，则使用RxBus，否则使用EventBus3.x</strong>。</p>
<h2 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h2><p>接下来将按以下顺序来进行EventBus的源码分析：</p>
<ol>
<li><p>订阅者：EventBus.getDefault().register(this)；</p>
</li>
<li><p>发布者：EventBus.getDefault().post(new CollectEvent())；</p>
</li>
<li><p>订阅者：EventBus.getDefault().unregister(this)。</p>
</li>
</ol>
<h3 id="EventBus-getDefault-register-this"><a href="#EventBus-getDefault-register-this" class="headerlink" title="EventBus.getDefault().register(this)"></a>EventBus.getDefault().register(this)</h3><p>首先，从获取EventBus实例的方法getDefault()开始分析：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EventBus <span class="hljs-title">getDefault</span>()</span> {<br>    <span class="hljs-keyword">if</span> (defaultInstance == <span class="hljs-literal">null</span>) {<br>        synchronized (EventBus.<span class="hljs-keyword">class</span>) {<br>            <span class="hljs-keyword">if</span> (defaultInstance == <span class="hljs-literal">null</span>) {<br>                defaultInstance = <span class="hljs-keyword">new</span> EventBus();<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> defaultInstance;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在getDefault()中使用了双重校验并加锁的单例模式来创建EventBus实例。</p>
<p>接着，看到EventBus的默认构造方法中做了什么:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventBusBuilder</span> <span class="hljs-variable">DEFAULT_BUILDER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBusBuilder</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">EventBus</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">this</span>(DEFAULT_BUILDER);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在EventBus的默认构造方法中又调用了它的另一个有参构造方法，将一个类型为EventBusBuilder的DEFAULT_BUILDER对象传递进去了。这里的EventBusBuilder很明显是一个EventBus的建造器，以便于EventBus能够添加自定义的参数和安装一个自定义的默认EventBus实例。</p>
<p>再看一下EventBusBuilder的构造方法：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">EventBusBuilder</span> {<br><br>    ...<br><br>    EventBusBuilder() {<br>    }<br>    <br>    ...<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>

<p>EventBusBuilder的构造方法中什么也没有做，那继续查看EventBus的这个有参构造方法：</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-keyword">Class</span>&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Object, List&lt;<span class="hljs-keyword">Class</span>&lt;?&gt;&gt;&gt; typesBySubscriber;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-keyword">Class</span>&lt;?&gt;, Object&gt; stickyEvents;<br><br>EventBus(EventBusBuilder builder) {<br>    ...<br>    <br>    <span class="hljs-comment">// 1</span><br>    subscriptionsByEventType = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 2</span><br>    typesBySubscriber = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 3</span><br>    stickyEvents = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 4</span><br>    mainThreadSupport = builder.getMainThreadSupport();<br>    mainThreadPoster = mainThreadSupport != <span class="hljs-keyword">null</span> ? mainThreadSupport.createPoster(<span class="hljs-keyword">this</span>) : <span class="hljs-keyword">null</span>;<br>    backgroundPoster = <span class="hljs-keyword">new</span> BackgroundPoster(<span class="hljs-keyword">this</span>);<br>    asyncPoster = <span class="hljs-keyword">new</span> AsyncPoster(<span class="hljs-keyword">this</span>);<br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 5</span><br>    subscriberMethodFinder = <span class="hljs-keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,<br>            builder.strictMethodVerification, builder.ignoreGeneratedIndex);<br>   <br>    <span class="hljs-comment">// 从builder取中一些列订阅相关信息进行赋值</span><br>    ...<br>   <br>    <span class="hljs-comment">// 6</span><br>    executorService = builder.executorService;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，创建了一个subscriptionsByEventType对象，可以看到它是一个类型为HashMap的subscriptionsByEventType对象，并且其key为<br>Event 类型，value为 Subscription链表。这里的Subscription是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object<br>的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity对象）；另一个是 类型为SubscriberMethod 的<br>subscriberMethod，它就是被@Subscribe注解的那个订阅方法，里面保存了一个重要的字段eventType，它是 Class&lt;?&gt; 类型的，代表了<br>Event 的类型。在注释2处，新建了一个类型为 Map 的typesBySubscriber对象，它的key为subscriber对象，value为subscriber对象中所有的<br>Event<br>类型链表，日常使用中仅用于判断某个对象是否注册过。在注释3处新建了一个类型为ConcurrentHashMap的stickyEvents对象，它是专用于粘性事件处理的一个字段，key为事件的Class对象，value为当前的事件。可能有的同学不了解sticky<br>event，这里解释下：</p>
<ul>
<li>我们都知道**普通事件是先注册，然后发送事件才能收到；而粘性事件，在发送事件之后再订阅该事件也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非你手动解除注册<br>**。</li>
</ul>
<p>在注释4处，新建了三个不同类型的事件发送器，这里总结下：</p>
<ul>
<li>mainThreadPoster：主线程事件发送器，通过它的mainThreadPoster.enqueue(subscription, event)方法可以将订阅信息和对应的事件进行入队，然后通过<br>handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li>
<li>backgroundPoster：后台事件发送器，通过它的enqueue() 将方法加入到后台的一个队列，最后通过线程池去执行，注意，它在<br>Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li>
<li>asyncPoster：实现逻辑类似于backgroundPoster，不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster则是异步运行的，可以同时接收多个任务。</li>
</ul>
<p>我们再回到注释5这行代码，这里新建了一个subscriberMethodFinder对象，这是从EventBus中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到<br><strong>组合优于继承</strong>的这种实现思想。在注释6处，从builder中取出了一个默认的线程池对象，它由**Executors的newCachedThreadPool()*<br>*方法创建，它是一个**有则用、无则创建、无数量上限**的线程池。</p>
<p>分析完这些核心的字段之后，后面的讲解就比较轻松了，接着查看EventBus的regist()方法：</p>
<figure class="highlight wren"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">Object</span> <span class="hljs-params">subscriber</span>) {<br>    <span class="hljs-title class_">Class</span><span class="hljs-operator">&lt;</span>?<span class="hljs-operator">&gt;</span> <span class="hljs-variable">subscriberClass</span> <span class="hljs-operator">=</span> <span class="hljs-variable">subscriber</span>.<span class="hljs-property">getClass</span>();<br>    <br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">SubscriberMethod</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">subscriberMethods</span> <span class="hljs-operator">=</span> <span class="hljs-variable">subscriberMethodFinder</span>.<span class="hljs-property">findSubscriberMethods</span>(<span class="hljs-variable">subscriberClass</span>);<br>    <span class="hljs-title function_">synchronized</span> (<span class="hljs-variable language_">this</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">SubscriberMethod</span> <span class="hljs-variable">subscriberMethod</span> : <span class="hljs-variable">subscriberMethods</span>) {<br>            <span class="hljs-comment">// 2</span><br>            <span class="hljs-title function_">subscribe</span>(<span class="hljs-variable">subscriber</span>, <span class="hljs-variable">subscriberMethod</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，根据当前注册类获取 subscriberMethods这个订阅方法列表 。在注释2处，使用了增强for循环令subsciber对象 对<br>subscriberMethods 中每个 SubscriberMethod 进行订阅。</p>
<p>接着查看SubscriberMethodFinder的findSubscriberMethods()方法：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">List&lt;SubscriberMethod&gt; <span class="hljs-title">findSubscriberMethods</span>(<span class="hljs-params">Class&lt;?&gt; subscriberClass</span>)</span> {<br>    <span class="hljs-comment">// 1</span><br>    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.<span class="hljs-keyword">get</span>(subscriberClass);<br>    <span class="hljs-keyword">if</span> (subscriberMethods != <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> subscriberMethods;<br>    }<br><br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">if</span> (ignoreGeneratedIndex) {<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } <span class="hljs-keyword">else</span> {<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    <span class="hljs-keyword">if</span> (subscriberMethods.isEmpty()) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EventBusException(<span class="hljs-string">"Subscriber "</span> + subscriberClass<br>                + <span class="hljs-string">" and its super classes have no public methods with the @Subscribe annotation"</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        <span class="hljs-keyword">return</span> subscriberMethods;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，如果缓存中有subscriberClass对象对应 的订阅方法列表，则直接返回。注释2处，先详细说说这个<strong>ignoreGeneratedIndex</strong><br>字段， 它用来<strong>判断是否使用生成的 APT 代码去优化寻找接收事件的过程，如果开启了的话，那么将会通过 subscriberInfoIndexes<br>来快速得到接收事件方法的相关信息</strong>。如果我们没有在项目中接入 EventBus 的 APT，那么可以将 ignoreGeneratedIndex 字段设为<br>false 以提高性能。这里ignoreGeneratedIndex 默认为false，所以会执行findUsingInfo()方法，后面生成 subscriberMethods<br>成功的话会加入到缓存中，失败的话会 抛出异常。</p>
<p>接着查看SubscriberMethodFinder的findUsingInfo()方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> List&lt;SubscriberMethod&gt; find<span class="hljs-constructor">UsingInfo(Class&lt;?&gt; <span class="hljs-params">subscriberClass</span>)</span> {<br>    <span class="hljs-comment">// 1</span><br>    FindState findState = prepare<span class="hljs-constructor">FindState()</span>;<br>    findState.init<span class="hljs-constructor">ForSubscriber(<span class="hljs-params">subscriberClass</span>)</span>;<br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">while</span> (findState.clazz != null) {<br>        findState.subscriberInfo = get<span class="hljs-constructor">SubscriberInfo(<span class="hljs-params">findState</span>)</span>;<br>        <span class="hljs-keyword">if</span> (findState.subscriberInfo != null) {<br>            SubscriberMethod<span class="hljs-literal">[]</span> <span class="hljs-built_in">array</span> = findState.subscriberInfo.get<span class="hljs-constructor">SubscriberMethods()</span>;<br>            <span class="hljs-keyword">for</span> (SubscriberMethod subscriberMethod: <span class="hljs-built_in">array</span>) {<br>                <span class="hljs-keyword">if</span> (findState.check<span class="hljs-constructor">Add(<span class="hljs-params">subscriberMethod</span>.<span class="hljs-params">method</span>, <span class="hljs-params">subscriberMethod</span>.<span class="hljs-params">eventType</span>)</span>) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } <span class="hljs-keyword">else</span> {<br>             <span class="hljs-comment">// 3</span><br>             find<span class="hljs-constructor">UsingReflectionInSingleClass(<span class="hljs-params">findState</span>)</span>;<br>        }<br>        findState.move<span class="hljs-constructor">ToSuperclass()</span>;<br>    }<br>    <span class="hljs-comment">// 4</span><br>    return get<span class="hljs-constructor">MethodsAndRelease(<span class="hljs-params">findState</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，调用了SubscriberMethodFinder的prepareFindState()方法创建了一个新的 FindState 类，来看看这个方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FindState[] FIND_STATE_POOL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FindState</span>[POOL_SIZE];<br><span class="hljs-keyword">private</span> FindState <span class="hljs-title function_">prepareFindState</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">synchronized</span>(FIND_STATE_POOL) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; POOL_SIZE; i++) {<br>            <span class="hljs-type">FindState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> FIND_STATE_POOL[i];<br>            <span class="hljs-keyword">if</span> (state != <span class="hljs-literal">null</span>) {<br>                FIND_STATE_POOL[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span> state;<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FindState</span>();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，会先从 FIND_STATE_POOL 即 FindState 池中取出可用的 FindState（这里的POOL_SIZE为4），如果没有的话，则通过注释2处的代码直接新建<br>一个新的 FindState 对象。</p>
<p>接着来分析下FindState这个类：</p>
<figure class="highlight wren"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindState</span> {<br>    <span class="hljs-operator">...</span>.<br>    <span class="hljs-variable">void</span> <span class="hljs-title function_">initForSubscriber</span>(<span class="hljs-params">Class</span>&lt;?&gt; <span class="hljs-params">subscriberClass</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscriberClass</span> <span class="hljs-operator">=</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-variable">subscriberClass</span>;<br>        <span class="hljs-variable">skipSuperClasses</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-variable">subscriberInfo</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    }<br>    <span class="hljs-operator">...</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>它是 SubscriberMethodFinder 的内部类，这个方法主要做一个初始化、回收对象等工作。</p>
<p>接着回到SubscriberMethodFinder的注释2处的SubscriberMethodFinder()方法：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">private</span> SubscriberInfo getSubscriberInfo(FindState findState) {<br>    <span class="hljs-attribute">if</span> (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) {<br>        <span class="hljs-attribute">SubscriberInfo</span> superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();<br>        <span class="hljs-attribute">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) {<br>            <span class="hljs-attribute">return</span> superclassInfo;<br>        }<br>    }<br>    <span class="hljs-attribute">if</span> (subscriberInfoIndexes != null) {<br>        <span class="hljs-attribute">for</span> (SubscriberInfoIndex index: subscriberInfoIndexes) {<br>            <span class="hljs-attribute">SubscriberInfo</span> <span class="hljs-literal">info</span> = index.getSubscriberInfo(findState.clazz);<br>            <span class="hljs-attribute">if</span> (<span class="hljs-literal">info</span> != null) {<br>                <span class="hljs-attribute">return</span> <span class="hljs-literal">info</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-attribute">return</span> null;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在前面初始化的时候，findState的subscriberInfo和subscriberInfoIndexes 这两个字段为空，所以这里直接返回 null。</p>
<p>接着查看注释3处的findUsingReflectionInSingleClass()方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void find<span class="hljs-constructor">UsingReflectionInSingleClass(FindState <span class="hljs-params">findState</span>)</span> {<br>    Method<span class="hljs-literal">[]</span> methods;<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br>        methods = findState.clazz.get<span class="hljs-constructor">DeclaredMethods()</span>;<br>    } catch (Throwable th) {<br>        methods = findState.clazz.get<span class="hljs-constructor">Methods()</span>;<br>        findState.skipSuperClasses = <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (Method <span class="hljs-keyword">method</span>: methods) {<br>        <span class="hljs-built_in">int</span> modifiers = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Modifiers()</span>;<br>        <span class="hljs-keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>(modifiers &amp; MODIFIERS_IGNORE)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) {<br>            Class&lt;?&gt; <span class="hljs-literal">[]</span> parameterTypes = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ParameterTypes()</span>;<br>            <span class="hljs-keyword">if</span> (parameterTypes.length<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) {<br>                Subscribe subscribeAnnotation = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Annotation(Subscribe.<span class="hljs-params">class</span>)</span>;<br>                <span class="hljs-keyword">if</span> (subscribeAnnotation != null) {<br>                    <span class="hljs-comment">// 重点</span><br>                    Class&lt;?&gt; eventType = parameterTypes<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>                    <span class="hljs-keyword">if</span> (findState.check<span class="hljs-constructor">Add(<span class="hljs-params">method</span>, <span class="hljs-params">eventType</span>)</span>) {<br>                        ThreadMode threadMode = subscribeAnnotation.thread<span class="hljs-constructor">Mode()</span>;<br>                        findState.subscriberMethods.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">SubscriberMethod(<span class="hljs-params">method</span>, <span class="hljs-params">eventType</span>, <span class="hljs-params">threadMode</span>, <span class="hljs-params">subscribeAnnotation</span>.<span class="hljs-params">priority</span>()</span>,  subscribeAnnotation.sticky<span class="hljs-literal">()</span>));<br>                    }<br>                }<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strictMethodVerification<span class="hljs-operator"> &amp;&amp;     </span><span class="hljs-keyword">method</span>.is<span class="hljs-constructor">AnnotationPresent(Subscribe.<span class="hljs-params">class</span>)</span>) {<br>            String methodName = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">"."</span> + <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Name()</span>;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">EventBusException(<span class="hljs-string">"@Subscribe method "</span> + <span class="hljs-params">methodName</span> + <span class="hljs-string">"must have exactly 1 parameter but has "</span> + <span class="hljs-params">parameterTypes</span>.<span class="hljs-params">length</span>)</span>;<br>            }<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strictMethodVerification<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">method</span>.is<span class="hljs-constructor">AnnotationPresent(Subscribe.<span class="hljs-params">class</span>)</span>) {<br>            String methodName = <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">"."</span> + <span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Name()</span>;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">EventBusException(<span class="hljs-params">methodName</span> + <span class="hljs-string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>)</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这个方法很长，大概做的事情是：</p>
<ol>
<li><p><strong>通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 @Subscribe作为注解的方法进行处理</strong>。</p>
</li>
<li><p><strong>在经过经过一轮检查，看看 findState.subscriberMethods是否存在，如果没有，将方法名，threadMode，优先级，是否为 sticky<br>方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中</strong>。</p>
</li>
</ol>
<p>最后，继续查看注释4处的getMethodsAndRelease()方法：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">SubscriberMethod</span>&gt; <span class="hljs-title function_">getMethodsAndRelease</span>(<span class="hljs-params">FindState findState</span>) {<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">SubscriberMethod</span>&gt; subscriberMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(findState.<span class="hljs-property">subscriberMethods</span>);<br>    <span class="hljs-comment">// 2</span><br>    findState.<span class="hljs-title function_">recycle</span>();<br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">FIND_STATE_POOL</span>) {<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable constant_">POOL_SIZE</span>; i++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">FIND_STATE_POOL</span>[i] == <span class="hljs-literal">null</span>) {<br>                <span class="hljs-variable constant_">FIND_STATE_POOL</span>[i] = findState;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> subscriberMethods;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在这里，首先在注释1处，从findState中取出了保存的subscriberMethods。在注释2处，将findState里的保存的所有对象进行回收。在注释3处，把findState存储在<br>FindState 池中方便下一次使用，以提高性能。最后，在注释4处，返回subscriberMethods。接着，<strong>在EventBus的 register() 方法的最后会调用<br>subscribe 方法</strong>：</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">public void register(Object <span class="hljs-keyword">subscriber) </span>{<br>    Class&lt;?&gt; <span class="hljs-keyword">subscriberClass </span>= <span class="hljs-keyword">subscriber.getClass();</span><br><span class="hljs-keyword"></span>    List&lt;<span class="hljs-keyword">SubscriberMethod&gt; </span><span class="hljs-keyword">subscriberMethods </span>= <span class="hljs-keyword">subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">synchronized </span>(this) {<br>        for (<span class="hljs-keyword">SubscriberMethod </span><span class="hljs-keyword">subscriberMethod </span>: <span class="hljs-keyword">subscriberMethods) </span>{<br>            <span class="hljs-keyword">subscribe(subscriber, </span><span class="hljs-keyword">subscriberMethod);</span><br><span class="hljs-keyword"></span>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>继续看看这个subscribe()方法做的事情：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {<br>    Class&lt;?&gt; eventType = subscriberMethod.eventType;<br>    Subscription <span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Subscription</span>(subscriber, subscriberMethod);<br>    <br>    <span class="hljs-comment">// 1</span><br>    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.<span class="hljs-keyword">get</span>(eventType);<br>    <span class="hljs-keyword">if</span> (subscriptions == <span class="hljs-literal">null</span>) {<br>        subscriptions = <span class="hljs-keyword">new</span> <span class="hljs-type">CopyOnWriteArrayList</span> &lt;&gt; ();<br>        subscriptionsByEventType.put(eventType, subscriptions);<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">if</span> (subscriptions.contains(<span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span>)) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">EventBusException</span>(<span class="hljs-string">"Subscriber "</span> + subscriber.getClass() + <span class="hljs-string">" already registered to event "</span> + eventType);<br>        }<br>    }<br>    int size = subscriptions.size();<br>    <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt;= size; i++) {<br>        <span class="hljs-keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.<span class="hljs-keyword">get</span>(i).subscriberMethod.priority) {<br>            subscriptions.add(i, <span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <br>    <span class="hljs-comment">// 3</span><br>    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.<span class="hljs-keyword">get</span>(subscriber);<br>    <span class="hljs-keyword">if</span> (subscribedEvents == <span class="hljs-literal">null</span>) {<br>        subscribedEvents = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        typesBySubscriber.put(subscriber, subscribedEvents);<br>    }<br>    subscribedEvents.add(eventType);<br>    <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">if</span> (subscriberMethod.sticky) {<br>        <span class="hljs-keyword">if</span> (eventInheritance) {<br>            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : <span class="hljs-type">entries</span>) {<br>                Class&lt;?&gt; candidateEventType = entry.getKey();<br>                <span class="hljs-keyword">if</span>(eventType.isAssignableFrom(candidateEventType)) {<br>                Object stickyEvent = entry.getValue();<br>                    checkPostStickyEventToSubscription(<span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span>, stickyEvent);<br>                }<br>            }<br>        } <span class="hljs-keyword">else</span> {<br>            Object stickyEvent = stickyEvents.<span class="hljs-keyword">get</span>(eventType);<br>            checkPostStickyEventToSubscription(<span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span>, stickyEvent);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，会根据 subscriberMethod的eventType，在 subscriptionsByEventType 去查找一个 CopyOnWriteArrayList<br>，如果没有则创建一个新的 CopyOnWriteArrayList，然后将这个 CopyOnWriteArrayList 放入 subscriptionsByEventType 中。在注释2处，<br><strong>添加 newSubscription对象，它是一个 Subscription 类，里面包含着 subscriber 和 subscriberMethod<br>等信息，并且这里有一个优先级的判断，说明它是按照优先级添加的。优先级越高，会插到在当前 List 靠前面的位置</strong><br>。在注释3处，对typesBySubscriber 进行添加，这主要是在EventBus的isRegister()方法中去使用的，目的是用来判断这个 Subscriber对象<br>是否已被注册过。最后，在注释4处，会判断是否是 sticky事件。如果是sticky事件的话，会调用 checkPostStickyEventToSubscription()<br>方法。</p>
<p>接着查看这个checkPostStickyEventToSubscription()方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void check<span class="hljs-constructor">PostStickyEventToSubscription(Subscription <span class="hljs-params">newSubscription</span>, Object <span class="hljs-params">stickyEvent</span>)</span> {<br>    <span class="hljs-keyword">if</span> (stickyEvent != null) {<br>        post<span class="hljs-constructor">ToSubscription(<span class="hljs-params">newSubscription</span>, <span class="hljs-params">stickyEvent</span>, <span class="hljs-params">isMainThread</span>()</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到最终是<strong>调用了postToSubscription()这个方法来进行粘性事件的发送</strong>，对于粘性事件的处理，最后再分析，接下来看看事件是如何post的。</p>
<h3 id="EventBus-getDefault-post-new-CollectEvent"><a href="#EventBus-getDefault-post-new-CollectEvent" class="headerlink" title="EventBus.getDefault().post(new CollectEvent())"></a>EventBus.getDefault().post(new CollectEvent())</h3><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span>(<span class="hljs-params">Object <span class="hljs-keyword">event</span></span>)</span> {<br>    <span class="hljs-comment">// 1</span><br>    PostingThreadState postingState = currentPostingThreadState.<span class="hljs-keyword">get</span>();<br>    List &lt;Object&gt; eventQueue = postingState.eventQueue;<br>    eventQueue.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">event</span>);<br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">if</span> (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (postingState.canceled) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EventBusException(<span class="hljs-string">"Internal error. Abort state was not reset"</span>);<br>        }<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">while</span> (!eventQueue.isEmpty()) {<br>                postSingleEvent(eventQueue.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>), postingState);<br>            }<br>        } <span class="hljs-keyword">finally</span> {<br>            postingState.isPosting = <span class="hljs-literal">false</span>;<br>            postingState.isMainThread = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>注释1处，这里的currentPostingThreadState 是一个 ThreadLocal 类型的对象，里面存储了 PostingThreadState，而<br>PostingThreadState 中包含了一个 eventQueue 和其他一些标志位，相关的源码如下：</p>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal &lt;PostingThreadState&gt; currentPostingThreadState = <span class="hljs-keyword">new</span> ThreadLocal &lt;PostingThreadState&gt; () {<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function">PostingThreadState <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PostingThreadState();<br>}<br>};<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostingThreadState</span> </span>{<br>    <span class="hljs-keyword">final</span> List &lt;Object&gt; eventQueue = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span> isPosting;<br>    <span class="hljs-keyword">boolean</span> isMainThread;<br>    Subscription subscription;<br>    Object event;<br>    <span class="hljs-keyword">boolean</span> canceled;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 中。在注释2处，最后调用了<br>postSingleEvent() 方法，我们继续查看这个方法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void post<span class="hljs-constructor">SingleEvent(Object <span class="hljs-params">event</span>, PostingThreadState <span class="hljs-params">postingState</span>)</span> throws Error {<br>    Class&lt;?&gt; eventClass = event.get<span class="hljs-constructor">Class()</span>;<br>    boolean subscriptionFound = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (eventInheritance) {<br>        <span class="hljs-comment">// 2</span><br>        List&lt;Class&lt;?&gt;&gt; eventTypes = lookup<span class="hljs-constructor">AllEventTypes(<span class="hljs-params">eventClass</span>)</span>;<br>        <span class="hljs-built_in">int</span> countTypes = eventTypes.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = <span class="hljs-number">0</span>; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound <span class="hljs-pattern-match">|=</span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 3</span><br><span class="hljs-pattern-match">            post<span class="hljs-constructor">SingleEventForEventType(<span class="hljs-params">event</span>, <span class="hljs-params">postingState</span>, <span class="hljs-params">clazz</span>)</span>;</span><br><span class="hljs-pattern-match">        }</span><br><span class="hljs-pattern-match">    } <span class="hljs-keyword">else</span> {</span><br><span class="hljs-pattern-match">        subscription<span class="hljs-constructor">Found</span> = post<span class="hljs-constructor">SingleEventForEventType(<span class="hljs-params">event</span>, <span class="hljs-params">postingState</span>, <span class="hljs-params">eventClass</span>)</span>;</span><br><span class="hljs-pattern-match">    }</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span> (!subscription<span class="hljs-constructor">Found</span>) {</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">...</span></span><br><span class="hljs-pattern-match">    }</span><br><span class="hljs-pattern-match">}</span><br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，首先取出 Event 的 class 类型，接着<strong>会对 eventInheritance 标志位 判断，它默认为true，如果设为 true<br>的话，它会在发射事件的时候判断是否需要发射父类事件，设为 false，能够提高一些性能</strong><br>。接着，在注释2处，会调用lookupAllEventTypes() 方法，它的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个<br>eventTypesCache 的缓存，这样就不用重复调用 getSuperclass() 方法。最后，在注释3处会调用postSingleEventForEventType()<br>方法，看下这个方法：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">private <span class="hljs-type">boolean</span> postSingleEventForEventType(<span class="hljs-keyword">Object</span> event, PostingThreadState postingState, <span class="hljs-keyword">Class</span> &lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList &lt;<span class="hljs-keyword">Subscription</span>&gt; subscriptions;<br>    synchronized(this) {<br>        subscriptions = subscriptionsByEventType.<span class="hljs-keyword">get</span>(eventClass);<br>    }<br>    <span class="hljs-keyword">if</span> (subscriptions != <span class="hljs-keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">Subscription</span> <span class="hljs-keyword">subscription</span>: subscriptions) {<br>            postingState.event = event;<br>            postingState.<span class="hljs-keyword">subscription</span> = <span class="hljs-keyword">subscription</span>;<br>            <span class="hljs-type">boolean</span> aborted = <span class="hljs-keyword">false</span>;<br>            try {<br>                postToSubscription(<span class="hljs-keyword">subscription</span>, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = <span class="hljs-keyword">null</span>;<br>                postingState.<span class="hljs-keyword">subscription</span> = <span class="hljs-keyword">null</span>;<br>                postingState.canceled = <span class="hljs-keyword">false</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (aborted) {<br>                break;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，这里直接根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions对象，最后调用了<br>postToSubscription() 方法。</p>
<p>这个时候再看看这个postToSubscription()方法：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postToSubscription</span>(<span class="hljs-params">Subscription subscription, Object <span class="hljs-keyword">event</span>, boolean isMainThread</span>)</span> {<br>    <span class="hljs-keyword">switch</span> (subscription.subscriberMethod.threadMode) {<br>        <span class="hljs-keyword">case</span> POSTING:<br>            invokeSubscriber(subscription, <span class="hljs-keyword">event</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MAIN:<br>            <span class="hljs-keyword">if</span> (isMainThread) {<br>                invokeSubscriber(subscription, <span class="hljs-keyword">event</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                mainThreadPoster.enqueue(subscription, <span class="hljs-keyword">event</span>);<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MAIN_ORDERED:<br>            <span class="hljs-keyword">if</span> (mainThreadPoster != <span class="hljs-literal">null</span>) {<br>                mainThreadPoster.enqueue(subscription, <span class="hljs-keyword">event</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                invokeSubscriber(subscription, <span class="hljs-keyword">event</span>);<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BACKGROUND:<br>            <span class="hljs-keyword">if</span> (isMainThread) {<br>                backgroundPoster.enqueue(subscription, <span class="hljs-keyword">event</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                invokeSubscriber(subscription, <span class="hljs-keyword">event</span>);<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ASYNC:<br>            asyncPoster.enqueue(subscription, <span class="hljs-keyword">event</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-literal">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unknow thread mode: "</span> + subscription.subscriberMethod.threadMode);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从上面可以看出，这里通过threadMode 来判断在哪个线程中去执行方法：</p>
<ol>
<li><p>POSTING：执行 invokeSubscriber() 方法，内部<strong>直接采用反射调用</strong>。</p>
</li>
<li><p>MAIN：<strong>首先去判断当前是否在 UI 线程，如果是的话则直接反射调用，否则调用mainThreadPoster的enqueue()<br>方法，即把当前的方法加入到队列之中，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法</strong>。</p>
</li>
<li><p>MAIN_ORDERED：<strong>与MAIN类似，不过是确保是顺序执行的</strong>。</p>
</li>
<li><p>BACKGROUND：<strong>判断当前是否在 UI 线程，如果不是的话则直接反射调用，是的话通过backgroundPoster的enqueue()方法<br>将方法加入到后台的一个队列，最后通过线程池去执行。注意，backgroundPoster在 Executor的execute()方法 上添加了<br>synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行</strong>。</p>
</li>
<li><p>ASYNC：**逻辑实现类似于BACKGROUND，将任务加入到后台的一个队列，最终由Eventbus 中的一个线程池去调用，这里的线程池与<br>BACKGROUND 逻辑中的线程池用的是同一个，即使用Executors的newCachedThreadPool()<br>方法创建的线程池，它是一个有则用、无则创建、无数量上限的线程池。不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，这里asyncPoster则是异步运行的，可以同时接收多个任务<br>**。</p>
</li>
</ol>
<p>分析完EventBus的post()方法值，接着看看它的unregister()。</p>
<h3 id="EventBus-getDefault-unregister-this"><a href="#EventBus-getDefault-unregister-this" class="headerlink" title="EventBus.getDefault().unregister(this)"></a>EventBus.getDefault().unregister(this)</h3><p>它的核心源码如下所示：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span>(<span class="hljs-params">Object subscriber</span>)</span> {<br>    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.<span class="hljs-keyword">get</span>(subscriber);<br>    <span class="hljs-keyword">if</span> (subscribedTypes != <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) {<br>            <span class="hljs-comment">//1</span><br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        <span class="hljs-comment">// 2</span><br>        typesBySubscriber.<span class="hljs-keyword">remove</span>(subscriber);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>首先，在注释1处，<strong>unsubscribeByEventType() 方法中对 subscriptionsByEventType 移除了该 subscriber 的所有订阅信息</strong><br>。最后，在注释2处，<strong>移除了注册对象和其对应的所有 Event 事件链表</strong>。</p>
<p>最后，再来分析下EventBus中对粘性事件的处理。</p>
<h3 id="EventBus-getDefault-postSticky-new-CollectEvent"><a href="#EventBus-getDefault-postSticky-new-CollectEvent" class="headerlink" title="EventBus.getDefault.postSticky(new CollectEvent())"></a>EventBus.getDefault.postSticky(new CollectEvent())</h3><p>如果想要发射 sticky 事件需要通过 EventBus的postSticky() 方法，内部源码如下所示：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postSticky</span>(<span class="hljs-params">Object <span class="hljs-keyword">event</span></span>)</span> {<br>    synchronized (stickyEvents) {<br>        <span class="hljs-comment">// 1</span><br>        stickyEvents.put(<span class="hljs-keyword">event</span>.getClass(), <span class="hljs-keyword">event</span>);<br>    }<br>    <span class="hljs-comment">// 2</span><br>    post(<span class="hljs-keyword">event</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>在注释1处，先将该事件放入 stickyEvents 中，接着在注释2处使用post()发送事件。前面我们在分析register()方法的最后部分时，其中有关粘性事件的源码如下：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (subscriberMethod.sticky) {<br>    Object stickyEvent = stickyEvents.<span class="hljs-keyword">get</span>(eventType);<br>    <span class="hljs-keyword">if</span> (stickyEvent != <span class="hljs-literal">null</span>) {<br>        postToSubscription(<span class="hljs-keyword">new</span><span class="hljs-type">Subscription</span>, stickyEvent, isMainThread());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>可以看到，在这里**会判断当前事件是否是 sticky 事件，如果是，则从 stickyEvents 中拿出该事件并执行 postToSubscription() 方法<br>**。</p>
<blockquote>
<p>EventBus 的源码在Android主流三方库源码分析系列中可以说是除了ButterKnife之外，算是比较简单的了。但是，它其中的一些思想和设计是值得借鉴的。比如<br><strong>它使用 FindState 复用池来复用 FindState 对象，在各处使用了 synchronized 关键字进行代码块同步的一些优化操作</strong><br>。其中上面分析了这么多，<strong>EventBus最核心的逻辑就是利用了 subscriptionsByEventType<br>这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行</strong>。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Android/" class="category-chain-item">Android</a>
  
  
    <span>></span>
    
  <a href="/categories/Android/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="category-chain-item">知识汇总</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android开源库源码分析</div>
      <div>http://virogu.github.io/2023/08/24/docs/android/zhi-shi-hui-zong/android-kai-yuan-ku-yuan-ma-fen-xi/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>未知</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/24/docs/android/zhi-shi-bi-ji/yi-xie-livedata-nian-xing-shi-jian-jie-jue-fang-an/" title="一些LiveData粘性事件解决方案">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一些LiveData粘性事件解决方案</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/23/docs/git/git/" title="GIT">
                        <span class="hidden-mobile">GIT</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"V9v3WDm9N49RSD9H2LQ6evJF-gzGzoHsz","appKey":"vnpaffWoXVwxIK81KYqPUYqg","path":"window.location.pathname","placeholder":"我有话要说 ~","avatar":"robohash","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true,"visitor":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <span>Copyright&nbsp;&copy;2023</span>&nbsp;
<a href="https://github.com/virogu" target="_blank" rel="nofollow noopener"><span>Virogu</span></a>
<span>&nbsp;|&nbsp;</span>
<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
<i class="iconfont icon-love"></i>
<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
